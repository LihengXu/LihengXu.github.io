<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL并发时经典的死锁及解决方法</title>
    <link href="/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL并发时经典的死锁及解决方法"><a href="#MySQL并发时经典的死锁及解决方法" class="headerlink" title="MySQL并发时经典的死锁及解决方法"></a>MySQL并发时经典的死锁及解决方法</h1><h2 id="1-MySQL都有锁分类"><a href="#1-MySQL都有锁分类" class="headerlink" title="1. MySQL都有锁分类"></a>1. MySQL都有锁分类</h2><blockquote><p>MySQL有三种锁的级别：页级、表级、行级。</p></blockquote><ul><li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></li><li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p></li><li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></li></ul><blockquote><p>算法</p></blockquote><ul><li><p>Next-KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap   </p></li><li><p>Gap锁，不锁记录，仅仅记录前面的Gap</p></li><li><p>Recordlock锁（锁数据，不锁Gap）</p></li></ul><p>总结：所以其实 Next-KeyLocks = Gap锁 + Recordlock锁</p><h2 id="2-什么情况下会造成死锁"><a href="#2-什么情况下会造成死锁" class="headerlink" title="2. 什么情况下会造成死锁"></a>2. 什么情况下会造成死锁</h2><blockquote><p>所谓死锁<DeadLock>: </p><p>是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p></blockquote><p>死锁的关键在于：<strong>两个(或以上)的Session加锁的顺序不一致</strong>。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p><h2 id="3-一些常见的死锁案例"><a href="#3-一些常见的死锁案例" class="headerlink" title="3.  一些常见的死锁案例"></a>3.  一些常见的死锁案例</h2><h3 id="3-1-案例一"><a href="#3-1-案例一" class="headerlink" title="3.1 案例一"></a>3.1 案例一</h3><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>抽象出来就是一个session通过for循环会有几条如下的语句：</p><p>Select * from xxx where id=’随机id’ for update</p><p>基本来说，程序开启后不一会就死锁。</p><p>这可以是说最经典的死锁情形了。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p><strong>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Select * from xxx where id in (xx,xx,xx) for update<br></code></pre></td></tr></table></figure><p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs mysql">例如（以下会话id为主键）：<br><br>Session1:<br><br>mysql&gt; select * from t3 where id in (8,9) for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>|  8 | WA     | f    | 2016-03-02 11:36:30 |<br><br>|  9 | JX     | f    | 2016-03-01 11:36:30 |<br><br>+----+--------+------+---------------------+<br><br>2 rows in set (0.04 sec)<br><br> <br><br> <br><br>Session2:<br><br>select * from t3 where id in (10,8,5) for update;<br><br>锁等待中……<br><br>其实这个时候id&#x3D;10这条记录没有被锁住的，但id&#x3D;5的记录已经被锁住了，锁的等待在id&#x3D;8的这里。<br><br> <br><br>不信请看<br><br>Session3:<br><br>mysql&gt; select * from t3 where id&#x3D;5 for update;<br><br>锁等待中<br><br> <br><br>Session4:<br><br>mysql&gt; select * from t3 where id&#x3D;10 for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>| 10 | JB     | g    | 2016-03-10 11:45:05 |<br><br>+----+--------+------+---------------------+<br><br>1 row in set (0.00 sec)<br><br> <br><br>在其它session中id&#x3D;5是加不了锁的，但是id&#x3D;10是可以加上锁的。<br></code></pre></td></tr></table></figure><h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">以id为主键为例，目前还没有id&#x3D;22的行<br><br>Session1:<br><br>select * from t3 where id&#x3D;22 for update;<br><br>Empty set (0.00 sec)<br><br> <br><br>session2:<br><br>select * from t3 where id&#x3D;23  for update;<br><br>Empty set (0.00 sec)<br><br> <br><br>Session1:<br><br>insert into t3 values(22,&#39;ac&#39;,&#39;a&#39;,now());<br><br>锁等待中……<br><br> <br><br>Session2:<br><br>insert into t3 values(23,&#39;bc&#39;,&#39;b&#39;,now());<br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br></code></pre></td></tr></table></figure><p>当对<font color="FF0000">存在的行</font>进行锁的时候(主键)，mysql就只有行锁。</p><p>当对<font color="FF0000">未存在的行</font>进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有Gap锁）</p><blockquote><p>锁住的范围为：</p><p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p></blockquote><p>如：如果表中目前有已有的id为（11 ， 12）</p><p>那么就锁住（12，无穷大）</p><p>如果表中目前已有的id为（11 ， 30）</p><p>那么就锁住（11，30）</p><p><strong>对于这种死锁的解决办法是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t3(xx,xx) on duplicate key update xx&#x3D;&#39;XX&#39;;<br></code></pre></td></tr></table></figure><p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p><h3 id="3-3-案例三"><a href="#3-3-案例三" class="headerlink" title="3.3 案例三"></a>3.3 案例三</h3><p>直接上情景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t3 where id&#x3D;9 for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>|  9 | JX     | f    | 2016-03-01 11:36:30 |<br><br>+----+--------+------+---------------------+<br><br>1 row in set (0.00 sec)<br><br> <br><br>Session2:<br><br>mysql&gt; select * from t3 where id&lt;20 for update;<br><br>锁等待中<br><br> <br><br>Session1:<br><br>mysql&gt; insert into t3 values(7,&#39;ae&#39;,&#39;a&#39;,now());<br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br></code></pre></td></tr></table></figure><p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p><p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p><p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/zejin2008/p/5262751.html%E8%BD%AC%E8%BD%BD%E8%AF%A5%E6%96%87">https://www.cnblogs.com/zejin2008/p/5262751.html转载该文</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 断点调试技巧</title>
    <link href="/2021/03/15/IDEA%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <url>/2021/03/15/IDEA%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA-断点调试技巧"><a href="#IDEA-断点调试技巧" class="headerlink" title="IDEA 断点调试技巧"></a>IDEA 断点调试技巧</h1><p>简单记录一下IDEA最常用到的debug方式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV1ur4y1P7SV?">[1]</span></a></sup></p><h1 id="1-行断点"><a href="#1-行断点" class="headerlink" title="1. 行断点"></a>1. 行断点</h1><p>普通在左侧打的断点就是行断点</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><h1 id="2-详细断点-源断点"><a href="#2-详细断点-源断点" class="headerlink" title="2. 详细断点 | 源断点"></a>2. 详细断点 | 源断点</h1><p>按住<code>shift</code>键加上鼠标点击代码左侧出现下图</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li><p>如果我们只勾选Enabled，再点击右下角done，则调试效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li>我们可以看到该断点并没有挂起，只是打出断点所触发的位置（具体的类及所在方法）</li></ul></li><li><p>勾选Suspend（挂起）和All，再点击右done，实际就是打了普通行断点，全部线程都会停止</p></li><li><p>勾选Suspend（挂起）和Thread，再点击done，只有<strong>当前线程才会在该断点停止</strong></p></li><li><p>condition中可以添加一些if else条件判断，但触发条件才会停止（高阶用法）</p></li></ul><h1 id="3-方法断点-接口跳转实现类"><a href="#3-方法断点-接口跳转实现类" class="headerlink" title="3. 方法断点 | 接口跳转实现类"></a>3. 方法断点 | 接口跳转实现类</h1><ul><li><p>方法断点既在方法左侧打的断点，如下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li><p>我们可以发现，该断点在进入方法第一句和方法返回的最后一句都会停止</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B92.png"></p></li></ul></li></ul><ul><li><p>如果是在接口的方法打方法断点，则会跳转到相应的实现类的方法第一句和返回出停止</p><ul><li>因此当我们不知道具体是哪一个实现类时可以直接在接口打方法断点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B93.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B94.png"></p></li></ul><h1 id="4-异常断点-全局捕获"><a href="#4-异常断点-全局捕获" class="headerlink" title="4. 异常断点 | 全局捕获"></a>4. 异常断点 | 全局捕获</h1><p>点击左下的断点图标如图</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9.png"></p><p>则会显示这么一个界面</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B92.png"></p><p>先选中Exception Breakpoints，在点左上加号添加</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B93.png"></p><p>再选中第三项</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B94.png"></p><p>那么可以再弹出窗口搜索你想要全局捕获的异常断点，也可以搜索你自己定义的异常</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B95.png"></p><p>最后添加并点击done确认</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B96.png"></p><p>那么在debug时就能捕获到异常并停下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B97.png"></p><h1 id="5-字段断点-读写监控"><a href="#5-字段断点-读写监控" class="headerlink" title="5. 字段断点 | 读写监控"></a>5. 字段断点 | 读写监控</h1><p>在类的成员变量左侧打断点</p><p>可以监控这个成员整个生命周期值的变化</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_%E5%AD%97%E6%AE%B5%E6%96%AD%E7%82%B9.png"></p><p>下面我们看看debug的效果</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_%E5%AD%97%E6%AE%B5%E6%96%AD%E7%82%B92.png"></p><p>我们可以看到在字段断点在监控的某一个字段某一个属性值一旦发生写的操作，改变了它的值就会触发停顿。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1ur4y1P7SV">https://www.bilibili.com/video/BV1ur4y1P7SV</a>?<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级</title>
    <link href="/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p>基于<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">MySQL高级</a>的学习笔记<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV12b411K7Zu?p=179">[2]</span></a></sup></p><blockquote><p>内容说明：</p><p>MySQL 是目前最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 也是目前最好的 RDBMS 应用软件之一。随着淘宝去IOE(去除IBM小型机、Oracle数据库及EMC存储设备)化的推进，MySQL 数据库在当前的互联网应用中变得越来越重要。</p><p>包括的MySQL 高级知识：索引，如何避免索引失效，索引优化策略，innodb和myisam存储引擎，MySQL锁机制，配置MySQL主从复制，explain、show profile、慢查询日志等日常SQL诊断和性能分析策略。</p></blockquote><h2 id="1-MySQL的架构介绍"><a href="#1-MySQL的架构介绍" class="headerlink" title="1.MySQL的架构介绍"></a>1.MySQL的架构介绍</h2><h3 id="1-1-MySQL简介"><a href="#1-1-MySQL简介" class="headerlink" title="1.1 MySQL简介"></a>1.1 MySQL简介</h3><ul><li><p>概述：关系型数据库管理系统RDBMS</p></li><li><p>高级MySQL：完整的mysql优化需要很深的功底，大公司有专门的DBA</p><ul><li><p>数据库内部结构和原理</p></li><li><p>数据库建模优化</p></li><li><p>数据库索引建立</p></li><li><p>SQL语句优化</p></li><li><p>SQL编程</p></li><li><p>mysql服务器安装配置</p></li><li><p>数据库的性能监控分析与系统优化</p></li><li><p>各种参数常量设定</p></li><li><p>主从复制</p></li><li><p>分布式架构搭建、垂直切割和水平切割</p></li><li><p>数据迁移</p></li><li><p>容灾备份和恢复</p></li><li><p>shell或python等脚本语言开发</p></li><li><p>对开源数据库进行二次开发</p></li></ul></li></ul><h3 id="1-2-MysqlLinux版的安装（mysql5-5）"><a href="#1-2-MysqlLinux版的安装（mysql5-5）" class="headerlink" title="1.2 MysqlLinux版的安装（mysql5.5）"></a>1.2 MysqlLinux版的安装（mysql5.5）</h3><ul><li>下载地址：</li></ul><p>官网下载地址：<a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a>     </p><ul><li><p>拷贝&amp;解压缩</p></li><li><p>检查工作</p><ul><li><p>检查是否安装过mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 执行安装命令前，先执行查询命令</span><br>rpm -qa|grep mysql<br><span class="hljs-meta">#</span><span class="bash"> 如果存在mysql-libs的旧版本包如下：请先执行卸载命令</span><br>rpm -e --nodeps  mysql-libs  <br></code></pre></td></tr></table></figure></li><li><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -R 777 /tmp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在mysql的安装文件目录下执行：</span><br>rpm -ivh MySQL-server-5.5.54-1.linux2.6.x86_64.rpmrpm -ivh MySQL-client-5.5.54-1.linux2.6.x86_64.rpm <br></code></pre></td></tr></table></figure></li></ul><ul><li><p>查看MySQL安装版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqladmin --version<br></code></pre></td></tr></table></figure></li><li><p>mysql服务的启+停</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start<br>ps -ef|grep mysql # 查看服务是否开启<br>service mysql stop<br></code></pre></td></tr></table></figure></li><li><p>首次登陆</p><p>安装完成后会提示出如下的提示：在mysql首次登录前要给 root 账号设置密码 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动服务后，执行命令</span> <br>/usr/bin/mysqladmin -u root  password &#x27;123123&#x27;<br><span class="hljs-meta">#</span><span class="bash"> 登录</span> <br>mysql -uroot -p123123  <br></code></pre></td></tr></table></figure></li><li><p>自启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chkconfig mysql on # 设置开机自启动<br>chkconfig --list | grep mysql<br>ntsysv # 看到[*]mysql这一行，表示开机后会自启动mysql<br></code></pre></td></tr></table></figure></li><li><p>mysql的安装位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef|grep mysql # 在linux下查看安装目录<br></code></pre></td></tr></table></figure><p> 参数路径解释备注</p><ul><li><p>basedir:  /usr/bin 相关命令目录mysqladmin mysqldump等命令</p></li><li><p>datadir: /var/lib/mysql/ mysql数据库文件的存放路径 </p></li><li><p>plugin-dir: /usr/lib64/mysql/pluginmysql插件存放路径</p></li><li><p>log-error: /var/lib/mysql/jack.atguigu.errmysql错误日志路径</p></li><li><p>pid-file: /var/lib/mysql/jack.atguigu.pid进程pid文件</p></li><li><p>socket:/var/lib/mysql/mysql.sock本地连接时用的unix套接字文件</p></li><li><p>/usr/share/mysql 配置文件目录mysql脚本及配置文件</p></li><li><p>/etc/init.d/mysql服务启停相关脚本 </p></li></ul></li><li><p>mysql修改字符集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 查看字符集设置</span><br>show variables like &#x27;character%&#x27;;<br>show variables like &#x27;%char%&#x27;;<br><span class="hljs-meta">#</span><span class="bash"> 默认的是客户端和服务器都用了latin1，所以会乱码</span><br><br><span class="hljs-meta">#</span><span class="bash"> 2. 修改my.cnf</span><br><span class="hljs-meta">#</span><span class="bash"> 在/usr/share/mysql/ 中找到my.cnf的配置文件，拷贝其中的my-huge.cnf 到/etc/, 并命名为my.cnf mysql</span><br><span class="hljs-meta">#</span><span class="bash"> 优先选中/etc/下的配置文件然后修改my.cnf:</span><br>[client]<br>default-character-set=utf8<br>[mysqld]<br>character_set_server=utf8character_set_client=utf8collation-server=utf8_general_ci<br>[mysql]<br>default-character-set=utf8<br><br><span class="hljs-meta">#</span><span class="bash"> 3. 重新启动mysql</span><br><span class="hljs-meta">#</span><span class="bash"> 但是原库的设定不会发生变化，参数修改之对新建的数据库生效</span> <br><br><span class="hljs-meta">#</span><span class="bash"> 4. 已生成的库表字符集如何变更修改数据库的字符集</span><br>alter database mytest character set &#x27;utf8&#x27;;<br><span class="hljs-meta">#</span><span class="bash"> 修改数据表的字符集</span><br>alter table user convert to  character set &#x27;utf8&#x27;; <br>但是原有的数据如果是用非&#x27;utf8&#x27;编码的话，数据本身不会发生改变。     <br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-mysql配置文件"><a href="#1-3-mysql配置文件" class="headerlink" title="1.3 mysql配置文件"></a>1.3 mysql配置文件</h3><p>  （先大致了解，混个眼熟）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p><h3 id="1-4-mysql逻辑框架简介"><a href="#1-4-mysql逻辑框架简介" class="headerlink" title="1.4 mysql逻辑框架简介"></a>1.4 mysql逻辑框架简介</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png"></p><blockquote><p>和其它数据库相比，MySQL有点与众不同，<strong>它的架构可以在多种不同场景中应用并发挥良好作用</strong>。</p><p>主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。</p><p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p></blockquote><ul><li><p>连接层 </p><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p></li><li><p>服务层</p><ol><li>Management Serveices &amp; Utilities： 系统管理和控制工具 </li><li>SQL Interface: SQL接口   接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li><li>Parser: 解析器    SQL命令传递到解析器的时候会被解析器验证和解析。</li><li> Optimizer: 查询优化器。   SQL语句在查询之前会使用查询优化器对查询进行优化。   用一个例子就可以理解： select uid,name from user where gender= 1;   优化器来决定先投影还是先过滤。</li><li>Cache和Buffer： 查询缓存。   如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。   这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等    缓存是负责读，缓冲负责写。</li></ol></li><li><p>引擎层 </p><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB </p></li><li><p>存储层 </p><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p></li></ul><h3 id="1-5-mysql存储引擎"><a href="#1-5-mysql存储引擎" class="headerlink" title="1.5 mysql存储引擎"></a>1.5 mysql存储引擎</h3><h4 id="1-5-1-查看命令"><a href="#1-5-1-查看命令" class="headerlink" title="1.5.1 查看命令"></a>1.5.1 查看命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 看你的mysql现在已提供什么存储引擎</span><br>show engines; <br><span class="hljs-meta">#</span><span class="bash"> 看你的mysql当前默认的存储引擎:</span>  <br>show variables like &#x27;%storage_engine%&#x27;; <br></code></pre></td></tr></table></figure><h4 id="1-5-2-MyISAM和InnoDB"><a href="#1-5-2-MyISAM和InnoDB" class="headerlink" title="1.5.2  MyISAM和InnoDB"></a>1.5.2  <font color=#FF0000><strong>MyISAM和InnoDB</strong></font></h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png"></p><h4 id="1-5-3-各个存储引擎介绍"><a href="#1-5-3-各个存储引擎介绍" class="headerlink" title="1.5.3 各个存储引擎介绍"></a>1.5.3 各个存储引擎介绍</h4><ol><li><strong>InnoDB</strong>存储引擎：InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况 </li><li><strong>MyISAM</strong>存储引擎：MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 </li><li>Archive引擎：Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。 </li><li>Blackhole引擎：Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </li><li>CSV引擎：CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。 </li><li>Memory引擎：如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis) </li><li>Federated引擎：Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。 </li></ol><h4 id="1-5-4-阿里巴巴、淘宝用哪个"><a href="#1-5-4-阿里巴巴、淘宝用哪个" class="headerlink" title="1.5.4 阿里巴巴、淘宝用哪个"></a>1.5.4 阿里巴巴、淘宝用哪个</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png"></p><h2 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2.  索引优化分析"></a>2.  索引优化分析</h2><h3 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png"></p><h3 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png"></p><ul><li><p>SQL解析：机读顺序（先from）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png"></p></li><li><p>Join图（重点，基本功一定要记住）：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BE.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_9_join%E5%9B%BE.png"></p></li></ul><h3 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h3><h4 id="2-3-1-索引是什么（重点）"><a href="#2-3-1-索引是什么（重点）" class="headerlink" title="2.3.1 索引是什么（重点）"></a>2.3.1 索引是什么（重点）</h4><blockquote><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p></blockquote><ul><li><p><strong>索引的本质</strong>：索引是<font color=#FF0000>数据结构</font></p></li><li><p>索引的目的：在于提高查询效率</p><p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p></li><li><p>简单理解： <font color=#FF0000><strong>索引是排好序的快速查找数据结构</strong></font> </p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png"></p><ul><li>二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。</li><li>B-TREE：(B:balance) 会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)  </li><li>B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。</li><li>B+TREE：Innodb 所使用的索引</li></ul></li><li><p><font color=#FF0000><strong>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引</strong></font>。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p></li></ul><h4 id="2-3-2-索引的优势"><a href="#2-3-2-索引的优势" class="headerlink" title="2.3.2 索引的优势"></a>2.3.2 索引的优势</h4><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><h4 id="2-3-3-索引的劣势"><a href="#2-3-3-索引的劣势" class="headerlink" title="2.3.3 索引的劣势"></a>2.3.3 索引的劣势</h4><ul><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要<strong>占用空间</strong>的</p></li><li><p>虽然索引大大<strong>提高了查询速度</strong>，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</p></li><li><p><font color=#FF0000><strong>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</strong></font></p></li></ul><h4 id="2-3-4-索引的分类"><a href="#2-3-4-索引的分类" class="headerlink" title="2.3.4 索引的分类"></a>2.3.4 索引的分类</h4><h5 id="2-3-4-1-单值索引"><a href="#2-3-4-1-单值索引" class="headerlink" title="2.3.4.1 单值索引"></a>2.3.4.1 单值索引</h5><blockquote><p>即一个索引只包含单个列，一个表可以有多个单列索引</p></blockquote><h5 id="2-3-4-2-唯一索引"><a href="#2-3-4-2-唯一索引" class="headerlink" title="2.3.4.2 唯一索引"></a>2.3.4.2 唯一索引</h5><blockquote><p>索引列的值必须唯一，但允许有空值</p></blockquote><h5 id="2-3-4-3-复合索引"><a href="#2-3-4-3-复合索引" class="headerlink" title="2.3.4.3 复合索引"></a>2.3.4.3 复合索引</h5><blockquote><p>即一个索引包含多个列</p></blockquote><h5 id="2-3-4-4-主键索引"><a href="#2-3-4-4-主键索引" class="headerlink" title="2.3.4.4 主键索引"></a>2.3.4.4 主键索引</h5><blockquote><p>设定为主键后数据库会自动建立索引，innodb为聚簇（聚集）索引</p><p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><h5 id="2-3-4-5-基本语法"><a href="#2-3-4-5-基本语法" class="headerlink" title="2.3.4.5 基本语法"></a>2.3.4.5 基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 创建<br>CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length))<br>ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) <br><br># 2. 删除<br>DROP INDEX [indexName] ON mytable<br><br># 3. 查看<br>SHOW INDEX FROM table_name\G<br><br># 4. 使用ALTER命令<br># 有四种方式来添加数据表的索引：<br>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) # 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。<br>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list) # 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次<br>ALTER TABLE tbl_name ADD INDEX index_name (column_list) # 添加普通索引，索引值可出现多次。<br>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) #该语句指定了索引为 FULLTEXT ，用于全文索引。 <br></code></pre></td></tr></table></figure><h4 id="2-3-5-mysql索引结构⭐"><a href="#2-3-5-mysql索引结构⭐" class="headerlink" title="2.3.5 mysql索引结构⭐"></a>2.3.5 mysql索引结构⭐</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><ul><li><p>B-Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><ul><li>d为大于1的一个正整数，称为B-Tree的度。</li><li>h为一个正整数，称为B-Tree的高度。</li><li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li><li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li><li>所有叶节点具有相同的深度，等于树高h。</li><li>key和指针互相间隔，节点两端是指针。</li><li>一个节点中的key从左到右非递减排列。</li><li>所有节点组成树结构。</li><li>每个指针要么为null，要么指向另外一个节点。</li><li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li><li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li><li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png"></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">BTree_Search(node, key) &#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    foreach(node.key)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(node.key[i] == key) <span class="hljs-keyword">return</span> node.data[i];<br>            <span class="hljs-keyword">if</span>(node.key[i] &gt; key) <span class="hljs-keyword">return</span> BTree_Search(point[i]-&gt;node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> BTree_Search(point[i+<span class="hljs-number">1</span>]-&gt;node);<br>&#125;<br>data = BTree_Search(root, my_key);<br></code></pre></td></tr></table></figure><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p></li><li><p>B+Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li><p>每个节点的指针上限为2d而不是2d+1。</p></li><li><p>内节点不存储data，只存储key；叶子节点不存储指针。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png"></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p></li><li><p>带有顺序访问指针的B+Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png"></p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p></li><li><p>为什么使用B-Tree（B+Tree）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础</p><p>考虑到<strong>主存存取原理</strong>，<strong>磁盘存取原理</strong>，<strong>局部性原理与磁盘预读</strong>详细见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li><p>一般使用磁盘I/O次数评价索引结构的优劣。</p></li><li><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><blockquote><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p></blockquote></li><li><p><font color=#FF0000><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(logdN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）</strong></font></p></li><li><p>综上所述，用B-Tree作为索引结构效率是非常高的</p></li><li><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多</p></li></ul></li></ul><ul><li><p>B+Tree适合外存索引的原因<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup>：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png"></p></li></ul><ul><li><p>MyISAM索引实现<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png"></p><blockquote><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png"></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><blockquote><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p></blockquote></li></ul><ul><li><p>InnoDB索引实现<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p></li><li><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png"></p><blockquote><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><ul><li><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如下图为定义在Col3上的一个辅助索引</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png"></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p></li></ul></li></ul><h4 id="2-3-6-哪些情况需要创建索引"><a href="#2-3-6-哪些情况需要创建索引" class="headerlink" title="2.3.6 哪些情况需要创建索引"></a>2.3.6 哪些情况需要创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><h4 id="2-3-7-哪些情况不需要创建索引"><a href="#2-3-7-哪些情况不需要创建索引" class="headerlink" title="2.3.7 哪些情况不需要创建索引"></a>2.3.7 哪些情况不需要创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><p>关于<strong>2.3.7.4</strong>的判断公式：<img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><h3 id="2-4-索引性能分析"><a href="#2-4-索引性能分析" class="headerlink" title="2.4 索引性能分析"></a>2.4 索引性能分析</h3><h4 id="2-4-1-MySQL-Query-Optimizer"><a href="#2-4-1-MySQL-Query-Optimizer" class="headerlink" title="2.4.1 MySQL Query Optimizer"></a>2.4.1 MySQL Query Optimizer</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png"></p><h4 id="2-4-2-MySQL常见瓶颈"><a href="#2-4-2-MySQL常见瓶颈" class="headerlink" title="2.4.2 MySQL常见瓶颈"></a>2.4.2 MySQL常见瓶颈</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png"></p><h4 id="2-4-3-Explain"><a href="#2-4-3-Explain" class="headerlink" title="2.4.3 Explain"></a>2.4.3 <font color=#FF0000><strong>Explain</strong></font></h4><h5 id="2-4-3-1-Explain是什么"><a href="#2-4-3-1-Explain是什么" class="headerlink" title="2.4.3.1 Explain是什么"></a>2.4.3.1 Explain是什么</h5><blockquote><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p></blockquote><p>官网介绍: <a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">http://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p><h5 id="2-4-3-2-Explain能干嘛"><a href="#2-4-3-2-Explain能干嘛" class="headerlink" title="2.4.3.2 Explain能干嘛"></a>2.4.3.2 Explain能干嘛</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png"></p><h5 id="2-4-3-3-Explain怎么用"><a href="#2-4-3-3-Explain怎么用" class="headerlink" title="2.4.3.3 Explain怎么用"></a>2.4.3.3 Explain怎么用</h5><blockquote><p>Explain + SQL语句</p></blockquote><ul><li><p>执行计划包含的信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png"></p></li></ul><h5 id="2-4-3-4-Explain执行计划各字段解释"><a href="#2-4-3-4-Explain执行计划各字段解释" class="headerlink" title="2.4.3.4 Explain执行计划各字段解释"></a>2.4.3.4 Explain执行计划各字段解释</h5><ul><li><p>id ⭐：</p><ul><li><p>含义：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的<strong>顺序</strong></p></li><li><p>三种情况：</p><ul><li><p>id相同：执行顺序由上至下</p></li><li><p>id不同：如果是子查询，id的序号会递增，<font color=#FF0000><strong>id值越大优先级越高</strong></font>，越先被执行</p></li><li><p>id相同/不同，同时存在：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png"></p><p>衍生表 = derived2 –&gt; derived + 2 </p><p>（2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）</p></li></ul></li></ul></li></ul><ul><li><p>select_type：</p><ul><li><p>包含：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png"></p></li><li><p>查询的类型：</p><p>主要是用于区别：普通查询、联合查询、子查询等的复杂查询</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png"></p></li></ul></li></ul><ul><li>table：显示这一行的数据是关于哪张表的</li></ul><ul><li><p>type⭐：</p><ul><li><p>包含：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png"></p></li><li><p> type显示的是访问类型，是较为重要的一个指标</p></li><li><p><font color=#FF0000><strong>结果值从最好到最坏依次是</strong></font>：</p><p>(system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL )</p><p><font color=#FF0000><strong>简化版（记住）</strong></font>：<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong> 一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png"></p></li></ul></li></ul><ul><li>possible_keys：<ul><li>显示可能应用在这张表中的索引，一个或多个。</li><li>查询涉及到的字段上若存在索引，则该索引将被列出，<font color=#FF0000><strong>但不一定被查询实际使用</strong></font></li></ul></li></ul><ul><li>key⭐：<ul><li>实际使用的索引。如果为NULL，则没有使用索引、索引失效</li><li><font color=#0000FF><strong>查询中若使用了覆盖索引，则该索引和查询的select字段重叠</strong></font></li></ul></li></ul><ul><li>key_len：<ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。不损失精度性的情况下，长度越短越好 </li><li>key_len字段能够帮你检查是否充分的利用上了索引</li></ul></li></ul><ul><li>ref：<ul><li>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li></ul></li></ul><ul><li>rows⭐：<ul><li>rows列显示MySQL认为它执行查询时必须检查的行数。</li><li>越少越好</li></ul></li></ul><ul><li>Extra⭐：<ul><li><p>包含不适合在其他列中显示但十分重要的额外信息</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png"></p></li><li><p><font color=#0000FF><strong>覆盖索引</strong></font>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p><p>①一个索引 </p><p>②包含了(或覆盖了)[select子句]与查询条件[Where子句]中 </p><p>③所有需要的字段就叫做<font color=#FF0000><strong>覆盖索引</strong></font>。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png"></p><p><strong>理解</strong>：     </p><blockquote><p>select id , name from t_xxx where age=18;   </p><p>有一个组合索引 idx_id_name_age_xxx 包含了(覆盖了) id,name,age三个字段。查询时直接将建立了索引的列读取出来了，而不需要去查找所在行的其他数据, 所以很高效。</p></blockquote><p>(个人认为：在数据量较大，固定字段查询情况多时可以使用这种方法。)</p></li></ul></li></ul><h3 id="2-5-查询优化"><a href="#2-5-查询优化" class="headerlink" title="2.5 查询优化"></a>2.5 查询优化</h3><h4 id="2-5-1-索引优化"><a href="#2-5-1-索引优化" class="headerlink" title="2.5.1 索引优化"></a>2.5.1 索引优化</h4><h5 id="2-5-1-1-索引分析"><a href="#2-5-1-1-索引分析" class="headerlink" title="2.5.1.1 索引分析"></a>2.5.1.1 索引分析</h5><ul><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=209">单表分析案例</a></p></li><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=210">多表分析案例</a></p></li><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=211">三表分析案例</a></p><ul><li>尽可能减少Join语句的NextedLoop的循环总次数：永远用小结果集驱动大结果集</li><li>优先优化NestedLoop的内层循环</li><li><font color=#FF0000><strong>保证Join语句中被驱动表上Join条件的字段已经被索引</strong></font></li><li>当无法保证被驱动表的Join条件字段被索引且内存充足的前提下，不要太吝啬JoinBuffer的设置</li></ul></li></ul><h5 id="2-5-1-2-索引失效"><a href="#2-5-1-2-索引失效" class="headerlink" title="2.5.1.2 索引失效"></a>2.5.1.2 <font color=#FF0000><strong>索引失效</strong></font></h5><ul><li><font color=#FF0000><strong>联合索引在B+Tree上的存储结构及数据查找方式.</strong></font> ⭐，具体参考<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/feichitianxia/article/details/107997795">[3]</span></a></sup>（基于底层去理解索引失效）<ul><li>这里贴一个简单的联合索引的结构图，具体看上面的帖子</li><li><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png"></li></ul></li><li>索引失效案例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"></p><ul><li><p>小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png"></p></li></ul><h5 id="2-5-1-3-一般性建议"><a href="#2-5-1-3-一般性建议" class="headerlink" title="2.5.1.3 一般性建议"></a>2.5.1.3 一般性建议</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png"></p><h5 id="2-5-1-4-优化口诀"><a href="#2-5-1-4-优化口诀" class="headerlink" title="2.5.1.4 优化口诀"></a>2.5.1.4 优化口诀</h5><p>建议理解，不用背</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png"></p><h4 id="2-5-2-查询优化"><a href="#2-5-2-查询优化" class="headerlink" title="2.5.2 查询优化"></a>2.5.2 查询优化</h4><blockquote><p>对于数据库分析</p><ol><li>观察，至少跑一天，看看生产的慢SQL情况。</li><li>开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li><li>explain+慢SQL分析</li><li>show profile</li><li>运维经理 or DBA来进行SQL数据库服务器的参数调优</li></ol></blockquote><p><strong>总结</strong>：</p><ul><li>慢查询开启并捕获</li><li>explain+慢SQL分析</li><li>show profile查询SQL再MySQL服务器里面的执行细节和生命周期情况</li><li>SQL数据库服务器参数调优</li></ul><h5 id="2-5-2-1-优化原则1：小表驱动大表"><a href="#2-5-2-1-优化原则1：小表驱动大表" class="headerlink" title="2.5.2.1 优化原则1：小表驱动大表"></a>2.5.2.1 优化原则1：小表驱动大表</h5><ul><li><p>类似嵌套循环Nested Loop</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png"></p></li><li><p>in/exists</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png"></p></li></ul><h5 id="2-5-2-2-order-by关键字优化"><a href="#2-5-2-2-order-by关键字优化" class="headerlink" title="2.5.2.2 order by关键字优化"></a>2.5.2.2 order by关键字优化</h5><blockquote><p>尽量使用Index方式排序,避免使用FileSort方式排序</p></blockquote><ul><li><p>MySQL支持二种方式的排序，FileSort和Index</p><ul><li>Index效率高.它指MySQL扫描索引本身完成排序。</li></ul></li><li><p>FileSort方式效率较低。</p></li></ul><blockquote><p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p></blockquote><ul><li>ORDER BY满足两情况，会使用Index方式排序<ul><li>ORDER BY 语句使用索引最左前列</li><li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li><li>where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</li></ul></li></ul><ul><li><p>小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png"></p></li></ul><blockquote><p>如果不在索引列上，filesort有两种算法：</p><p>mysql就要启动<strong>双路排序</strong>和<strong>单路排序</strong></p></blockquote><ul><li>双路排序<ul><li>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。（两次）</li><li><strong>缺点</strong>：取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li></ul></li></ul><ul><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</li><li>它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li><li>结论及引申出的问题：<ul><li>结论：由于单路是后出的，总体而言好过双路</li><li>问题：在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li></ul></li></ul></li></ul><ul><li><p>优化策略</p><ul><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>去掉select 后面不需要的字段</p></li><li><p>以上策略对应的原因：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png"></p></li></ul></li></ul><h5 id="2-5-2-3-group-by关键字优化"><a href="#2-5-2-3-group-by关键字优化" class="headerlink" title="2.5.2.3 group by关键字优化"></a>2.5.2.3 group by关键字优化</h5><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ul><h5 id="2-5-2-4-关联查询优化"><a href="#2-5-2-4-关联查询优化" class="headerlink" title="2.5.2.4 关联查询优化"></a>2.5.2.4 关联查询优化</h5><ul><li>保证被驱动表的join字段已经被索引</li><li>left join 时，选择小表作为驱动表，大表作为被驱动表</li><li>inner join 时，mysql会自己帮你把小结果集的表选为驱动表</li><li>子查询尽量不要放在被驱动表，有可能使用不到索引</li></ul><h5 id="2-5-2-5-子查询优化"><a href="#2-5-2-5-子查询优化" class="headerlink" title="2.5.2.5 子查询优化"></a>2.5.2.5 子查询优化</h5><ul><li>有索引的情况下 用 inner join 是最好的 其次是 in ，exists最糟糕 </li><li>无索引的情况下用 小表驱动大表 因为join 方式需要distinct ，没有索引distinct消耗性能较大 所以 exists性能最佳 in其次 join性能最差</li><li>无索引的情况下大表驱动小表in 和 exists 的性能应该是接近的 都比较糟糕 exists稍微好一点 超不过5%   但是inner join 由于使用了 join buffer 所以快很多如果left join 则最慢 </li></ul><h5 id="2-5-2-6-分页查询优化"><a href="#2-5-2-6-分页查询优化" class="headerlink" title="2.5.2.6 分页查询优化"></a>2.5.2.6 分页查询优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 优化前<br>EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY deptno  LIMIT 10000,40<br># 优化后<br>EXPLAIN SELECT SQL_NO_CACHE * FROM emp INNER JOIN (SELECT id FROM emp e ORDER BY deptno LIMIT 10000,40) a ON a.id&#x3D;emp.id<br></code></pre></td></tr></table></figure><ul><li><p>先利用覆盖索引把要取的数据行的主键取到，然后再用这个主键列与数据表做关联（查询的数据量小了）</p></li><li><p>实践证明： </p><p>①、order by 后的字段（XXX）有索引 </p><p>②、sql 中有 limit 时，  当 select id 或 XXX字段索引包含字段时 ，显示 using index  当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort </p></li></ul><h5 id="2-5-2-7-去重优化"><a href="#2-5-2-7-去重优化" class="headerlink" title="2.5.2.7 去重优化"></a>2.5.2.7 去重优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 将产生重复数据<br>select kcdz from t_mall_sku where id in( 3,4,5,6,8 )<br><br># 使用 distinct 关键字去重消耗性能优化<br>select distinct kcdz from t_mall_sku where id in( 3,4,5,6,8 )<br><br># 能够利用到索引<br>select  kcdz from t_mall_sku where id in( 3,4,5,6,8 )  group by kcdz <br></code></pre></td></tr></table></figure><ul><li><p>尽量不要使用 distinct 关键字去重</p></li><li><p>group by能去重且利用索引</p></li></ul><h2 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3. 查询截取分析"></a>3. 查询截取分析</h2><h3 id="3-1-慢查询日志"><a href="#3-1-慢查询日志" class="headerlink" title="3.1 慢查询日志"></a>3.1 慢查询日志</h3><h4 id="3-1-1-慢查询日志介绍"><a href="#3-1-1-慢查询日志介绍" class="headerlink" title="3.1.1 慢查询日志介绍"></a>3.1.1 慢查询日志介绍</h4><ul><li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 </p></li><li><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。 </p></li><li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。 </p></li></ul><h4 id="3-1-2-慢查询日志使用"><a href="#3-1-2-慢查询日志使用" class="headerlink" title="3.1.2 慢查询日志使用"></a>3.1.2 慢查询日志使用</h4><blockquote><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p></blockquote><ul><li><p>查看是否开启及如何开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看<br>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;<br># 设置开启，只对当前数据库生效<br>set global slow_query_log&#x3D;1;<br></code></pre></td></tr></table></figure></li><li><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png"></p></li></ul><ul><li><p>查看当前多少秒算慢, 以及修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看<br>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;<br># 设置<br>set global long_query_time&#x3D;1;<br># 需要重新连接或新开一个会话才能看到修改值<br>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;<br><br># 改变当前session变量<br>set session long_query_time&#x3D;1;<br></code></pre></td></tr></table></figure></li><li><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show global status like &#39;%Slow_queries%&#39;;  <br></code></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-日志分析工具mysqldumpslow"><a href="#3-1-3-日志分析工具mysqldumpslow" class="headerlink" title="3.1.3 日志分析工具mysqldumpslow"></a>3.1.3 日志分析工具mysqldumpslow</h4><ul><li><p>工作常用参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more<br></code></pre></td></tr></table></figure></li><li><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png"></p></li></ul><h3 id="3-2-批量数据脚本"><a href="#3-2-批量数据脚本" class="headerlink" title="3.2 批量数据脚本"></a>3.2 批量数据脚本</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png"></p><ul><li><p>创建函数，假如报错：This function has none of DETERMINISTIC……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 由于开启过慢查询日志，因为我们开启了 bin-log, 我们就必须为我们的function指定一个参数。<br>show variables like &#39;log_bin_trust_function_creators&#39;;<br>set global log_bin_trust_function_creators&#x3D;1;<br><br># 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法：<br># windows下: my.ini[mysqld]加上log_bin_trust_function_creators&#x3D;1<br># linux下: &#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators&#x3D;1<br></code></pre></td></tr></table></figure></li><li><p>创建函数,保证每条数据都不同</p><ul><li><p>随机产生字符串</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)<br>BEGIN    ##方法开始 <br>DECLARE chars_str VARCHAR(100) DEFAULT   &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;;  ##声明一个 字符窜长度为 100 的变量 chars_str ,默认值  <br>DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;; DECLARE i INT DEFAULT 0;  ##循环开始<br>WHILE i &lt; n DO   <br>SET return_str &#x3D;CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));##concat 连接函数  ，substring(a,index,length) 从index处开始截取<br>SET i &#x3D; i + 1;<br>END WHILE;<br>RETURN return_str;<br>END $$ <br># 假如要删除<br># drop function rand_string;<br></code></pre></td></tr></table></figure></li><li><p>随机产生部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">    DELIMITER $$<br>    CREATE FUNCTION rand_num( ) RETURNS INT(5)<br>BEGIN    <br>    DECLARE i INT DEFAULT 0;<br>    SET i &#x3D; FLOOR(100+RAND()*10);<br>    RETURN i;<br>    END $$  <br>    # 假如要删除<br>    # drop function rand_num;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建存储过程</p><ul><li><p>插入数据的存储过程(往emp表添加随机数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE insert_emp10000(IN START INT(10),IN max_num INT(10))<br>BEGIN  <br>DECLARE i INT DEFAULT 0;   #set autocommit &#x3D;0 把autocommit设置成0  ；提高执行效率 <br>SET autocommit &#x3D; 0;     <br>REPEAT  ##重复 <br>SET i &#x3D; i + 1;   <br>INSERT INTO emp10000 (empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i) ,rand_string(6),&#39;SALESMAN&#39;,0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());   <br>UNTIL i &#x3D; max_num   ##直到  上面也是一个循环<br>END REPEAT;  ##满足条件后结束循环 <br>COMMIT;   ##执行完成后一起提交 <br>END $$ <br># 删除<br># DELIMITER ;<br># drop PROCEDURE insert_emp; <br></code></pre></td></tr></table></figure></li><li><p>插入数据的存储过程(往dept表添加随机数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程，往dept表添加随机数据<br>DELIMITER $$<br>CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))<br>BEGIN  <br>DECLARE i INT DEFAULT 0;<br>SET autocommit &#x3D; 0;     <br>REPEAT   <br>SET i &#x3D; i + 1;   <br>INSERT INTO dept (deptno ,dname,loc ) VALUES (START +i ,rand_string(10),rand_string(8));   <br>UNTIL i &#x3D; max_num   <br>END REPEAT;   <br>COMMIT;   <br>END $$  <br>#删除<br># DELIMITER ; #将 结束标志换回 ;<br># drop PROCEDURE insert_dept;<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>调用存储过程</p><ul><li><p>dept</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER ; #将 结束标志换回 ;<br>CALL insert_dept(100,10); <br></code></pre></td></tr></table></figure></li><li><p>emp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程，往emp表添加50万条数据<br>DELIMITER ;    #将 结束标志换回 ;<br>CALL insert_emp(100001,500000);  <br>CALL insert_emp10000(100001,10000);    <br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3-Show-Profile"><a href="#3-3-Show-Profile" class="headerlink" title="3.3 Show Profile"></a>3.3 Show Profile</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><blockquote><p>是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></blockquote><h4 id="3-3-2-官网介绍"><a href="#3-3-2-官网介绍" class="headerlink" title="3.3.2 官网介绍"></a>3.3.2 官网介绍</h4><p>官网：<a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p><h4 id="3-3-3-默认设置"><a href="#3-3-3-默认设置" class="headerlink" title="3.3.3 默认设置"></a>3.3.3 默认设置</h4><blockquote><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></blockquote><h4 id="3-3-4-分析步骤"><a href="#3-3-4-分析步骤" class="headerlink" title="3.3.4 分析步骤"></a>3.3.4 分析步骤</h4><ul><li><p>看看当前的mysql版本是否支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Show variables like &#39;profiling&#39;; #  默认是关闭，使用前需要开启    <br>set profiling&#x3D;1;  #  开启<br></code></pre></td></tr></table></figure></li><li><p>运行SQL</p></li><li><p>查看结果，show profiles；</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png"></p></li><li><p>诊断SQL，show profile cpu,block io for query  n  (n为上一步前面的问题SQL数字号码);</p><ul><li><p>查询命令的参数</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png"></p></li><li><p>查询结果</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png"></p></li></ul></li></ul><ul><li><p>日常开发需要注意的结论</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png"></p><ul><li><p>创建临时表的性能耗费示例：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png"></p></li></ul></li></ul><h3 id="3-4-全局查询日志"><a href="#3-4-全局查询日志" class="headerlink" title="3.4 全局查询日志"></a>3.4 全局查询日志</h3><h4 id="3-4-1-配置启用"><a href="#3-4-1-配置启用" class="headerlink" title="3.4.1 配置启用"></a>3.4.1 配置启用</h4><p>在mysql的my.cnf中，设置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启</span><br><span class="hljs-attr">general_log</span>=<span class="hljs-number">1</span>  <br><span class="hljs-comment"># 记录日志文件的路径</span><br><span class="hljs-attr">general_log_file</span>=/path/logfile<br><span class="hljs-comment"># 输出格式</span><br><span class="hljs-attr">log_output</span>=FILE<br></code></pre></td></tr></table></figure><h4 id="3-4-2-编码启用"><a href="#3-4-2-编码启用" class="headerlink" title="3.4.2 编码启用"></a>3.4.2 编码启用</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png"></p><blockquote><p><font color=#FF0000><strong>特别的：尽量不要在生产环境开启这个功能</strong></font></p></blockquote><h2 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4. MySQL锁机制"></a>4. MySQL锁机制</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote><h3 id="4-2-锁的分类"><a href="#4-2-锁的分类" class="headerlink" title="4.2 锁的分类"></a>4.2 锁的分类</h3><h4 id="4-2-1-从对数据操作的类型（读-写）分"><a href="#4-2-1-从对数据操作的类型（读-写）分" class="headerlink" title="4.2.1 从对数据操作的类型（读\写）分"></a>4.2.1 从对数据操作的类型（读\写）分</h4><ul><li>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁(排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul><h4 id="4-2-2-从对数据操作的粒度分"><a href="#4-2-2-从对数据操作的粒度分" class="headerlink" title="4.2.2 从对数据操作的粒度分"></a>4.2.2 从对数据操作的粒度分</h4><ul><li>表锁</li><li>行锁</li></ul><h3 id="4-3-三锁"><a href="#4-3-三锁" class="headerlink" title="4.3 三锁"></a>4.3 三锁</h3><h4 id="4-3-1-表锁（偏读）"><a href="#4-3-1-表锁（偏读）" class="headerlink" title="4.3.1 表锁（偏读）"></a>4.3.1 表锁（偏读）</h4><blockquote><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></blockquote><ul><li><p>手动加读写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock tabel 表名 read(write), 表名2 read(write), ...;<br></code></pre></td></tr></table></figure></li><li><p>查看表上加过的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show open tables;<br></code></pre></td></tr></table></figure></li><li><p>释放表锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure></li><li><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png"></p><p>补充：加读锁的session也不能修改加读锁的表。</p><p><font color=#FF0000><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong></font></p></li><li><p>如何分析表锁定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png"></p></li></ul><h4 id="4-3-2-行锁（偏写）"><a href="#4-3-2-行锁（偏写）" class="headerlink" title="4.3.2 行锁（偏写）"></a>4.3.2 行锁（偏写）</h4><blockquote><p>特点：</p><ol><li>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li></ol></blockquote><ul><li><p>行锁支持事务，<a href="http://lihengxu.cn/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/#5-TCL%E8%AF%AD%E8%A8%80">复习初级部分知识⭐</a></p><ul><li><p>重点:事务特性、并发事务导致的问题、事务隔离级别等</p></li><li><p>补充：并发事务导致的问题（更新丢失）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png"></p></li></ul></li></ul><ul><li><p><font color=#FF0000><strong>无索引(或者索引失效)行锁升级为表锁</strong></font></p></li><li><p>间隙锁的危害</p><ul><li><p><strong>间隙锁</strong>: </p><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。 </p></li><li><p><strong>危害</strong>:</p><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p></li></ul></li><li><p><font color=#FF0000><strong>[面试题] 常考如何锁定一行</strong></font></p><p>事务显示加锁<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_33033819/article/details/106445880">[9]</span></a></sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">##在 MySQL 5.7 中<br>共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE<br>排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE<br><br>##在 MySQL 8.0 中<br>共享锁（S）：SELECT * FROM table_name WHERE ... FOR SHARE<br>排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE[NOWAIT|SKIP LOCKED]<br>--NOWAIT:发现有锁等待后会立即返回错误，不用等待锁超时后报错。<br>--SKIP LOCKED:跳过被锁定的行，直接更新其他行，但是这样要注意是否会造成更新结果不符合预期。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p></li></ul><ul><li><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。 </p></li><li><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p></li><li><p>如何分析行锁定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png"></p></li></ul><ul><li>优化建议：<ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁</li><li>涉及相同表的事务，对于调用表的顺序尽量保持一致</li><li>在业务环境允许的情况下,尽可能低级别事务隔离</li></ul></li></ul><h4 id="4-3-2-页锁（了解）"><a href="#4-3-2-页锁（了解）" class="headerlink" title="4.3.2 页锁（了解）"></a>4.3.2 页锁（了解）</h4><blockquote><p>开销和加锁时间界于表锁和行锁之间；</p><p>会出现死锁；</p><p>锁定粒度界于表锁和行锁之间，并发度一般。</p></blockquote><h2 id="5-主从复制⭐"><a href="#5-主从复制⭐" class="headerlink" title="5. 主从复制⭐"></a>5. 主从复制⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png"></p><h3 id="5-1-复制的基本原理"><a href="#5-1-复制的基本原理" class="headerlink" title="5.1 复制的基本原理"></a>5.1 复制的基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></p><h3 id="5-2-复制的基本原则"><a href="#5-2-复制的基本原则" class="headerlink" title="5.2 复制的基本原则"></a>5.2 复制的基本原则</h3><ul><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个salve</li></ul><h3 id="5-3-复制的最大问题"><a href="#5-3-复制的最大问题" class="headerlink" title="5.3 复制的最大问题"></a>5.3 复制的最大问题</h3><blockquote><p>延时</p></blockquote><h3 id="5-4-一主一从常见配置"><a href="#5-4-一主一从常见配置" class="headerlink" title="5.4 一主一从常见配置"></a>5.4 一主一从常见配置</h3><ul><li><p>mysql版本一致且后台以服务运行</p></li><li><p>主从都配置在[mysqld]结点下，都是小写</p></li><li><p>主机修改my.ini配置文件</p><ul><li>[必须]主服务器唯一ID<ul><li>server-id=1</li></ul></li></ul></li><li><p>[必须]启用二进制日志</p><ul><li><p>log-bin=自己本地的路径/data/mysqlbin</p><ul><li>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin</li></ul></li><li><p>[可选]启用错误日志</p><ul><li>log-err=自己本地的路径/data/mysqlerr</li></ul></li><li><p>log-err=D:/devSoft/MySQLServer5.5/data/mys</p></li><li><p>[可选]根目录</p></li><li><p>basedir=”自己本地路径”</p><ul><li>basedir=”D:/devSoft/MySQLServer5.5/“</li></ul></li></ul></li><li><p>[可选]临时目录</p><ul><li><p>tmpdir=”自己本地路径”</p></li><li><p>tmpdir=”D:/devSoft/MySQLServer5.5/“</p></li><li><p>[可选]数据目录</p><ul><li>datadir=”自己本地路径/Data/“</li><li>datadir=”D:/devSoft/MySQLServer5.5/Data/“</li></ul></li></ul></li><li><p>read-only=0 </p><ul><li><p>主机，读写都可以</p></li><li><p>[可选]设置不要复制的数据库</p></li><li><p>binlog-ignore-db=mysql</p></li><li><p>[可选]设置需要复制的数据库</p><ul><li>binlog-do-db=需要复制的主数据库名字</li></ul></li></ul></li><li><p>从机修改my.cnf配置文件</p><ul><li>[必须]从服务器唯一ID</li><li>[可选]启用二进制日志</li></ul></li><li><p>因修改过配置文件，请主机+从机都重启后台mysql服务</p></li><li><p>主机从机都关闭防火墙</p><ul><li>windows手动关闭</li><li>关闭虚拟机linux防火墙    service iptables stop</li></ul></li><li><p>在Windows主机上建立帐户并授权slave</p><ul><li><p>在主机mysql中执行授权命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.授权<br>GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;123456&#39;;<br># 2.执行结束后刷新<br>flush privileges;<br># 3.查询主机状态<br>show master status;<br># 4.记录下File和Position的值<br># 5.执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在Linux从机上配置需要复制的主机</p><ul><li><p>在从机mysql中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机IP&#39;,<br>MASTER_USER&#x3D;&#39;zhangsan&#39;,<br>MASTER_PASSWORD&#x3D;&#39;123456&#39;,<br>MASTER_LOG_FILE&#x3D;&#39;File名字&#39;,MASTER_LOG_POS&#x3D;Position数字;<br></code></pre></td></tr></table></figure></li><li><p>启动从服务器复制功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start slave;<br></code></pre></td></tr></table></figure></li><li><p>查看从机状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show slave status\G<br></code></pre></td></tr></table></figure><p>下面两个参数都是Yes，则说明主从配置成功!</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: Yes</p></li></ul></li></ul><ul><li><p>主机新建库、新建表、insert记录，从机复制</p></li><li><p>如何停止从服务复制功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">stop slave;<br></code></pre></td></tr></table></figure><p>注意停止后，重新授权需要重新查看主机状态，记录下File和Position的值</p></li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">https://www.bilibili.com/video/BV12b411K7Zu?p=179</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/feichitianxia/article/details/107997795">https://blog.csdn.net/feichitianxia/article/details/107997795</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>MySQL5.1参考手册 - <a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://blog.csdn.net/qq_33033819/article/details/106445880">https://blog.csdn.net/qq_33033819/article/details/106445880</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2021/03/12/MySQL_JDBC/"/>
    <url>/2021/03/12/MySQL_JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p><strong>JDO</strong>技术（Java Data Object）</p></li><li><p>第三方O/R工具，如Hibernate, Mybatis 等</p></li></ul><p><strong>JDBC</strong>是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p><h3 id="1-1-JDBC介绍"><a href="#1-1-JDBC介绍" class="headerlink" title="1.1 JDBC介绍"></a>1.1 JDBC介绍</h3><blockquote><p> JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p></blockquote><p><strong>作用</strong>：</p><ul><li><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p></li><li><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p></li></ul><p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png"></p><p>而通过JDBC可以如下访问：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png"></p><blockquote><p>总结：</p><p>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p></blockquote><h3 id="1-2-JDBC-API"><a href="#1-2-JDBC-API" class="headerlink" title="1.2 JDBC API"></a>1.2 JDBC API</h3><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png"></p><h3 id="1-3-JDBC程序编写步骤"><a href="#1-3-JDBC程序编写步骤" class="headerlink" title="1.3  JDBC程序编写步骤"></a>1.3  JDBC程序编写步骤</h3><ul><li>注册驱动</li><li>获取连接</li><li>执行增删改查</li><li>释放资源</li></ul><h2 id="2-快速使用JDBC"><a href="#2-快速使用JDBC" class="headerlink" title="2. 快速使用JDBC"></a>2. 快速使用JDBC</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar <a href="http://dev.mysql.com/downloads/">MySQL的驱动下载地址</a></li><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li>右键–&gt;Add As Library</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC快速入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//1. 导入驱动jar包</span><br>        <span class="hljs-comment">//2.注册驱动</span><br>        <span class="hljs-comment">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>        <span class="hljs-comment">//3.获取数据库连接对象</span><br>        <span class="hljs-comment">// Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br>        Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-comment">//4.定义sql语句</span><br>        <span class="hljs-comment">//String sql = &quot;update account set balance = 2000 where id = 1&quot;;</span><br>        String sql = <span class="hljs-string">&quot;update account set balance = 2000&quot;</span>;<br>        <span class="hljs-comment">//5.获取执行sql的对象 Statement</span><br>        Statement stmt = conn.createStatement();<br>        <span class="hljs-comment">//6.执行sql</span><br>        <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<br>        <span class="hljs-comment">//7.处理结果</span><br>        System.out.println(count);<br>        <span class="hljs-comment">//8.释放资源</span><br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-详解各个对象："><a href="#2-3-详解各个对象：" class="headerlink" title="2.3 详解各个对象："></a>2.3 详解各个对象：</h3><h4 id="2-3-1-DriverManager：驱动管理对象"><a href="#2-3-1-DriverManager：驱动管理对象" class="headerlink" title="2.3.1 DriverManager：驱动管理对象"></a>2.3.1 DriverManager：驱动管理对象</h4><ul><li><p>功能</p><ul><li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar</p><p>static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager</p><p>写代码使用：  Class.forName(“com.mysql.jdbc.Driver”); </p><p>通过反射，加载与注册驱动类，<strong>解耦合（不直接依赖）</strong></p><p>通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>  java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>  &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</p></li><li><p>获取数据库连接：</p><ul><li><p>方法：static Connection getConnection(String url, String user, String password)</p></li><li><p>参数：</p><p><strong>JDBC URL</strong> 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由协议，子协议，子名称三部分组成，各部分间用冒号分隔。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png"></p><p>参数url：指定连接的路径</p><ol><li>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li><li>例子：jdbc:mysql://localhost:3306/db3</li><li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li></ol><p>user：用户名<br>password：密码</p></li></ul></li></ul></li></ul><h4 id="2-3-2-Connection：数据库连接对象"><a href="#2-3-2-Connection：数据库连接对象" class="headerlink" title="2.3.2 Connection：数据库连接对象"></a>2.3.2 Connection：数据库连接对象</h4><ul><li><p>功能</p><ul><li>获取执行sql 的对象</li><li>Statement createStatement()</li><li>PreparedStatement prepareStatement(String sql) </li></ul></li><li><p>管理事务：</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul><h4 id="2-3-3-Statement：执行sql的对象"><a href="#2-3-3-Statement：执行sql的对象" class="headerlink" title="2.3.3 Statement：执行sql的对象"></a>2.3.3 Statement：执行sql的对象</h4><ul><li><p>执行sql</p><ul><li>boolean execute(String sql) ：可以执行任意的sql 了解</li><li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li><li>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</li><li>PreparedStatement prepareStatement(String sql) </li></ul></li><li><p>代码: 对account表完成增删改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Statement stmt = <span class="hljs-keyword">null</span>;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 注册驱动</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>            <span class="hljs-comment">//2. 定义sql(增删改)</span><br>            String sql = <span class="hljs-string">&quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;</span>;<br>            <span class="hljs-comment">//String sql  = &quot;update account set balance = 1500 where id = 3&quot;;</span><br>            <span class="hljs-comment">//String sql  = &quot;delete from account where id = 3&quot;;</span><br>            <span class="hljs-comment">//3.获取Connection对象</span><br>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>            <span class="hljs-comment">//4.获取执行sql的对象 Statement</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">//5.执行sql</span><br>            <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<span class="hljs-comment">//影响的行数</span><br>            <span class="hljs-comment">//6.处理结果</span><br>            System.out.println(count);<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;添加成功！&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;添加失败！&quot;</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//stmt.close();</span><br>            <span class="hljs-comment">//7. 释放资源</span><br>            <span class="hljs-comment">//避免空指针异常</span><br>            <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    stmt.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    conn.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul><h4 id="2-3-4-ResultSet：结果集对象-封装查询结果"><a href="#2-3-4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="2.3.4 ResultSet：结果集对象,封装查询结果"></a>2.3.4 ResultSet：结果集对象,封装查询结果</h4><ul><li><p>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p></li><li><p>getXxx(参数):获取数据</p><ul><li> Xxx：代表数据类型   如： int getInt() ,    String getString()</li><li>参数：<ol><li>int：代表列的编号, 从1开始   如: getString(1)</li><li>String：代表列名称, 如: getDouble(“balance”)</li></ol></li></ul></li><li><p>注意：</p><ul><li><p>使用步骤：</p><ul><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li></ul></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(rs.next())&#123;<br><span class="hljs-comment">//获取数据</span><br><span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-number">1</span>);<br>String name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">double</span> balance = rs.getDouble(<span class="hljs-number">3</span>);<br>System.out.println(id + <span class="hljs-string">&quot;---&quot;</span> + name + <span class="hljs-string">&quot;---&quot;</span> + balance);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-5-PreparedStatement：执行sql的对象"><a href="#2-3-5-PreparedStatement：执行sql的对象" class="headerlink" title="2.3.5 PreparedStatement：执行sql的对象"></a>2.3.5 PreparedStatement：执行sql的对象</h4><ul><li><p>SQL注入问题: 在拼接sql时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题 </p><ul><li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li><li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ </li></ul></li><li><p>解决sql注入问题：使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL：参数使用 ? 作为占位符</p></li><li><p>步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用PreparedStatement实现登录方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username ,String password)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(username == <span class="hljs-keyword">null</span> || password == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//连接数据库判断是否登录成功</span><br>    Connection conn = <span class="hljs-keyword">null</span>;<br>    PreparedStatement pstmt =  <span class="hljs-keyword">null</span>;<br>    ResultSet rs = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//1.获取连接</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        conn =  JDBCUtils.getConnection();<br>        <span class="hljs-comment">//2.定义sql</span><br>        String sql = <span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>;<br>        <span class="hljs-comment">//3.获取执行sql的对象</span><br>        pstmt = conn.prepareStatement(sql);<br>        <span class="hljs-comment">//给?赋值</span><br>        pstmt.setString(<span class="hljs-number">1</span>,username);<br>        pstmt.setString(<span class="hljs-number">2</span>,password);<br>        <span class="hljs-comment">//4.执行查询,不需要传递sql</span><br>        rs = pstmt.executeQuery();<br>        <span class="hljs-comment">//5.判断</span><br>        <span class="hljs-comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;else&#123;</span><br><span class="hljs-comment">                return false;</span><br><span class="hljs-comment">            &#125;*/</span><br>        <span class="hljs-keyword">return</span> rs.next();<span class="hljs-comment">//如果有下一行，则返回true</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        JDBCUtils.close(rs,pstmt,conn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p><ul><li>可以防止SQL注入</li><li>效率更高</li></ul></li></ul><h3 id="2-4-PreparedStatement-Statement-对比"><a href="#2-4-PreparedStatement-Statement-对比" class="headerlink" title="2.4 PreparedStatement/Statement 对比"></a>2.4 PreparedStatement/Statement 对比</h3><blockquote><p><strong>Blob类型的数据</strong> (了解)</p><ol><li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li><li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li></ol><p>注意：如果存储的文件过大，数据库的性能会下降</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png"></p><p><strong>两者区别</strong></p><ul><li><p>代码的可读性和可维护性. Statement的sql拼接是个难题。</p></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li><li><p>PreparedStatement 可以处理Blob类型的数据</p></li><li><p>PreparedStatement 能最大可能提高性能</p><ul><li><p>Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高</p></li><li><p>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行</p></li></ul></li></ul><h2 id="3-JDBCUtils-抽取JDBC工具类"><a href="#3-JDBCUtils-抽取JDBC工具类" class="headerlink" title="3. JDBCUtils: 抽取JDBC工具类"></a>3. JDBCUtils: 抽取JDBC工具类</h2><ul><li><p>目的：简化书写</p></li><li><p>分析：</p><ol><li><p>注册驱动也抽取</p></li><li><p>抽取一个方法获取连接对象</p><ul><li><p>需求：不想传递参数（麻烦），还得保证工具类的通用性。</p></li><li><p>解决：配置文件</p><p> jdbc.properties<br> url=<br> user=<br> password=</p></li></ul></li></ol><ul><li>抽取一个方法释放资源</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取资源文件，获取值。</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 创建Properties集合类。</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br><br>            <span class="hljs-comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br>            ClassLoader classLoader = JDBCUtils.class.getClassLoader();<br>            URL res  = classLoader.getResource(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>            String path = res.getPath();<br>           <span class="hljs-comment">// System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br>            <span class="hljs-comment">//2. 加载文件</span><br>           <span class="hljs-comment">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br>            pro.load(<span class="hljs-keyword">new</span> FileReader(path));<br><br>            <span class="hljs-comment">//3. 获取数据，赋值</span><br>            url = pro.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            user = pro.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            password = pro.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>            driver = pro.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            <span class="hljs-comment">//4. 注册驱动</span><br>            Class.forName(driver);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-JDBC控制事务"><a href="#4-JDBC控制事务" class="headerlink" title="4. JDBC控制事务"></a>4. JDBC控制事务</h2><ol><li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p></li><li><p>操作：</p><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li><p>使用Connection对象来管理事务</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务</li></ul></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事务操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement pstmt1 = <span class="hljs-keyword">null</span>;<br>        PreparedStatement pstmt2 = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.获取连接</span><br>            conn = JDBCUtils.getConnection();<br>            <span class="hljs-comment">//开启事务</span><br>            conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">//2.定义sql</span><br>            <span class="hljs-comment">//2.1 张三 - 500</span><br>            String sql1 = <span class="hljs-string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//2.2 李四 + 500</span><br>            String sql2 = <span class="hljs-string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//3.获取执行sql对象</span><br>            pstmt1 = conn.prepareStatement(sql1);<br>            pstmt2 = conn.prepareStatement(sql2);<br>            <span class="hljs-comment">//4. 设置参数</span><br>            pstmt1.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt1.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><br>            pstmt2.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt2.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//5.执行sql</span><br>            pstmt1.executeUpdate();<br>            <span class="hljs-comment">// 手动制造异常</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br><br>            pstmt2.executeUpdate();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//事务回滚</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>) &#123;<br>                    conn.rollback();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.close(pstmt1,conn);<br>            JDBCUtils.close(pstmt2,<span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-批处理"><a href="#5-批处理" class="headerlink" title="5. 批处理"></a>5. 批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><blockquote><p> 注意:</p><ol><li>不是所用版本的mysql都支持</li><li><strong>JDBC</strong>连接MySQL时，如果要使用批处理功能，请再ur中加参数?rewriteBatchedStatements=true</li><li><strong>PreparedStatement</strong>作批处理插入时使用values（使用value没有效果）</li></ol></blockquote><h3 id="5-1-JDBC的批量处理语句包括下面方法："><a href="#5-1-JDBC的批量处理语句包括下面方法：" class="headerlink" title="5.1 JDBC的批量处理语句包括下面方法："></a>5.1 JDBC的批量处理语句包括下面方法：</h3><ul><li><p><strong>addBatch</strong>()：添加需要批量处理的SQL语句或参数</p></li><li><p><strong>executeBatch</strong>()：执行批量处理语句；</p></li><li><p><strong>clearBatch</strong>():清空批处理包的语句</p></li></ul><h3 id="5-2-批量执行SQL语句的两种情况"><a href="#5-2-批量执行SQL语句的两种情况" class="headerlink" title="5.2 批量执行SQL语句的两种情况"></a>5.2 批量执行SQL语句的两种情况</h3><ul><li><p>多条SQL语句的批量处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>Statement st = conn.createStatement();<br>st.addBatch(sql1);<br>st.addBatch(sql2);<br>...<br>st.addBatch(sqln);<br>st.executeBatch();<br>st.clearBatch();<br>...<br></code></pre></td></tr></table></figure></li><li><p><strong>一个SQL语句的批量传参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>PreparedStatement pst = conn.prepareStatement(sql);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">1001</span>; i++)&#123;<br>pst.setInt(<span class="hljs-number">1</span>, i);<br>...<br>pst.addBatch();<br>&#125;<br>pst.executeBatch();<br>st.clearBatch();<br>...<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-Blob类型数据的读写（了解）"><a href="#6-Blob类型数据的读写（了解）" class="headerlink" title="6. Blob类型数据的读写（了解）"></a>6. Blob类型数据的读写（了解）</h2><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li><li><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p></li><li><p> 需要注意的是：如果存储的文件过大，数据库的性能会下降</p></li></ul><p>写入：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png"></p><p>读取：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png"></p><h2 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7. 数据库连接池"></a>7. 数据库连接池</h2><ol><li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p><p> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p></li><li><p>好处：</p><ul><li><p>节约资源</p></li><li><p>用户访问高效</p></li></ul></li><li><p>实现：</p></li></ol><ul><li><p>标准接口：DataSource   javax.sql包下的</p><p>方法：</p><ul><li>获取连接：getConnection()</li><li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li></ul></li><li><p>一般我们不去实现它，有数据库厂商来实现</p><ul><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li></ul></li></ul><ol start="4"><li>C3P0：数据库连接池技术</li></ol><ul><li>步骤：</li></ul><ol><li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p><ul><li>不要忘记导入数据库驱动jar包</li></ul></li><li><p>定义配置文件：</p><ul><li>名称： c3p0.properties 或者 c3p0-config.xml</li><li>路径：直接将文件放在src目录下即可。</li></ul></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接： getConnection</p></li></ol><ul><li>代码：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * c3p0的演示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3P0Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-comment">//1.创建数据库连接池对象</span><br>        DataSource ds  = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>        <span class="hljs-comment">//2. 获取连接对象</span><br>        Connection conn = ds.getConnection();<br>        <span class="hljs-comment">//3. 打印</span><br>        System.out.println(conn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>Druid：数据库连接池实现技术，由阿里巴巴提供的<ol><li>步骤：<ol><li>导入jar包 druid-1.0.9.jar</li><li>定义配置文件：<ul><li>是properties形式的</li><li>可以叫任意名称，可以放在任意目录下</li></ul></li><li>加载配置文件。Properties</li><li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol></li></ol><ul><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Druid演示</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidDemo</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>          <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.定义配置文件</span><br>        <span class="hljs-comment">//3.加载配置文件</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>);<br>        pro.load(is);<br>        <span class="hljs-comment">//4.获取连接池对象</span><br>        DataSource ds = DruidDataSourceFactory.createDataSource(pro);<br>        <span class="hljs-comment">//5.获取连接</span><br>        Connection conn = ds.getConnection();<br>        System.out.println(conn);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>定义工具类<ol><li>定义一个类 JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法</li></ol></li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Druid连接池的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br><br>    <span class="hljs-comment">//1.定义成员变量 DataSource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载配置文件</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br>            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>));<br>            <span class="hljs-comment">//2.获取DataSource</span><br>            ds = DruidDataSourceFactory.createDataSource(pro);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>       close(<span class="hljs-keyword">null</span>,stmt,conn);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<span class="hljs-comment">//归还连接</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接池方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）"><a href="#8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）" class="headerlink" title="8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）"></a>8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）</h2><ul><li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>步骤：</p><ol><li><p>导入jar包</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li>JdbcTemplate template = new JdbcTemplate(ds);</li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li><p>update():执行DML语句。增、删、改语句</p></li><li><p>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p><p>注意：这个方法查询的结果集长度只能是1</p></li><li><p>queryForList():查询结果将结果集封装为list集合</p><p>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p></li><li><p>query():查询结果，将结果封装为JavaBean对象</p></li><li><p>query的参数：RowMapper</p></li></ul></li><li><p>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p></li><li><p>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p><ul><li><p>queryForObject：查询结果，将结果封装为对象</p><p>一般用于聚合函数的查询</p></li></ul></li></ol></li></ul><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jdbctemplate;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JdbcTemplate入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.创建JDBCTemplate对象</span><br>        JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());<br>        <span class="hljs-comment">//3.调用方法</span><br>        String sql = <span class="hljs-string">&quot;update account set balance = 5000 where id = ?&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">3</span>);<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jdbctemplate;<br><br><span class="hljs-keyword">import</span> cn.itcast.domain.Emp;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><br><span class="hljs-keyword">import</span> java.sql.Date;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo2</span> </span>&#123;<br><br>    <span class="hljs-comment">//Junit单元测试，可以让方法独立执行</span><br>    <span class="hljs-comment">//1. 获取JDBCTemplate对象</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//2. 定义sql</span><br>        String sql = <span class="hljs-string">&quot;update emp set salary = 10000 where id = 1001&quot;</span>;<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-keyword">int</span> count = template.update(sql);<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 添加一条记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>, <span class="hljs-string">&quot;郭靖&quot;</span>, <span class="hljs-number">10</span>);<br>        System.out.println(count);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3.删除刚才添加的记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;delete from emp where id = ?&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>);<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="hljs-comment">     * 注意：这个方法查询的结果集长度只能是1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp where id = ? or id = ?&quot;</span>;<br>        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 5. 查询所有记录，将其封装为List</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);<br><br>        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;<br>            System.out.println(stringObjectMap);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Emp&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Emp <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                Emp emp = <span class="hljs-keyword">new</span> Emp();<br>                <span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                String ename = rs.getString(<span class="hljs-string">&quot;ename&quot;</span>);<br>                <span class="hljs-keyword">int</span> job_id = rs.getInt(<span class="hljs-string">&quot;job_id&quot;</span>);<br>                <span class="hljs-keyword">int</span> mgr = rs.getInt(<span class="hljs-string">&quot;mgr&quot;</span>);<br>                Date joindate = rs.getDate(<span class="hljs-string">&quot;joindate&quot;</span>);<br>                <span class="hljs-keyword">double</span> salary = rs.getDouble(<span class="hljs-string">&quot;salary&quot;</span>);<br>                <span class="hljs-keyword">double</span> bonus = rs.getDouble(<span class="hljs-string">&quot;bonus&quot;</span>);<br>                <span class="hljs-keyword">int</span> dept_id = rs.getInt(<span class="hljs-string">&quot;dept_id&quot;</span>);<br><br>                emp.setId(id);<br>                emp.setEname(ename);<br>                emp.setJob_id(job_id);<br>                emp.setMgr(mgr);<br>                emp.setJoindate(joindate);<br>                emp.setSalary(salary);<br>                emp.setBonus(bonus);<br>                emp.setDept_id(dept_id);<br><br>                <span class="hljs-keyword">return</span> emp;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6_2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));<br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 7. 查询总记录数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select count(id) from emp&quot;</span>;<br>        Long total = template.queryForObject(sql, Long.class);<br>        System.out.println(total);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>表与JavaBean的关系</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png"></p></li></ul><h2 id="9-DAO层"><a href="#9-DAO层" class="headerlink" title="9.  DAO层"></a>9.  DAO层</h2><ul><li><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</p></li><li><p>作用：为了实现功能的模块化，更有利于代码的维护和升级</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Java</category>
      
      <category>MySQL</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>JDBC</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO框架 个人博客域名更换</title>
    <link href="/2021/03/11/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/"/>
    <url>/2021/03/11/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO框架-个人博客域名更换"><a href="#HEXO框架-个人博客域名更换" class="headerlink" title="HEXO框架 个人博客域名更换"></a>HEXO框架 个人博客域名更换</h1><p>基于<a href="http://lihengxu.cn/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">HEXO框架 个人博客搭建</a>，完成博客项目部署后，我们可以绑定自己的域名</p><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h2><p>在<a href="https://wanwang.aliyun.com/">阿里云的万网</a>购买了自己域名：lihengxu.cn</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_1_%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7.png"></p><p>购买后可以在<a href="https://dc.console.aliyun.com/">域名控制台</a>看到自己的域名信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_2_%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E6%8E%A7%E5%88%B6%E5%8F%B0.png"></p><h2 id="2-解析域名"><a href="#2-解析域名" class="headerlink" title="2. 解析域名"></a>2. 解析域名</h2><ul><li><p>解析之前先ping 一下博客仓库对应的GitHub二级域名：</p><p>lihengxu.github.io的IP地址：185.199.110.153</p></li><li><p>然后点击解析</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_3_%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D.png"></p><ul><li>添加两个解析记录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_4_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%951.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_5_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%952.png"></p><ul><li>完成添加后的效果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_6_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%953.png"></p><h2 id="3-设置CNAME"><a href="#3-设置CNAME" class="headerlink" title="3. 设置CNAME"></a>3. 设置CNAME</h2><p>在项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_7_CNAME%E6%96%87%E4%BB%B6.png"></p><p>然后填写上域名。比如：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_8_CNAME%E6%96%87%E4%BB%B6.png"></p><h2 id="4-更新并重新部署"><a href="#4-更新并重新部署" class="headerlink" title="4. 更新并重新部署"></a>4. 更新并重新部署</h2><p>一下指令的具体解释见这篇博客：<a href="http://lihengxu.cn/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">HEXO框架 个人博客搭建</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览<br>hexo d # 部署到github<br></code></pre></td></tr></table></figure><blockquote><p>参考资料：<br>[1]  <a href="https://my.oschina.net/leonadmin/blog/4315110">https://my.oschina.net/leonadmin/blog/4315110</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p><strong>基于<a href="https://www.bilibili.com/video/BV12b411K7Zu">尚硅谷MySQL视频</a>的学习笔记</strong></p><h2 id="1-初识MySQL"><a href="#1-初识MySQL" class="headerlink" title="1. 初识MySQL"></a>1. 初识MySQL</h2><h3 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h3><ul><li>数据库的常见概念 ★<br>1、DB：数据库，存储数据的容器<br>2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br>3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</li><li>数据库存储数据的特点<br>1、数据存放到表中，然后表再放到库中<br>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br>3、表中有一个或多个列，<strong>列</strong>又称为“<strong>字段</strong>”，相当于java中“<strong>属性</strong>”<br>4、表中的<strong>每一行数据</strong>，相当于java中“<strong>对象</strong>”</li></ul><ul><li>常见的数据库管理系统<br>mysql、oracle、db2、sqlserver</li></ul><h3 id="1-2-MySQL介绍"><a href="#1-2-MySQL介绍" class="headerlink" title="1.2 MySQL介绍"></a>1.2 MySQL介绍</h3><ul><li><p>MySQL的背景<br>前身属于瑞典的一家公司，MySQL AB<br>08年被sun公司收购<br>09年sun被oracle收购</p></li><li><p>MySQL的优点</p><ul><li>开源、免费、成本低</li><li>性能高、移植性也好</li><li>体积小，便于安装</li></ul></li><li><p>MySQL服务的启动和停止</p><ul><li>方式一：通过命令行<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> 服务名<br><span class="hljs-built_in">net</span> stop 服务名<br></code></pre></td></tr></table></figure></li><li>方式二：计算机——右击——管理——服务</li></ul></li></ul><ul><li><p>MySQL服务的登录和退出</p><ul><li><p>登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码<br></code></pre></td></tr></table></figure></li><li><p>退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit 或 ctrl+C<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>MySQL的常见命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.查看当前所有的数据库<br>show databases;<br># 2.打开指定的库<br>use 库名<br># 3.查看当前库的所有表<br>show tables;<br># 4.查看其它库的所有表<br>show tables from 库名;<br># 5.创建表<br>create table 表名(<br>列名 列类型,<br>列名 列类型，<br>...<br>);<br># 6.查看表结构<br>desc 表名;<br># 7.查看服务器的版本<br># 方式一：登录到mysql服务端<br>select version();<br># 方式二：没有登录到mysql服务端<br>mysql --version<br># 或<br>mysql --V<br></code></pre></td></tr></table></figure></li><li><p>MySQL的语法规范</p><ol><li><p>不区分大小写,但建议关键字大写，表名、列名小写</p></li><li><p>每条命令最好用分号结尾</p></li><li><p>每条命令根据需要，可以进行缩进 或换行</p></li><li><p>注释</p><ul><li><p>单行注释：#注释文字</p></li><li><p>单行注释：– 注释文字</p></li><li><p>多行注释：/* 注释文字  */</p></li></ul></li></ol></li><li><p>SQL的语言分类</p><ul><li>DQL（Data Query Language）：数据查询语言<pre><code>    select </code></pre></li><li>DML(Data Manipulate Language):数据操作语言<pre><code>    insert 、update、delete</code></pre></li><li>DDL（Data Define Languge）：数据定义语言<pre><code>    create、drop、alter</code></pre></li><li>TCL（Transaction Control Language）：事务控制语言<pre><code>    commit、rollback</code></pre></li></ul></li></ul><h2 id="2-DQL语言"><a href="#2-DQL语言" class="headerlink" title="2. DQL语言"></a>2. DQL语言</h2><h3 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、查询单个字段<br>select 字段名 from 表名;<br><br># 2、查询多个字段<br>select 字段名，字段名 from 表名;<br><br># 3、查询所有字段<br>select * from 表名;<br><br># 4、查询常量<br># 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要<br>select 常量值;<br><br># 5、查询函数<br>select 函数名(实参列表);<br><br># 6、查询表达式<br>select 100&#x2F;1234;<br><br># 7、起别名<br># ① as<br># ② 空格<br><br># 8、去重<br>select distinct 字段名 from 表名;<br><br># 9、+<br># 作用：做加法运算<br>select 数值+数值;  # 直接运算<br>select 字符+数值;  # 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算<br>select null+值;  # 结果都为null<br><br># 10、【补充】concat函数<br># 功能：拼接字符<br>select concat(字符1，字符2，字符3,...);<br><br># 11、【补充】ifnull函数<br># 功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值<br>select ifnull(commission_pct,0) from employees;<br><br># 12、【补充】isnull函数<br># 功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0<br></code></pre></td></tr></table></figure><h3 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.条件查询的基本结构<br>select 查询列表 from 表名 where 筛选条件<br><br># 2.简单条件运算符<br>&gt; &lt; &#x3D; &lt;&gt; !&#x3D; &gt;&#x3D; &lt;&#x3D;  <br>&lt;&#x3D;&gt;安全等于 # 可以判断null值<br><br># 3. 逻辑运算符<br>&amp;&amp; and<br>|| or<br>!  not<br><br># 4、模糊查询<br>between and # 左右边界不能颠倒顺序<br>between 120 and 100 # 等价于 &gt;&#x3D; 120 &amp;&amp; &lt;&#x3D; 100 <br><br>in (&#39;&#39;, &#39;&#39;) # in列表值类型必须统一,且不支持通配符<br>is null &#x2F;is not null  # 用于判断null值, &#x3D; 不能判断null<br>like  # 一般搭配通配符使用，可以判断字符型或数值型 <br><br># 5.通配符：<br>%：任意多个字符<br>_：任意单个字符<br>通配符转义 \ 或者 &#39;_$_&#39; ESCAPE &#39;$&#39;<br><br><br>普通类型的数值  null值   可读性<br>is null×   √      √<br>&lt;&#x3D;&gt;    √   √      ×<br></code></pre></td></tr></table></figure><p><font color=#FF0000><strong>经典面试题</strong></font> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from employees;<br>select * from employees where name like &#39;%%&#39; and id like &#39;%%&#39;;<br>两个查询语句的执行结果是否相同？<br>解：不一样，若name或者id有null值则查不出来<br></code></pre></td></tr></table></figure><h3 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 排序查询的基本结构<br>select 查询列表<br>from 表<br>where 筛选条件<br>order by 排序列表 [asc&#125;desc]<br><br># 2. 特点<br>&#x2F;*<br>1、asc ：升序，如果不写默认升序<br>   desc：降序<br>2、排序列表 支持 单个字段、多个字段、函数、表达式、别名<br>3、order by的位置一般放在查询语句的最后（除limit语句之外）<br>*&#x2F;<br></code></pre></td></tr></table></figure><h3 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h3><ul><li>功能：类似于java中的方法</li><li>好处：提高重用性和隐藏实现细节</li><li>调用：select 函数名(实参列表);</li></ul><p>单行函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、字符函数<br># concat:连接<br># substr:截取子串，索引从1开始<br># upper:变大写<br># lower：变小写<br># replace：替换<br># length：获取字节长度<br># trim:去前后空格<br># lpad：左填充<br># rpad：右填充<br># instr:获取子串第一次出现的索引<br><br>SELECT LENGTH(&#39;john&#39;);<br>SELECT CONCAT(last_name,&#39;_&#39;,first_name) 姓名 FROM employees;<br>SELECT UPPER(&#39;john&#39;);<br>SELECT LOWER(&#39;joHn&#39;);<br>SELECT <br>CONCAT(UPPER(last_name),LOWER(first_name))  姓名 <br>FROM employees;<br>SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,7)  out_put;<br>SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;<br>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2)))  out_put<br>FROM employees;<br>SELECT INSTR(&#39;杨不殷六侠悔爱上了殷六侠&#39;,&#39;殷八侠&#39;) AS out_put;<br>SELECT LENGTH(TRIM(&#39;    张翠山    &#39;)) AS out_put;<br>SELECT TRIM(&#39;aa&#39; FROM &#39;aaaaaa张aaaa翠山aaaaa&#39;) AS out_put;<br>SELECT LPAD(&#39;殷素素&#39;,2,&#39;*&#39;) AS out_put;<br>SELECT RPAD(&#39;殷素素&#39;,12,&#39;ab&#39;) AS out_put;<br>SELECT REPLACE(&#39;周芷若周芷若张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;<br><br># 2、数学函数<br># ceil:向上取整<br># round：四舍五入<br># mod:取模<br># floor：向下取整<br># truncate:截断<br># rand:获取随机数，返回0-1之间的小数<br>SELECT ROUND(-1.55);<br>SELECT ROUND(1.567,2);<br>SELECT CEIL(-1.02);<br>SELECT FLOOR(-9.99);<br>SELECT TRUNCATE(1.69999,1);<br>#mod取余<br>&#x2F;*<br>mod(a,b) ：  a-a&#x2F;b*b<br>mod(-10,-3):-10- (-10)&#x2F;(-3)*（-3）&#x3D;-1<br>*&#x2F;<br>SELECT MOD(10,-3);<br>SELECT 10%3;<br><br># 3、日期函数<br># now：返回当前日期+时间<br># year:返回年<br># month：返回月<br># day:返回日<br># date_format:将日期转换成字符<br># curdate:返回当前日期<br># str_to_date:将字符转换成日期<br># curtime：返回当前时间<br># hour:小时<br># minute:分钟<br># second：秒<br># datediff:返回两个日期相差的天数<br># monthname:以英文形式返回月<br>SELECT NOW();<br>SELECT CURDATE();<br>SELECT CURTIME();<br>SELECT YEAR(NOW()) 年;<br>SELECT YEAR(&#39;1998-1-1&#39;) 年;<br>SELECT  YEAR(hiredate) 年 FROM employees;<br>SELECT MONTH(NOW()) 月;<br>SELECT MONTHNAME(NOW()) 月;<br>SELECT STR_TO_DATE(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) AS out_put;<br>#查询入职日期为1992--4-3的员工信息<br>SELECT * FROM employees WHERE hiredate &#x3D; &#39;1992-4-3&#39;;<br>SELECT * FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);<br>SELECT DATE_FORMAT(NOW(),&#39;%y年%m月%d日&#39;) AS out_put;<br>#查询有奖金的员工名和入职日期(xx月&#x2F;xx日 xx年)<br>SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月&#x2F;%d日 %y年&#39;) 入职日期<br>FROM employees<br>WHERE commission_pct IS NOT NULL;<br><br># 4、其他函数<br># version 当前数据库服务器的版本<br># database 当前打开的数据库<br># user当前用户<br># password(&#39;字符&#39;)：返回该字符的密码形式<br># md5(&#39;字符&#39;):返回该字符的md5加密形式<br>SELECT VERSION();<br>SELECT DATABASE();<br>SELECT USER();<br><br>#5、流程控制函数<br>&#x2F;*<br>①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2<br>②case情况1<br>case 变量或表达式或字段<br>when 常量1 then 值1<br>when 常量2 then 值2<br>...<br>else 值n<br>end<br><br>③case情况2<br>case <br>when 条件1 then 值1<br>when 条件2 then 值2<br>...<br>else 值n<br>end<br>*&#x2F;<br>SELECT IF(10&lt;5,&#39;大&#39;,&#39;小&#39;);<br><br>SELECT salary 原始工资,department_id,<br>CASE department_id<br>WHEN 30 THEN salary*1.1<br>WHEN 40 THEN salary*1.2<br>WHEN 50 THEN salary*1.3<br>ELSE salary<br>END AS 新工资<br>FROM employees;<br><br>SELECT salary,<br>CASE <br>WHEN salary&gt;20000 THEN &#39;A&#39;<br>WHEN salary&gt;15000 THEN &#39;B&#39;<br>WHEN salary&gt;10000 THEN &#39;C&#39;<br>ELSE &#39;D&#39;<br>END AS 工资级别<br>FROM employees;<br></code></pre></td></tr></table></figure><p>分组函数(统计函数\聚合函数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.分类<br>max 最大值<br>min 最小值<br>sum 和<br>avg 平均值<br>count 计算个数<br><br># 2.简单 的使用<br>SELECT SUM(salary) FROM employees;<br>SELECT AVG(salary) FROM employees;<br>SELECT MIN(salary) FROM employees;<br>SELECT MAX(salary) FROM employees;<br>SELECT COUNT(salary) FROM employees;<br><br><br>SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;<br><br>SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;<br><br># 3、参数支持哪些类型<br># sum和avg一般用于处理数值型<br># max、min、count可以处理任何数据类型<br>SELECT SUM(last_name) ,AVG(last_name) FROM employees;<br>SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;<br>SELECT MAX(last_name),MIN(last_name) FROM employees;<br>SELECT MAX(hiredate),MIN(hiredate) FROM employees;<br>SELECT COUNT(commission_pct) FROM employees;<br>SELECT COUNT(last_name) FROM employees;<br><br># 4、是否忽略null(以上分组函数都忽略)<br>SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)&#x2F;35,SUM(commission_pct)&#x2F;107 FROM employees;<br><br>SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;<br><br>SELECT COUNT(commission_pct) FROM employees;<br>SELECT commission_pct FROM employees;<br><br># 5、和distinct搭配<br>SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;<br>SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;<br><br># 6、count函数的详细介绍<br>count(字段)：统计该字段非空值的个数<br>count(*):统计结果集的行数<br>SELECT COUNT(salary) FROM employees;<br>SELECT COUNT(*) FROM employees;<br>SELECT COUNT(1) FROM employees;<br><br>效率：<br>MYISAM存储引擎下，COUNT(*)的效率高<br>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些<br><br>#6、和分组函数一同查询的字段有限制,要求是group by后出现的字段<br>SELECT AVG(salary),employee_id  FROM employees; # 这个查询没有意义<br></code></pre></td></tr></table></figure><h3 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.分组查询的基本结构<br>select 分组函数，分组后的字段<br>from 表<br>[where 筛选条件]<br>group by 分组的字段<br>[having 分组后的筛选]<br>[order by 排序列表]<br><br># 2.筛选对比<br>使用关键字筛选的表位置<br>分组前筛选where原始表 group by的前面<br>分组后筛选having分组后的结果   group by 的后面<br><br># 3. 常见问题<br>1：分组函数做筛选能不能放在where后面<br>答：不能<br><br>2：where——group by——having<br>答：一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率<br><br>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用<br><br># 4. 一些示例<br>#案例1：查询每个工种的员工平均工资<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;<br>#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资<br>SELECT job_id,MAX(salary)<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING MAX(salary)&gt;12000;<br>#案例3：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序<br>SELECT job_id,MAX(salary) m<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING m&gt;6000<br>ORDER BY m ;<br>#案例4：查询每个工种每个部门的最低工资,并按最低工资降序<br>SELECT MIN(salary),job_id,department_id<br>FROM employees<br>GROUP BY department_id,job_id<br>ORDER BY MIN(salary) DESC;<br></code></pre></td></tr></table></figure><h3 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.连接查询的含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询<br>    笛卡尔乘积现象：表1 有m行，表2有n行，结果&#x3D;m*n行<br>    发生原因：没有有效的连接条件<br>    如何避免：添加有效的连接条件<br><br># 2.分类：<br># 按年代分类：<br>sql92标准:仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br><br># 按功能分类：<br>内连接：<br>等值连接<br>非等值连接<br>自连接<br>外连接：<br>左外连接<br>右外连接<br>全外连接<br><br>交叉连接<br><br># 3. SQL92语法<br># 等值连接<br>select 查询列表<br>from 表1 别名,表2 别名<br>where 表1.key&#x3D;表2.key<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br>① 一般为表起别名<br>② 多表的顺序可以调换<br>③ n表连接至少需要n-1个连接条件<br>④ 等值连接的结果是多表的交集部分<br><br><br># 非等值连接<br>select 查询列表<br>from 表1 别名,表2 别名<br>where 非等值的连接条件<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br># 自连接<br>select 查询列表<br>from 表 别名1,表 别名2<br>where 等值的连接条件<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br><br># 4.SQL99语法<br>    # 内连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    【inner】 join 表2 别名 on 连接条件<br>    where 筛选条件<br>    group by 分组列表<br>    having 分组后的筛选<br>    order by 排序列表<br>    limit 子句;<br>    - 特点：<br>    ① 表的顺序可以调换<br>    ② 内连接的结果&#x3D;多表的交集<br>    ③ n表连接至少需要n-1个连接条件<br>    - 分类：<br>    等值连接<br>    非等值连接<br>    自连接<br><br>    # 外连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    left|right|full【outer】 join 表2 别名 on 连接条件<br>    where 筛选条件<br>    group by 分组列表<br>    having 分组后的筛选<br>    order by 排序列表<br>    limit 子句;<br>    - 特点：<br>    ① 查询的结果&#x3D;主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null<br>    ② left join 左边的就是主表<br>      right join 右边的就是主表<br>      full join 两边都是主表<br>    ③ 一般用于查询除了交集部分的剩余的不匹配的行<br><br>    # 交叉连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    cross join 表2 别名;<br>    - 特点：<br>    类似于笛卡尔乘积<br></code></pre></td></tr></table></figure><h3 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 子查询的含义<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询<br><br># 2. 分类：<br>    # 按子查询出现的位置：<br>        select后面：<br>            仅仅支持标量子查询<br><br>        from后面：<br>            支持表子查询<br>        where或having后面：★<br>            标量子查询（单行） √<br>            列子查询  （多行） √<br>            行子查询<br><br>        exists后面（相关子查询）<br>            表子查询<br><br>    # 按结果集的行列数不同：<br>        标量子查询（结果集只有一行一列）<br>        列子查询（结果集只有一列多行）<br>        行子查询（结果集有一行多列）<br>        表子查询（结果集一般为多行多列）<br><br># 3. 示例<br># 3.1 where或having后面<br>特点：<br>① 子查询放在小括号内<br>② 子查询一般放在条件的右侧<br>③ 标量子查询，一般搭配着单行操作符使用<br>&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;<br>列子查询，一般搭配着多行操作符使用<br>in、any&#x2F;some、all<br><br>④ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果<br><br>    # 标量子查询<br>    案例：查询最低工资的员工姓名和工资<br>    ① 最低工资<br>    select min(salary) from employees<br>    ② 查询员工的姓名和工资，要求工资&#x3D;①<br>    select last_name,salary<br>    from employees<br>    where salary&#x3D;(<br>        select min(salary) from employees<br>    );<br><br>    # 列子查询 ★<br>    案例：查询所有是领导的员工姓名<br>    ① 查询所有员工的 manager_id<br>    select manager_id<br>    from employees<br>    ② 查询姓名，employee_id属于①列表的一个<br>    select last_name<br>    from employees<br>    where employee_id in(<br>        select manager_id<br>        from employees<br>    );<br>    <br>    # 行子查询（了解）<br>案例：查询员工编号最小并且工资最高的员工信息<br>    SELECT * <br>    FROM employees<br>    WHERE (employee_id,salary)&#x3D;(<br>        SELECT MIN(employee_id),MAX(salary)<br>        FROM employees<br>    );<br>    ① 查询最小的员工编号<br>    SELECT MIN(employee_id)<br>    FROM employees<br>② 查询最高工资<br>    SELECT MAX(salary)<br>    FROM employees<br>    ③ 查询员工信息<br>    SELECT *<br>    FROM employees<br>    WHERE employee_id&#x3D;(<br>        SELECT MIN(employee_id)<br>        FROM employees<br>    )AND salary&#x3D;(<br>        SELECT MAX(salary)<br>        FROM employees<br>    );<br>    <br># 3.2 select后面<br>仅仅支持标量子查询<br>    #案例：查询每个部门的员工个数<br>    SELECT d.*,(<br>        SELECT COUNT(*)<br>        FROM employees e<br>        WHERE e.department_id &#x3D; d.&#96;department_id&#96;<br>     ) 个数<br>     FROM departments d;<br><br><br># 3.3 from后面<br>将子查询结果充当一张表，要求必须起别名<br>    #案例：查询每个部门的平均工资的工资等级<br>    ① 查询每个部门的平均工资<br>    SELECT AVG(salary),department_id<br>    FROM employees<br>    GROUP BY department_id<br>    SELECT * FROM job_grades;<br><br>    ② 连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal<br>    SELECT  ag_dep.*,g.&#96;grade_level&#96;<br>    FROM (<br>        SELECT AVG(salary) ag,department_id<br>        FROM employees<br>        GROUP BY department_id<br>    ) ag_dep<br>    INNER JOIN job_grades g<br>    ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;<br><br><br># 3.4 exists后面（相关子查询）<br>语法：<br>exists(完整的查询语句)<br>结果：<br>1或0<br><br>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary&#x3D;300000);<br><br>    #案例：查询有员工的部门名<br>    #in<br>    SELECT department_name<br>    FROM departments d<br>    WHERE d.&#96;department_id&#96; IN(<br>        SELECT department_id<br>        FROM employees<br>    )<br>    #exists<br>    SELECT department_name<br>    FROM departments d<br>    WHERE EXISTS(<br>        SELECT *<br>        FROM employees e<br>        WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;<br>    );<br></code></pre></td></tr></table></figure><h3 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 分页查询<br>select 查询列表<br>from 表<br>[join type join 表2<br>on 连接条件<br>where 筛选条件<br>group by 分组字段<br>having 分组后的筛选<br>order by 排序的字段]<br>limit [offset，] size;<br><br># 2. 注意<br>offset代表的是起始的条目索引，默认从0开始<br>size代表的是显示的条目数<br><br># 3. 公式<br>假如要显示的页数为page，每一页条目数为size<br>select 查询列表<br>from 表<br>limit (page-1)*size,size;<br></code></pre></td></tr></table></figure><h3 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 联合查询: 将多条查询语句的结果合并成一个结果<br>查询语句1<br>union<br>查询语句2<br>union<br>...<br><br># 2. 应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时<br><br># 3. 特点：★<br>3.1 要求多条查询语句的查询列数是一致的！<br>3.2 要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.3 union关键字默认去重，如果使用union all 可以包含重复项<br><br># 4.案例：查询部门编号&gt;90或邮箱包含a的员工信息<br>SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;;<br>SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;<br></code></pre></td></tr></table></figure><h3 id="2-10-查询语句总结"><a href="#2-10-查询语句总结" class="headerlink" title="2.10 查询语句总结"></a>2.10 查询语句总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法以及执行顺序<br>select 查询列表    ⑦<br>from 表1 别名       ①<br>连接类型 join 表2   ②<br>on 连接条件         ③<br>where 筛选          ④<br>group by 分组列表   ⑤<br>having 筛选         ⑥<br>order by排序列表    ⑧<br>limit 起始条目索引，条目数;  ⑨<br></code></pre></td></tr></table></figure><h2 id="3-DML语言"><a href="#3-DML语言" class="headerlink" title="3. DML语言"></a>3. DML语言</h2><blockquote><p>数据操作语言：</p><p>插入：insert</p><p>修改：update</p><p>删除：delete</p></blockquote><h3 id="3-1-插入语句"><a href="#3-1-插入语句" class="headerlink" title="3.1 插入语句"></a>3.1 插入语句</h3><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法<br>insert into 表名(列名) values(值1,...);<br><br># 1.插入的值的类型要与列的类型一致或兼容<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br><br># 2.不可以为null的列必须插入值。可以为null的列如何插入值？<br># 2.1：<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br># 2.2：<br>INSERT INTO beauty(id,NAME,sex,phone)<br>VALUES(15,&#39;娜扎&#39;,&#39;女&#39;,&#39;1388888888&#39;);<br><br># 3.列的顺序是否可以调换<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);<br><br># 4.列数和值的个数必须一致<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);<br><br># 5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致<br>INSERT INTO beauty<br>VALUES(18,&#39;张飞&#39;,&#39;男&#39;,NULL,&#39;119&#39;,NULL,NULL);<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br>insert into 表名<br>set 列名&#x3D;值,列名&#x3D;值,...<br><br># 示例<br>INSERT INTO beauty<br>SET id&#x3D;19, NAME&#x3D;&#39;刘涛&#39;, phone&#x3D;&#39;999&#39;;<br></code></pre></td></tr></table></figure><p>对比两种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、方式一支持插入多行,方式二不支持<br>INSERT INTO beauty<br>VALUES(23,&#39;唐艺昕1&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)<br>,(24,&#39;唐艺昕2&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)<br>,(25,&#39;唐艺昕3&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br><br># 2、方式一支持子查询，方式二不支持<br>INSERT INTO beauty(id,NAME,phone)<br>SELECT 26,&#39;宋茜&#39;,&#39;11809866&#39;;<br><br>INSERT INTO beauty(id,NAME,phone)<br>SELECT id,boyname,&#39;1234567&#39;<br>FROM boys WHERE id&lt;3;<br></code></pre></td></tr></table></figure><h3 id="3-2-修改语句"><a href="#3-2-修改语句" class="headerlink" title="3.2 修改语句"></a>3.2 修改语句</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.修改单表的记录★<br>update 表名<br>set 列&#x3D;新值,列&#x3D;新值,...<br>where 筛选条件;<br><br># 2.修改多表的记录【补充】<br># sql92语法：<br>update 表1 别名,表2 别名<br>set 列&#x3D;值,...<br>where 连接条件<br>and 筛选条件;<br># sql99语法：<br>update 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br>set 列&#x3D;值,...<br>where 筛选条件;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.修改单表的记录<br>#案例1：修改beauty表中姓唐的女神的电话为13899888899<br>UPDATE beauty SET phone &#x3D; &#39;13899888899&#39;<br>WHERE NAME LIKE &#39;唐%&#39;;<br>#案例2：修改boys表中id好为2的名称为张飞，魅力值 10<br>UPDATE boys SET boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10<br>WHERE id&#x3D;2;<br><br>#2.修改多表的记录<br>#案例 1：修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;<br>SET b.&#96;phone&#96;&#x3D;&#39;119&#39;,bo.&#96;userCP&#96;&#x3D;1000<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;<br>#案例2：修改没有男朋友的女神的男朋友编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;<br>SET b.&#96;boyfriend_id&#96;&#x3D;2<br>WHERE bo.&#96;id&#96; IS NULL;<br>SELECT * FROM boys;<br></code></pre></td></tr></table></figure><h3 id="3-3-删除语句"><a href="#3-3-删除语句" class="headerlink" title="3.3 删除语句"></a>3.3 删除语句</h3><p> 方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、单表的删除【★】<br>delete from 表名 where 筛选条件<br><br># 2、多表的删除【补充】<br># sql92语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名,表2 别名<br>where 连接条件<br>and 筛选条件;<br># sql99语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.单表的删除<br># 案例：删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;<br><br># 2.多表的删除<br># 案例：删除张无忌的女朋友的信息<br>DELETE b<br>FROM beauty b<br>INNER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;<br># 案例：删除黄晓明的信息以及他女朋友的信息<br>DELETE b,bo<br>FROM beauty b<br>INNER JOIN boys bo ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;黄晓明&#39;;<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br>truncate table 表名;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#案例：将魅力值&gt;100的男神信息删除<br>TRUNCATE TABLE boys ;<br></code></pre></td></tr></table></figure><p><font color=#FF0000><strong>delete 对比 truncate</strong>  [面试题]</font> </p><blockquote><ol><li><p>delete 可以加where 条件，truncate不能加</p></li><li><p>truncate删除，效率高一丢丢</p></li><li><p>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</p></li><li><p>truncate删除没有返回值，delete删除有返回值</p></li><li><p>truncate删除不能回滚，delete删除可以回滚.</p></li></ol></blockquote><h2 id="4-DDL语言"><a href="#4-DDL语言" class="headerlink" title="4. DDL语言"></a>4. DDL语言</h2><p>数据定义语言    –&gt;   库和表的管理</p><blockquote><p>一、库的管理<br>创建、修改、删除</p><p>二、表的管理<br>创建、修改、删除</p></blockquote><p>创建： create<br>修改： alter<br>删除： drop</p><h3 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1、库的创建<br>create database  [if not exists]库名;<br>#案例：创建库Books<br>CREATE DATABASE IF NOT EXISTS books ;<br><br>#2、库的修改<br>RENAME DATABASE books TO 新库名;<br>#更改库的字符集<br>ALTER DATABASE books CHARACTER SET gbk;<br><br>#3、库的删除<br>DROP DATABASE IF EXISTS books;<br></code></pre></td></tr></table></figure><h3 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.表的创建 ★<br># 语法：<br>create table 表名(<br>列名 列的类型【(长度) 约束】,<br>列名 列的类型【(长度) 约束】,<br>列名 列的类型【(长度) 约束】,<br>...<br>列名 列的类型【(长度) 约束】<br>)<br># 案例：创建表Book<br>CREATE TABLE book(<br>id INT,#编号<br>bName VARCHAR(20),#图书名<br>price DOUBLE,#价格<br>authorId  INT,#作者编号<br>publishDate DATETIME#出版日期<br>);<br>DESC book;<br>#案例：创建表author<br>CREATE TABLE IF NOT EXISTS author(<br>id INT,<br>au_name VARCHAR(20),<br>nation VARCHAR(10)<br>)<br>DESC author;<br><br><br># 2.表的修改<br># 语法<br>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;<br># ① 修改列名<br>ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;<br># ② 修改列的类型或约束<br>ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;<br># ③ 添加新列<br>ALTER TABLE author ADD COLUMN annual DOUBLE; <br># ④ 删除列<br>ALTER TABLE book_author DROP COLUMN  annual;<br># ⑤ 修改表名<br>ALTER TABLE author RENAME TO book_author;<br><br><br># 3.表的删除<br>DROP TABLE IF EXISTS book_author;<br>SHOW TABLES;<br># 通用的写法：<br>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;<br>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE  表名();<br><br><br># 4.表的复制<br>INSERT INTO author VALUES<br>(1,&#39;村上春树&#39;,&#39;日本&#39;),<br>(2,&#39;莫言&#39;,&#39;中国&#39;),<br>(3,&#39;冯唐&#39;,&#39;中国&#39;),<br>(4,&#39;金庸&#39;,&#39;中国&#39;);<br><br>SELECT * FROM Author;<br>SELECT * FROM copy2;<br># 1.仅仅复制表的结构<br>CREATE TABLE copy LIKE author;<br># 2.复制表的结构+数据<br>CREATE TABLE copy2 <br>SELECT * FROM author;<br><br># 只复制部分数据<br>CREATE TABLE copy3<br>SELECT id,au_name<br>FROM author <br>WHERE nation&#x3D;&#39;中国&#39;;<br><br># 仅仅复制某些字段<br>CREATE TABLE copy4 <br>SELECT id,au_name<br>FROM author<br>WHERE 0;<br></code></pre></td></tr></table></figure><h3 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h3><blockquote><p>  常见的数据类型</p><ul><li><p>数值型：</p></li><li><p>整型</p></li><li><p>小数：</p><ul><li><p>定点数</p></li><li><p>浮点数</p></li></ul></li><li><p>字符型：</p></li><li><p>较短的文本：char、varchar</p></li><li><p>较长的文本：text、blob（较长的二进制数据）</p></li><li><p>日期型</p></li></ul></blockquote><p><strong>整型</strong></p><ul><li><p>分类：<br>tinyint、smallint、mediumint、int/integer、bigint<br>1              2               3                     4                     8</p></li><li><p>特点：<br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 如何设置无符号和有符号<br>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>t1 INT(7) ZEROFILL,<br>t2 INT(7) ZEROFILL,<br>    t3 INT UNSIGNED<br><br>);<br>DESC tab_int;<br><br><br>INSERT INTO tab_int VALUES(-123456);<br>INSERT INTO tab_int VALUES(-123456,-123456);<br>INSERT INTO tab_int VALUES(2147483648,4294967296);<br>INSERT INTO tab_int VALUES(123,123);<br>SELECT * FROM tab_int;<br></code></pre></td></tr></table></figure><p><strong>小数</strong></p><ul><li><p>分类：</p><ol><li>浮点型<br>float(M,D)<br>double(M,D)</li><li>定点型<br>dec(M，D)<br>decimal(M,D)</li></ol></li><li><p>特点：</p><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p><p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③</p><p>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p></li><li><p>原则：</p><p>所选择的类型越简单越好，能保存数值的类型越小越好</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#测试M和D<br>CREATE TABLE tab_float(<br>f1 FLOAT,<br>f2 DOUBLE,<br>f3 DECIMAL<br>);<br>SELECT * FROM tab_float;<br>DESC tab_float;<br><br>INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);<br>INSERT INTO tab_float VALUES(123.456,123.456,123.456);<br>INSERT INTO tab_float VALUES(123.4,123.4,123.4);<br>INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);<br></code></pre></td></tr></table></figure><p><strong>字符型</strong></p><ul><li><p>较短的文本：</p><p>char  varchar</p></li><li><p>其他：</p><p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p></li><li><p>较长的文本：<br>text<br>blob(较大的二进制)</p></li><li><p>char/varchar 对比</p></li></ul><table><thead><tr><th></th><th>写法</th><th>M的意思</th><th>特点</th><th>空间的耗费</th><th>效率</th></tr></thead><tbody><tr><td>char</td><td>char(M)</td><td>最大的字符数，可以省略，默认为1</td><td>固定长度的字符</td><td>比较耗费</td><td>高</td></tr><tr><td>varchar</td><td>varchar(M)</td><td>最大的字符数，不可以省略</td><td>可变长度的字符</td><td>比较节省</td><td>低</td></tr></tbody></table><ul><li>enum和set不区分大小写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tab_char(<br>c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)<br>);<br>INSERT INTO tab_char VALUES(&#39;a&#39;);<br>INSERT INTO tab_char VALUES(&#39;b&#39;);<br>INSERT INTO tab_char VALUES(&#39;c&#39;);<br>INSERT INTO tab_char VALUES(&#39;m&#39;);<br>INSERT INTO tab_char VALUES(&#39;A&#39;);<br>SELECT * FROM tab_char;<br><br>CREATE TABLE tab_set(<br>s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)<br>);<br>INSERT INTO tab_set VALUES(&#39;a&#39;);<br>INSERT INTO tab_set VALUES(&#39;A,B&#39;);<br>INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);<br></code></pre></td></tr></table></figure></li></ul><p><strong>日期型</strong></p><ul><li>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</li></ul><p>datetime保存日期+时间<br>timestamp保存日期+时间</p><table><thead><tr><th></th><th>写法</th><th>范围</th><th>时区等的影响</th></tr></thead><tbody><tr><td>datetime</td><td>8</td><td>1000-9999</td><td>不受</td></tr><tr><td>timestamp</td><td>4</td><td>1970-2038</td><td>受</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tab_date(<br>t1 DATETIME,<br>t2 TIMESTAMP<br>);<br>INSERT INTO tab_date VALUES(NOW(),NOW());<br>SELECT * FROM tab_date;<br><br># 查看当前时区<br>SHOW VARIABLES LIKE &#39;time_zone&#39;;<br># 更改时区<br>SET time_zone&#x3D;&#39;+9:00&#39;;<br></code></pre></td></tr></table></figure><h3 id="4-4-常见约束"><a href="#4-4-常见约束" class="headerlink" title="4.4 常见约束"></a>4.4 常见约束</h3><ul><li><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p></li><li><p>分类：六大约束</p><ul><li><p>NOT NULL：<strong>非空</strong>，用于保证该字段的值不能为空</p><pre><code>比如姓名、学号等</code></pre></li><li><p>DEFAULT：<strong>默认</strong>，用于保证该字段有默认值</p><pre><code>比如性别</code></pre></li><li><p>PRIMARY KEY：<strong>主键</strong>，用于保证该字段的值具有<strong>唯一性</strong>，并且<strong>非空</strong></p><pre><code>比如学号、员工编号等</code></pre></li><li><p>UNIQUE：<strong>唯一</strong>，用于保证该字段的值具有<strong>唯一性</strong>，可以为空</p><pre><code>比如座位号</code></pre></li><li><p>CHECK：检查约束【mysql中不支持】</p><pre><code>比如年龄、性别</code></pre></li><li><p>FOREIGN KEY：<strong>外键</strong>，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p><p>​    在<strong>从表添加外键约束</strong>，用于<strong>引用主表</strong>中某列的值<br>​    比如学生表的专业编号，员工表的部门编号，员工表的工种编号<br>​    </p></li></ul></li><li><p>添加约束的时机：</p><pre><code>1.创建表时2.修改表时</code></pre></li><li><p>约束的添加分类：</p><ul><li>列级约束：<br>六大约束语法上都支持，但外键约束没有效果        </li><li>表级约束：<br>除了非空、默认，其他的都支持<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型 列级约束,<br>字段名 字段类型,<br>表级约束<br>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>​    </p><ul><li><font color=#FF0000>主键和唯一的对比【面试题】</font> </li></ul><table><thead><tr><th></th><th>保证唯一性</th><th>是否允许为空</th><th>一个表中可以有多少个</th><th>是否允许组合</th></tr></thead><tbody><tr><td>主键</td><td>√</td><td>×</td><td>至多有1个</td><td>√，但不推荐</td></tr><tr><td>唯一</td><td>√</td><td>√</td><td>可以有多个</td><td>√，但不推荐</td></tr></tbody></table><ul><li><p>外键</p><ul><li><p>要求在从表设置外键关系</p></li><li><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p></li><li><p>主表的关联列必须是一个key（一般是主键或唯一）</p></li><li><p>插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 可以通过以下两种方式来删除主表的记录<br># 方式一：级联删除<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;<br># 方式二：级联置空<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>约束的增删改</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建表时添加约束<br># 1.添加列级约束<br>&#x2F;*<br>语法：<br>直接在字段名和类型后面追加 约束类型即可。<br>只支持：默认、非空、主键、唯一<br>*&#x2F;<br>USE students;<br>DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>id INT PRIMARY KEY,#主键<br>stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>gender CHAR(1) CHECK(gender&#x3D;&#39;男&#39; OR gender &#x3D;&#39;女&#39;),#检查<br>seat INT UNIQUE,#唯一<br>age INT DEFAULT  18,#默认约束<br>majorId INT REFERENCES major(id)#外键(这里外键无效)<br><br>);<br><br>CREATE TABLE major(<br>id INT PRIMARY KEY,<br>majorName VARCHAR(20)<br>);<br><br>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;<br><br><br># 2.添加表级约束<br>&#x2F;*<br>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名) <br>*&#x2F;<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT,<br><br>CONSTRAINT pk PRIMARY KEY(id),#主键<br>CONSTRAINT uq UNIQUE(seat),#唯一键<br>CONSTRAINT ck CHECK(gender &#x3D;&#39;男&#39; OR gender  &#x3D; &#39;女&#39;),#检查<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键<br><br>);<br><br>SHOW INDEX FROM stuinfo;<br><br><br># 通用的写法：★<br>CREATE TABLE IF NOT EXISTS stuinfo(<br>id INT PRIMARY KEY,<br>stuname VARCHAR(20),<br>sex CHAR(1),<br>age INT DEFAULT 18,<br>seat INT UNIQUE,<br>majorid INT,<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br><br>);<br><br><br># 二、修改表时添加约束<br>&#x2F;*<br>1. 添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;<br>2. 添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;<br>*&#x2F;<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT<br>)<br>DESC stuinfo;<br><br># 1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;<br># 2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br># 3.添加主键<br># ①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;<br># ②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);<br># 4.添加唯一<br># ①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;<br># ②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);<br># 5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); <br><br><br># 三、修改表时删除约束<br># 1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;<br># 2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;<br># 3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;<br># 4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;<br># 5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br><br>SHOW INDEX FROM stuinfo;<br></code></pre></td></tr></table></figure><ul><li><p>自增长列(标识列）</p><ul><li><p>含义：可以不用手动的插入值，系统提供默认的序列值</p></li><li><p>特点：</p><blockquote><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？<strong>至多一个</strong>！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p></blockquote></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.创建表时设置标识列<br>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>id INT,<br>NAME FLOAT UNIQUE AUTO_INCREMENT,<br>seat INT <br>);<br>TRUNCATE TABLE tab_identity;<br><br>INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#39;john&#39;);<br>INSERT INTO tab_identity(NAME) VALUES(&#39;lucy&#39;);<br>SELECT * FROM tab_identity;<br><br># 查看自增长相关变量<br>SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;<br># 设置自增长步长(一般要进行修改)<br>SET auto_increment_increment&#x3D;3;<br><br># 2.修改表时设置标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;<br><br># 3.修改表时删除标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT;<br></code></pre></td></tr></table></figure><h3 id="4-5-表与表之间的关系"><a href="#4-5-表与表之间的关系" class="headerlink" title="4.5 表与表之间的关系"></a>4.5 表与表之间的关系</h3><ul><li>一对一</li><li>一对多</li><li>多对多</li></ul><h2 id="5-TCL语言"><a href="#5-TCL语言" class="headerlink" title="5. TCL语言"></a>5. TCL语言</h2><p>Transaction Control Language 事务控制语言</p><h3 id="5-1-事务的含义"><a href="#5-1-事务的含义" class="headerlink" title="5.1 事务的含义"></a>5.1 事务的含义</h3><blockquote><p><strong>事务</strong>：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p></blockquote><h3 id="5-2-事务的特点"><a href="#5-2-事务的特点" class="headerlink" title="5.2 事务的特点"></a>5.2 事务的特点</h3><p><font color=#FF0000>事务的特性：ACID  [面试题]</font>  </p><ul><li>原子性：一个事务不可再分割，要么都执行要么都不执行.</li><li>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态.</li><li>隔离性：一个事务的执行不受其他事务的干扰.</li><li>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</li></ul><blockquote><p>存储引擎:</p><ol><li>概念: 在mysql中的数据用各种不同的技术存储在文件(或者内存)中.</li><li>通过<code>show engines;</code>来查看mysql支持的存储引擎.</li><li>在mysql中用的最多的存储引擎有: innodb, myisam, memory等. 其中innodb支持事务,而myisam和memory不支持事务.</li></ol></blockquote><h3 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h3><ul><li><p>事务的创建</p><ul><li><p>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p><p>​    delete from 表 where id =1;</p></li><li><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用<code>set autocommit=0;</code></p></li></ul></li></ul><ul><li><p>显式事务的使用</p><p>① 开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p><p>② 编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p><p>设置回滚点：<br>savepoint 回滚点名;</p><p>③ 结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p></li><li><p>delete和truncate在事务使用时的区别：</p><ul><li>delete支持回滚</li><li>truncate不支持</li></ul></li></ul><h3 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h3><ul><li><p>事务的并发问题是如何发生的？</p><p>​    多个事务 同时 操作 同一个数据库的相同数据时</p></li><li><p><font color=#FF0000>并发问题都有哪些？</font> </p><ul><li><strong>脏读</strong>：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li><li><strong>不可重复读</strong>：一个事务多次读取，结果不一样</li><li><strong>幻读</strong>：一个事务读取了其他事务还没有提交的数据，只是读到的是其他事务“插入”的数据</li><li><strong>更新丢失</strong>：当两个或者多个事务选择同一行，然后基于最初的选定的值更新该行时，由于每一个事务都不知道其他事务的存在，就会发生更新问题。最后的更新覆盖了其他事务所做的更新。</li></ul></li><li><p>如何解决并发问题</p><p>​    通过设置隔离级别来解决并发问题</p></li><li><p><font color=#FF0000>事务的隔离级别</font>  </p></li></ul><table><thead><tr><th></th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted: 读未提交</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>×</td><td>×</td><td>×</td></tr><tr><td>read committed: 读已提交</td><td>语句级</td><td>√</td><td>×</td><td>×</td></tr><tr><td>repeatable read: 可重复读</td><td>事务级</td><td>√</td><td>√</td><td>×</td></tr><tr><td>serializable: 串行化 (每次读都需获得表级共享锁，读写相互都会阻塞,性能低下)</td><td>最高级别，事务级</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql中默认 第三个隔离级别 <br>repeatable read<br># oracle中默认第二个隔离级别 <br>read committed<br># 查看隔离级别<br>select @@tx_isolation;<br>show variables like &#39;tx_isolation&#39;;<br># 设置隔离级别<br>set session|global transaction isolation level 隔离级别;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.演示事务的使用步骤<br># 开启事务<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br># 编写一组事务的语句<br>UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;<br>UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;<br># 结束事务<br>ROLLBACK; # commit;<br>SELECT * FROM account;<br><br>#2.演示事务对于delete和truncate的处理的区别<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;<br><br>#3.演示savepoint 的使用<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id&#x3D;25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id&#x3D;28;<br>ROLLBACK TO a;#回滚到保存点<br>SELECT * FROM account;<br></code></pre></td></tr></table></figure><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><blockquote><p><strong>含义</strong>：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据, <strong>只保存了sql逻辑</strong>, 不保存查询结果</p></blockquote><ul><li><p>应用场景:</p><ul><li>多个地方用到相同的查询结果</li><li>该查询结果使用的sql语句比较复杂</li></ul></li><li><p>好处：</p><ul><li>重用sql语句</li><li>简化复杂的sql操作，不必知道它的查询细节</li><li>保护数据，提高安全性（只提供对方需要的信息）</li></ul></li><li><p>创建视图</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 示例：查询姓张的学生名和专业名<br># 1.原始sql语句<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;<br>WHERE s.&#96;stuname&#96; LIKE &#39;张%&#39;;<br># 2.①创建视图<br>CREATE VIEW v1<br>AS<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;;<br># 2.②使用视图简化原始sql语句<br>SELECT * FROM v1 WHERE stuname LIKE &#39;张%&#39;;<br></code></pre></td></tr></table></figure><ul><li>修改视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式一：<br>&#x2F;*<br>create or replace view  视图名<br>as<br>查询语句;<br>*&#x2F;<br>SELECT * FROM myv3 <br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;<br><br>#方式二：<br>&#x2F;*<br>语法：<br>alter view 视图名<br>as <br>查询语句;<br>*&#x2F;<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;<br></code></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：drop view 视图名,视图名,...;<br>DROP VIEW emp_v1,emp_v2,myv3;<br></code></pre></td></tr></table></figure><ul><li>查看视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC myv3;<br>SHOW CREATE VIEW myv3;<br></code></pre></td></tr></table></figure><ul><li>更新视图</li></ul><p>视图可以增删改，示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;<br>SELECT * FROM myv1;<br>SELECT * FROM employees;<br>#1.插入<br>INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;);<br>#2.修改<br>UPDATE myv1 SET last_name &#x3D; &#39;张无忌&#39; WHERE last_name&#x3D;&#39;张飞&#39;;<br>#3.删除<br>DELETE FROM myv1 WHERE last_name &#x3D; &#39;张无忌&#39;;<br></code></pre></td></tr></table></figure><p>具备以下特点的视图不允许更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># ① 包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT MAX(salary) m,department_id<br>FROM employees<br>GROUP BY department_id;<br>SELECT * FROM myv1;<br>#更新<br>UPDATE myv1 SET m&#x3D;9000 WHERE department_id&#x3D;10;<br><br># ② 常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS<br>SELECT &#39;john&#39; NAME;<br>SELECT * FROM myv2;<br>#更新<br>UPDATE myv2 SET NAME&#x3D;&#39;lucy&#39;;<br><br><br># ③ Select中包含子查询<br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;<br>#更新<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资&#x3D;100000;<br><br><br># ④ join<br>CREATE OR REPLACE VIEW myv4<br>AS<br>SELECT last_name,department_name<br>FROM employees e<br>JOIN departments d<br>ON e.department_id  &#x3D; d.department_id;<br>#更新<br>SELECT * FROM myv4;<br>UPDATE myv4 SET last_name  &#x3D; &#39;张飞&#39; WHERE last_name&#x3D;&#39;Whalen&#39;;<br>INSERT INTO myv4 VALUES(&#39;陈真&#39;,&#39;xxxx&#39;);<br><br># ⑤ from一个不能更新的视图<br>CREATE OR REPLACE VIEW myv5<br>AS<br>SELECT * FROM myv3;<br>#更新<br>SELECT * FROM myv5;<br>UPDATE myv5 SET 最高工资&#x3D;10000 WHERE department_id&#x3D;60;<br><br># ⑥ where子句的子查询引用了from子句中的表<br>CREATE OR REPLACE VIEW myv6<br>AS<br>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>SELECT  manager_id<br>FROM employees<br>WHERE manager_id IS NOT NULL<br>);<br>#更新<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary&#x3D;10000 WHERE last_name &#x3D; &#39;k_ing&#39;;<br></code></pre></td></tr></table></figure><ul><li>表和视图的对比<table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>create view</td><td>只是保存了sql逻辑</td><td>增删改查，只是一般不能增删改</td></tr><tr><td>表</td><td>create table</td><td>保存了数据</td><td>增删改查</td></tr></tbody></table></li></ul><h3 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h3><ul><li>系统变量：<ul><li>全局变量：</li></ul>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效<ul><li><p>会话变量：</p><p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p></li></ul></li><li>自定义变量：<ul><li>用户变量</li><li>局部变量</li></ul></li></ul><blockquote><ol><li>系统变量</li></ol></blockquote><p><strong>说明</strong>：变量由系统定义，不是用户定义，属于服务器层面<br><strong>注意</strong>：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br><strong>使用步骤</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、查看所有系统变量<br>show global|【session】variables;<br># 2、查看满足条件的部分系统变量<br>show global|【session】 variables like &#39;%char%&#39;;<br># 3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br># 4、为某个系统变量赋值<br># 方式一：<br>set global|【session】系统变量名&#x3D;值;<br># 方式二：<br>set @@global|【session】系统变量名&#x3D;值;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1》全局变量<br>&#x2F;*<br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>*&#x2F;<br># ① 查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br># ② 查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;<br># ③ 查看指定的系统变量的值<br>SELECT @@global.autocommit;<br># ④ 为某个系统变量赋值<br>SET @@global.autocommit&#x3D;0;<br>SET GLOBAL autocommit&#x3D;0;<br><br>#2》会话变量<br>&#x2F;*<br>作用域：针对于当前会话（连接）有效<br>*&#x2F;<br># ① 查看所有会话变量<br>SHOW SESSION VARIABLES;<br># ② 查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;<br># ③ 查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;<br># ④ 为某个会话变量赋值<br>SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;<br>SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>自定义变量</li></ol></blockquote><p><strong>说明</strong>：变量由用户自定义，而不是系统提供的<br><strong>使用步骤</strong>：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1》用户变量<br>&#x2F;*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*&#x2F;<br># 赋值操作符：&#x3D;或:&#x3D;<br># ① 声明并初始化<br>SET @变量名&#x3D;值;<br>SET @变量名:&#x3D;值;<br>SELECT @变量名:&#x3D;值;<br># ② 赋值（更新变量的值）<br>#方式一：<br>SET @变量名&#x3D;值;<br>SET @变量名:&#x3D;值;<br>SELECT @变量名:&#x3D;值;<br>#方式二：<br>SELECT 字段 INTO @变量名<br>FROM 表;<br># ③ 使用（查看变量的值）<br>SELECT @变量名;<br><br><br># 2》局部变量<br>&#x2F;*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*&#x2F;<br># ① 声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】<br># ② 赋值（更新变量的值）<br>#方式一：<br>SET 局部变量名&#x3D;值;<br>SET 局部变量名:&#x3D;值;<br>SELECT 局部变量名:&#x3D;值;<br>#方式二：<br>SELECT 字段 INTO 具备变量名<br>FROM 表;<br># ③ 使用（查看变量的值）<br>SELECT 局部变量名;<br><br><br># 案例：声明两个变量，求和并打印<br># 用户变量<br>SET @m&#x3D;1;<br>SET @n&#x3D;1;<br>SET @sum&#x3D;@m+@n;<br>SELECT @sum;<br># 局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM&#x3D;m+n;<br>SELECT SUM;<br></code></pre></td></tr></table></figure><p><strong>用户变量和局部变量的对比</strong>：</p><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><h3 id="6-3-存储过程和函数"><a href="#6-3-存储过程和函数" class="headerlink" title="6.3 存储过程和函数"></a>6.3 存储过程和函数</h3><ul><li>存储过程和函数：类似于java中的方法</li><li>好处：<br>1、提高代码的重用性<br>2、简化操作</li></ul><blockquote><ol><li><strong>存储过程</strong></li></ol></blockquote><p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建语法★<br>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN<br>存储过程体（一组合法的SQL语句）<br>END<br>&#x2F;*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)<br><br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值,in可以省略<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值<br><br>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*&#x2F;<br><br><br># 二、调用语法<br>CALL 存储过程名(实参列表);<br><br>#----------------------案例演示-------------------------<br># 1.空参列表<br>#案例：插入到admin表中五条记录<br>SELECT * FROM admin;<br>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>INSERT INTO admin(username,&#96;password&#96;) <br>VALUES(&#39;john1&#39;,&#39;0000&#39;),(&#39;lily&#39;,&#39;0000&#39;),(&#39;rose&#39;,&#39;0000&#39;),(&#39;jack&#39;,&#39;0000&#39;),(&#39;tom&#39;,&#39;0000&#39;);<br>END $<br>#调用<br>CALL myp1()$<br><br># 2.创建带in模式参数的存储过程<br>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息<br>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>SELECT bo.*<br>FROM boys bo<br>RIGHT JOIN beauty b ON bo.id &#x3D; b.boyfriend_id<br>WHERE b.name&#x3D;beautyName;<br>END $<br>#调用<br>CALL myp2(&#39;柳岩&#39;)$<br>#案例2 ：创建存储过程实现，用户是否登录成功<br>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>DECLARE result INT DEFAULT 0;#声明并初始化<br>SELECT COUNT(*) INTO result#赋值<br>FROM admin<br>WHERE admin.username &#x3D; username<br>AND admin.password &#x3D; PASSWORD;<br><br>SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用<br>END $<br>#调用<br>CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$<br><br># 3.创建out 模式参数的存储过程<br>#案例1：根据输入的女神名，返回对应的男神名<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>SELECT bo.boyname INTO boyname<br>FROM boys bo<br>RIGHT JOIN<br>beauty b ON b.boyfriend_id &#x3D; bo.id<br>WHERE b.name&#x3D;beautyName ;<br>END $<br>#调用<br>CALL myp7(&#39;小昭&#39;, @name)$<br>SELECT @name$<br>#案例2：根据输入的女神名，返回对应的男神名和魅力值<br>CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) <br>BEGIN<br>SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>FROM boys <br>RIGHT JOIN<br>beauty b ON b.boyfriend_id &#x3D; boys.id<br>WHERE b.name&#x3D;beautyName ;<br>END $<br>#调用<br>CALL myp7(&#39;小昭&#39;, @name, @cp)$<br>SELECT @name,@cp$<br><br># 4.创建带inout模式参数的存储过程<br>#案例1：传入a和b两个值，最终a和b都翻倍并返回<br>CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)<br>BEGIN<br>SET a&#x3D;a*2;<br>SET b&#x3D;b*2;<br>END $<br>#调用<br>SET @m&#x3D;10$<br>SET @n&#x3D;20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$<br><br><br># 三、删除存储过程<br>#语法：drop procedure 存储过程名<br>DROP PROCEDURE p1;<br>DROP PROCEDURE p2,p3;#×<br><br><br># 四、查看存储过程的信息<br>DESC myp2; # 不可以<br>SHOW CREATE PROCEDURE  myp2;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li><strong>函数</strong></li></ol></blockquote><p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p><strong>区别</strong>：</p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>函数体<br>END<br>&#x2F;*<br>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型<br>2.函数体：<br>肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记<br>*&#x2F;<br><br><br>#二、调用语法<br>SELECT 函数名(参数列表)<br><br>#-----------------案例演示-------------------<br># 1.无参有返回<br>#案例：返回公司的员工个数<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>DECLARE c INT DEFAULT 0;#定义局部变量<br>SELECT COUNT(*) INTO c#赋值<br>FROM employees;<br>RETURN c;<br>END $<br>SELECT myf1()$<br><br># 2.有参有返回<br># 案例1：根据员工名，返回它的工资<br>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>SET @sal&#x3D;0;#定义用户变量 <br>SELECT salary INTO @sal   #赋值<br>FROM employees<br>WHERE last_name &#x3D; empName;<br>RETURN @sal;<br>END $<br>SELECT myf2(&#39;k_ing&#39;) $<br># 案例2：根据部门名，返回该部门的平均工资<br>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>DECLARE sal DOUBLE ;<br>SELECT AVG(salary) INTO sal<br>FROM employees e<br>JOIN departments d ON e.department_id &#x3D; d.department_id<br>WHERE d.department_name&#x3D;deptName;<br>RETURN sal;<br>END $<br>SELECT myf3(&#39;IT&#39;)$<br><br><br>#三、查看函数<br>SHOW CREATE FUNCTION myf3;<br><br><br>#四、删除函数<br>DROP FUNCTION myf3;<br><br># 案例: 创建函数，实现传入两个float，返回二者之和<br>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>DECLARE SUM FLOAT DEFAULT 0;<br>SET SUM&#x3D;num1+num2;<br>RETURN SUM;<br>END $<br>SELECT test_fun1(1,2)$<br></code></pre></td></tr></table></figure><h3 id="6-4-流程控制结构"><a href="#6-4-流程控制结构" class="headerlink" title="6.4  流程控制结构"></a>6.4  流程控制结构</h3><p>顺序、分支、循环</p><blockquote><ol><li>分支结构</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.if函数<br>&#x2F;*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面<br>*&#x2F;<br><br># 2.case结构<br>&#x2F;*<br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>...<br>else 语句n;<br>end <br>情况2：<br>case <br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>...<br>else 语句n;<br>end <br>- 应用在begin end 中或外面<br>如果放在begin end 外面，作为表达式结合着其他语句使用<br>如果放在begin end 里面，一般作为独立的语句使用<br>- else语句可以省略，如果else省略了，全部when都不满足，则返回null<br><br># 3.if结构<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>....<br>else 语句n;<br>end if;<br>功能：类似于多重if<br>只能应用在begin end 中<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>循环结构</li></ol></blockquote><p><strong>分类</strong>：<br>while、loop、repeat</p><p><strong>循环控制</strong>：</p><p>iterate 【标签】 类似于 continue，继续，结束本次循环，继续下一次<br>leave 【标签】 类似于  break，跳出，结束当前所在的循环</p><p><strong>语法</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E5%9F%BA%E7%A1%80_1_%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png"></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.没有添加循环控制语句<br>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>WHILE i&lt;&#x3D;insertCount DO<br>INSERT INTO admin(username,&#96;password&#96;) VALUES(CONCAT(&#39;Rose&#39;,i),&#39;666&#39;);<br>SET i&#x3D;i+1;<br>END WHILE;<br>END $<br>CALL pro_while1(100)$<br><br>#2.添加leave语句<br>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>a:WHILE i&lt;&#x3D;insertCount DO<br>INSERT INTO admin(username,&#96;password&#96;)<br>VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);<br>IF i&gt;&#x3D;20 THEN LEAVE a;<br>END IF;<br>SET i&#x3D;i+1;<br>END WHILE a;<br>END $<br>CALL test_while1(100)$<br><br>#3.添加iterate语句<br>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>a:WHILE i&lt;&#x3D;insertCount DO<br>SET i&#x3D;i+1;<br>IF MOD(i,2)!&#x3D;0 THEN ITERATE a;<br>END IF;<br><br>INSERT INTO admin(username,&#96;password&#96;)<br>VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);<br>END WHILE a;<br>END $<br>CALL test_while1(100)$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo图床</title>
    <link href="/2021/03/07/PicGo/"/>
    <url>/2021/03/07/PicGo/</url>
    
    <content type="html"><![CDATA[<h1 id="PicGo图床"><a href="#PicGo图床" class="headerlink" title="PicGo图床"></a>PicGo图床</h1><h2 id="1-下载PicGo"><a href="#1-下载PicGo" class="headerlink" title="1. 下载PicGo"></a>1. 下载PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h2 id="2-安装PicGo"><a href="#2-安装PicGo" class="headerlink" title="2. 安装PicGo"></a>2. 安装PicGo</h2><p>直接运行.exe</p><h2 id="3-新建一个github仓库"><a href="#3-新建一个github仓库" class="headerlink" title="3. 新建一个github仓库"></a>3. 新建一个github仓库</h2><p>mycdn</p><h2 id="4-生成token"><a href="#4-生成token" class="headerlink" title="4.生成token"></a>4.生成token</h2><p>[进入github] -&gt; [点击头像] -&gt; [settings] -&gt; [Developers settings] -&gt; [Personal access token]</p><blockquote><p> 必须勾选repo</p></blockquote><p>生成后必须复制token，只显示一次</p><blockquote><p>0cb447c7cb66f97f8dd645d1b30f88b3bda94198</p></blockquote><h2 id="5-配置PicGo"><a href="#5-配置PicGo" class="headerlink" title="5. 配置PicGo"></a>5. 配置PicGo</h2><p>打开PicGo左栏依次选择[图床设置] -&gt; [github图床]</p><p>格式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">仓库名： 你的用户名/仓库名<br>分支： main<br>Token： <span class="hljs-number">0</span>cb447c7cb66f97f8dd645d1b30f88b3bda94198<br>存储路径： img/  <span class="hljs-comment"># 表示上传到你的仓库的img目录下</span><br>自定义域名格式： https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>LihengXu/mycdn<br></code></pre></td></tr></table></figure><p>因为github的服务器在国外，所以用来当图床的时候，国内的速度非常感人，但是我们可以使用<code>jsdelivr</code>提供的CDN服务，速度非常的快，基本不大的图片可以秒开。</p><p>所以上述<strong>自定义域名</strong>实际上是使用的<code>jsdelivr</code>的CDN服务。</p><h2 id="6-上传图片"><a href="#6-上传图片" class="headerlink" title="6. 上传图片"></a>6. 上传图片</h2><p>点击上传区，选择github图床</p><p>示例</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/myfig.png"></p>]]></content>
    
    
    <categories>
      
      <category>PicGo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO框架 个人博客搭建</title>
    <link href="/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO框架-个人博客搭建"><a href="#HEXO框架-个人博客搭建" class="headerlink" title="HEXO框架 个人博客搭建"></a>HEXO框架 个人博客搭建</h1><h2 id="一、-环境搭建"><a href="#一、-环境搭建" class="headerlink" title="一、 环境搭建"></a>一、 环境搭建</h2><h3 id="1-nodejs安装"><a href="#1-nodejs安装" class="headerlink" title="1. nodejs安装"></a>1. nodejs安装</h3><h4 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h4><p>下载地址（选择<strong>LTS</strong>稳定版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><blockquote><p>下载之后直接默认安装，一路next（建议不要放在C盘）</p></blockquote><h4 id="1-2-测试nodejs"><a href="#1-2-测试nodejs" class="headerlink" title="1.2 测试nodejs"></a>1.2 测试nodejs</h4><p>打开windows的命令行工具输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure><p>显示版本号则安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_1_%E6%B5%8B%E8%AF%95nodejs%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h4 id="1-3-测试npm"><a href="#1-3-测试npm" class="headerlink" title="1.3 测试npm"></a>1.3 测试npm</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> npm是nodejs安装时默认安装的</span><br><span class="hljs-meta">#</span><span class="bash"> 直接在windows的命令行工具输入</span><br>npm -v<br></code></pre></td></tr></table></figure><p>显示如下则安装成功, npm管理工具用于安装Hexo框架</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_2_%E6%B5%8B%E8%AF%95npm%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h4 id="1-4-安装nrm（需要一点耐心）"><a href="#1-4-安装nrm（需要一点耐心）" class="headerlink" title="1.4 安装nrm（需要一点耐心）"></a>1.4 安装nrm（需要一点耐心）</h4><blockquote><p> nrm的安装原因：需要切换下载源到国内镜像源，提升下载速度</p></blockquote><ul><li>默认npm的全局安装路径在C盘，我们需要修改到nodejs的安装目录，新建两个文件夹: <code>node_global_modules</code> 和 <code>node_cache</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_3_%E4%BF%AE%E6%94%B9npm%E9%BB%98%E8%AE%A4%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84.png"></p><ul><li><p>在命令行执行以下两条命令修改npm配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set prefix &quot;D:\Java\nodejs\node_modules\npm\node_global_modules&quot;<br>npm config set cache &quot;D:\Java\nodejs\node_modules\npm\node_cache&quot;<br></code></pre></td></tr></table></figure></li><li><p>执行后输入以下命令，查看npm配置结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config ls<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_4_npm%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png"></p><ul><li>验证配置成功后，需要配置环境变量。在环境变量中，新建一个系统变量，变量名：<code>NODE_HOME</code>，变量值：<code>D:\dev\nodejs</code>，效果如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_5_%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE_HOME.png"></p><ul><li><p>在系统环境变量<code>Path</code>变量名中，新建变量值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">NODE_HOME%</span><br><span class="hljs-meta">%</span><span class="bash">NODE_HOME%\node_modules</span><br><span class="hljs-meta">%</span><span class="bash">NODE_HOME%\node_modules\npm\node_global_modules\</span><br></code></pre></td></tr></table></figure></li></ul><p>效果如图（下图第二个路径写错了）：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_6_%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%88%B0path.png"></p><ul><li><p>保存后重新打开命令行工具，执行性全局安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install nrm -g<br></code></pre></td></tr></table></figure><p>安装结束后如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_7_nrm%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C.png"></p></li><li><p>在命令行输入指令查看下载源，可能会报错如下图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nrm ls<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_8_nrm%E6%8A%A5%E9%94%99.png"></p></li><li><p>找到nrm目录(错误第四行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">at Object.&lt;anonymous&gt; (D:\Java\nodejs\node_modules\npm\node_global_modules\node_modules\nrm\cli.js:17:20)<br></code></pre></td></tr></table></figure></li><li><p>打开cli.js 第17行修改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//const NRMRC = path.join(process.env.HOME, &#x27;.nrmrc&#x27;); (删除)</span><br><span class="hljs-keyword">const</span> NRMRC = path.join(process.env[(process.platform == <span class="hljs-string">&#x27;win32&#x27;</span>) ? <span class="hljs-string">&#x27;USERPROFILE&#x27;</span> : <span class="hljs-string">&#x27;HOME&#x27;</span>], <span class="hljs-string">&#x27;.nrmrc&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>重新输入<code>nrm ls</code>查看下载源</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_9_%E6%9F%A5%E7%9C%8Bnrm%E4%B8%8B%E8%BD%BD%E6%BA%90.png"></p></li><li><p>修改下载源指令，推荐选择taobao</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nrm use taobao # 选择淘宝<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-安装Hexo框架"><a href="#2-安装Hexo框架" class="headerlink" title="2. 安装Hexo框架"></a>2. 安装Hexo框架</h3><h4 id="2-1-安装hexo-cli脚手架"><a href="#2-1-安装hexo-cli脚手架" class="headerlink" title="2.1 安装hexo-cli脚手架"></a>2.1 安装hexo-cli脚手架</h4><p>打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装成功如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_10_hexo-cli%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png"></p><h4 id="2-2-验证hexo-cli安装成功"><a href="#2-2-验证hexo-cli安装成功" class="headerlink" title="2.2 验证hexo-cli安装成功"></a>2.2 验证hexo-cli安装成功</h4><p>命令行输入测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_11_hexo-cli%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85.png"></p><h3 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3. 安装Git"></a>3. 安装Git</h3><p>具体可以参考我的<a href="https://lihengxu.github.io/2020/08/21/gitstudy/">Git总结</a></p><h2 id="二、使用Hexo搭建博客"><a href="#二、使用Hexo搭建博客" class="headerlink" title="二、使用Hexo搭建博客"></a>二、使用Hexo搭建博客</h2><h3 id="1-创建项目文件夹"><a href="#1-创建项目文件夹" class="headerlink" title="1. 创建项目文件夹"></a>1. 创建项目文件夹</h3><p>在本地硬盘创建并进入项目文件夹（blog），并在该文件夹下打开命令行工具</p><h3 id="2-初始化blog项目"><a href="#2-初始化blog项目" class="headerlink" title="2. 初始化blog项目"></a>2. 初始化blog项目</h3><p>使用hexo命令初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>初始化项目文件如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_12_blog%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6.png"></p><h3 id="3-运行hexo服务预览博客"><a href="#3-运行hexo服务预览博客" class="headerlink" title="3. 运行hexo服务预览博客"></a>3. 运行hexo服务预览博客</h3><p>在当前路径下输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>命令行出现访问路径，直接点击访问即可</p><p>默认样式如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_13_hexo%E5%8D%9A%E5%AE%A2%E9%A2%84%E8%A7%88.png"></p><h3 id="4-创建文章"><a href="#4-创建文章" class="headerlink" title="4. 创建文章"></a>4. 创建文章</h3><p>在当前路径下输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo n &#x27;hexo test&#x27;<br></code></pre></td></tr></table></figure><p>回车后出现以标题命名的.md文件路径，打开该文件编辑文章内容</p><h3 id="5-更新文章"><a href="#5-更新文章" class="headerlink" title="5. 更新文章"></a>5. 更新文章</h3><p>命令行输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览博客<br></code></pre></td></tr></table></figure><h2 id="三、-博客部署到GitHub"><a href="#三、-博客部署到GitHub" class="headerlink" title="三、 博客部署到GitHub"></a>三、 博客部署到GitHub</h2><h3 id="1-登陆GitHub创建仓库"><a href="#1-登陆GitHub创建仓库" class="headerlink" title="1. 登陆GitHub创建仓库"></a>1. 登陆GitHub创建仓库</h3><p>创建仓库命：LihengXu.github.io (注意第一个.前面一定是账户名)</p><h3 id="2-在本地目录安装git部署插件"><a href="#2-在本地目录安装git部署插件" class="headerlink" title="2. 在本地目录安装git部署插件"></a>2. 在本地目录安装git部署插件</h3><p>在项目根目录下打开命令行工具输入如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-deployer-git # --save 表示只在本目录下安装<br></code></pre></td></tr></table></figure><h3 id="3-修改项目根目录下的配置文件"><a href="#3-修改项目根目录下的配置文件" class="headerlink" title="3. 修改项目根目录下的配置文件"></a>3. 修改项目根目录下的配置文件</h3><p>找到<code>_config.yaml</code>文件</p><p>找到最下面的<code>deploy：type</code> 进行编辑:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/LihengXu/LihengXu.github.io.git</span> <br>  <span class="hljs-comment"># repo : github上创建的仓库地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><blockquote><p>上面的repo：建议使用ssh并绑定公钥， 详细见如何<a href="https://lihengxu.github.io/2020/08/21/Git/#%E4%BD%BF%E7%94%A8%E7%A0%81%E4%BA%91gitee">GIt：使用码云gitee</a>（gitee和github操作没有区别）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:LihengXu/LihengXu.github.io.git</span><br></code></pre></td></tr></table></figure><h3 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h3><p>项目根目录下打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>提示你输入GitHub账户和密码后将代码提交到GitHub仓库</p><p>通过<a href="https://lihengxu.github.io/">GitHub链接</a>可访问博客</p><h2 id="四、-更换主题"><a href="#四、-更换主题" class="headerlink" title="四、 更换主题"></a>四、 更换主题</h2><h3 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h3><p>将主题文件下载到本地项目的<code>theme</code>文件夹</p><p>在本地项目根目录下打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><h3 id="2-修改配置-config-yml"><a href="#2-修改配置-config-yml" class="headerlink" title="2. 修改配置 _config.yml"></a>2. 修改配置 _config.yml</h3><p>找到<code>#Extensions</code>项的theme</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><p><a href="https://hexo.fluid-dev.com/docs/start/">fluid主题使用指南</a>，可以进一步自定义更多设置</p><h3 id="3-更新并重新部署"><a href="#3-更新并重新部署" class="headerlink" title="3. 更新并重新部署"></a>3. 更新并重新部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览<br>hexo d # 部署到github<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用</title>
    <link href="/2020/08/21/Git/"/>
    <url>/2020/08/21/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git初步使用"><a href="#Git初步使用" class="headerlink" title="Git初步使用"></a>Git初步使用</h1><p><strong>前言</strong>：用了比较长时间的github了，一直都不能把git理清楚，于是决定整理一下git的学习笔记，供自己梳理和回顾。</p><p><strong>说明</strong>：这里思路是B站up狂神的git教学<a href="https://www.bilibili.com/video/BV1FE411P7B3?p=1">狂神聊Git</a>，给大家安利一下这个up，他许多视频都很不错。</p><hr><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote><p><strong>版本控制</strong>  版本迭代的版本管理器(Revision control)</p></blockquote><p>尤其在多人开发中，使用版本控制尤为重要</p><blockquote><p><strong>常见的版本控制工具</strong></p></blockquote><p>主流的版本控制器有：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong> (subversion)</li><li><strong>CVS</strong> (Concurrent Version System)</li><li><strong>VSS</strong> (Micorosoft Visual SourceSafe)</li><li><strong>TFS</strong> (Team Foudation Server)</li><li>Visual Studio Online</li></ul><p>现在影响力最大也是使用最广泛的是<strong>Git</strong>和<strong>SVN</strong></p><blockquote><p><strong>版本控制分类</strong></p></blockquote><ol><li><p><strong>本地版本控制</strong></p><p>记录文件每次更新，可以对每个版本做一个快照，或者是记录补丁文件，适用于个人，如RCS。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_1_%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p></li><li><p><strong>集中版本控制</strong></p><p>所有版本数据都保存在服务器上，协同开发者从服务器上同步更新或者上传自己的修改。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_2_%E9%9B%86%E4%B8%AD%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p><p>所有的版本数据保存在服务器上，用户本地只有自己的以前所同步的版本，如果不联网，用户看不到历史版本，也午饭切换版本验证问题，或者不同分支工作。而且，所有有数据都保存在单一服务器上，一旦服务器损坏就会丢失所有数据，需要定期备份。代表有：<strong>SVN CVS VSS</strong></p></li><li><p><strong>分布式版本控制</strong></p><p>所有版本星信息全部同步到本地的每一个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需要在连网时push到相应的服务器或者其他用户那里。由于每一个用户保存的都是所有的版本数据，只要有一个用户设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_3_%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p></li></ol><blockquote><p><strong>Git和SVN的区别</strong></p></blockquote><p><strong>SVN</strong>是集中式版本控制系统，版本库集中放在中央服务器的，而工作的时候，用自己电脑首先要从重要服务器得到最新版本，然后工作，完成工作后需要推送到中央服务器。集中实版本控制系统必须联网才能工作，对网络带宽要求较高</p><p><strong>Git</strong>是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同方式：你在电脑上修改了文件A，其他人也修改了文件A，你们俩只需要把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到。</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p><strong>GIt</strong>是Linux社区 (特别是Linux的缔造者<strong>Linus Torvalds</strong>) 基于使用<strong>BitKeeper</strong>时的经验教训，开发出的自己的版本系统。大约花了<strong>两周左右</strong>，也就是后来的<strong>Git</strong>。</p><p><strong>Git</strong>是免费的、开源的、最初Git是为辅助Linux内核开发的，来代替BitKeeper。</p><h2 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h2><blockquote><p><strong>Git下载</strong></p></blockquote><p>打开官网<a href="https://git-scm.com/">git官网</a>，下载git对应操作系统的版本</p><p>下载过慢就是用镜像下载<a href="http://npm.taobao.org/mirrors/git-for-windows/">淘宝镜像</a></p><blockquote><p><strong>Git卸载</strong></p></blockquote><p>直接反安装即可、清理环境变量</p><blockquote><p><strong>Git安装</strong></p></blockquote><p>无脑下一步安装即可。</p><blockquote><p><strong>启动Git</strong></p></blockquote><p>安装成功后开始菜单会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_4_git%E9%80%89%E9%A1%B9.png"></p><p><strong>Git Bash</strong>:  Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD</strong>:  Windows风格的命令行</p><p><strong>GIt GUI</strong>:  图形界面的GIt，不建议初学者使用，尽量先熟悉常用的命令</p><blockquote><p><strong>基本的Linux命令</strong></p></blockquote><ol><li><p><strong>cd</strong> 改变目录</p></li><li><p><strong>cd ..</strong> 回退到上一个目录，直接cd进入默认目录</p></li><li><p><strong>pwd</strong> 显示当前目录路径</p></li><li><p><strong>ls(ll)</strong> 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更加详细</p></li><li><p><strong>touch</strong> 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p></li><li><p><strong>rm</strong> 删除一个文件，rm index.js 就会把index.js删除掉</p></li><li><p><strong>mkdir</strong> 新建一个目录，就是新建一个文件夹</p></li><li><p><strong>rm -r</strong> 删除一个文件夹，rm -r src 删除src目录</p><p>切勿随意在Linux系统中使用<strong>rm -rf /</strong> ，会从根目录全部递归删除，那么会删除电脑中全部文件。</p></li><li><p><strong>mv</strong> 移动文件，mv index.html src index.html 是我们要移动的文件，src是目标文件夹，这么写必须在同一目录下。</p></li><li><p><strong>reset</strong> 重新初始化终端/清屏</p></li><li><p><strong>clear</strong> 清屏</p></li><li><p><strong>history</strong> 查看命令历史</p></li><li><p><strong>help</strong> 帮助</p></li><li><p><strong>exit</strong> 退出</p></li><li><p>**#**表示注释</p></li></ol><blockquote><p><strong>Git配置</strong></p></blockquote><p>查看配置 <strong>git config -l</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_5_git%E9%85%8D%E7%BD%AE.png"></p><p>查看不同级别的配置文件 (都保存在本地) ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统config</span><br>git config --system --list<br><br><span class="hljs-comment"># 查看当前用户(global)配置</span><br>git config --global --list<br></code></pre></td></tr></table></figure><p><strong>Git相关的配置文件：</strong></p><ol><li>Git\etc\gitconfig : Git 安装目录下的gitconfig –system 系统级</li><li>C:\UsersAdminstrator\ .gitconfig 只适用于当前登录用户配置 –global 全局</li></ol><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里</p><blockquote><p><strong>配置用户名与邮箱 (用户标识，必要)</strong></p></blockquote><p>当你安装git后首先要设置你的用户名和e-mail地址。这非常重要，每次git提交都会使用该信息。它会被永远嵌入到你的提交中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;lihengxu&quot;</span> <span class="hljs-comment"># 名称</span><br>git config --global user.email 15882320389@163.com <span class="hljs-comment"># 邮箱</span><br></code></pre></td></tr></table></figure><p>只需要设置一次，只要传递了–global选项，Git将总会使用该信息来处理你在系统中的一切处理。如果你希望在一个特定的项目中使用不同的名称或email地址，你可以在该项目运行该命令而不要–global选项。总之–global为全局配置，不加为某一个项目的特定配置。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_6_git%E9%85%8D%E7%BD%AE--global.png"></p><h2 id="Git基本理论-核心"><a href="#Git基本理论-核心" class="headerlink" title="Git基本理论 (核心)"></a>Git基本理论 (核心)</h2><blockquote><p><strong>工作区域</strong></p></blockquote><p>Git本地有三个工作区域：</p><ol><li>工作目录(Working Direcitory)</li><li>暂存区(Stage/Index)</li><li>资源区(Repository 或 GIt Directory)</li></ol><p>如果加上远程的</p><ol start="4"><li>Git仓库(Remote Directory)</li></ol><p>就可以分为4个工作区域，转换关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_7_git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F.png"></p><ul><li><strong>Workspace</strong>: 工作区，就是平时你存放项目代码的地方</li><li><strong>Index/Stage</strong>： 暂存区，用于平时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li><strong>Repository</strong>：仓库区(或者本地仓库)， 就是安全存放数据的位置，这里面有你提交的所有版本数据。其中HEAD指向最新放入仓库的版本。</li><li><strong>Remote</strong>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</li></ul><p>本地三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_8_HEAD%E6%8C%87%E5%90%91%E7%9A%84%E7%89%88%E6%9C%AC.png"></p><ul><li><strong>Directory</strong>：使用GIt管理的目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li><strong>WorkSpace</strong>：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间</li><li><strong>.git</strong>：存放管理信息的目录，初始化仓库的时候自动创建。</li><li><strong>Index/Stage</strong>：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li><strong>Local Repo</strong>：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支(branch)。</li><li><strong>Stash</strong>：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><blockquote><p><strong>工作流程</strong></p></blockquote><p>git的工作流程一般是这样的：</p><ol><li>在工作目录中添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；</li><li>将暂存区域的文件提交到git仓库。</li></ol><p>因此，git管理文件有三种状态：已修改(modified)、已暂存(staged)、已提交(committed)</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_9_git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><blockquote><p>创建工程目录与常用指令</p></blockquote><p>工作目录(WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你的项目的目录，也可以是一个空目录，建议不要有中文，日常使用一下图中6个命令：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_10_git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库有两种方法：一种是创建一个全新仓库，另一种是克隆远程仓库。</p><ol><li><p>创建全新仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前目录中新建一个Git代码库</span><br>$ git init<br></code></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目中多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p></li></ol><blockquote><p>克隆远程仓库</p></blockquote><ol><li><p>另一种方式是克隆远程目录，也就是将远程服务器上的仓库完全镜像一份到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆一个项目和它整个历史代码(版本信息)</span><br>$ git <span class="hljs-built_in">clone</span> https://github.com/LihengXu/WPS_Apolloscape.git<br></code></pre></td></tr></table></figure></li><li><p>去gitee或者github上克隆一个测试</p></li></ol><h2 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h2><blockquote><p><strong>文件4种状态</strong></p></blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改，提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在不想提交的文件，或者要提交的文件没有提交上。</p><ul><li><strong>Untracked</strong>：未跟踪，此文件在文件夹种，并没有加入到git库，不参与版本控制，通过<code>git add</code> 状态变为 <code>staged</code></li><li><strong>Unmodify</strong>：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中的完全一致。这种类型的文件有两种去处，如果它被修改，而变为<code>Modified</code>，如果使用<code>git rm</code>移出版本库，则成为<code>untracked</code>文件</li><li><strong>Modified</strong>：文件已修改，仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过<code>git add</code>可以进入暂存<code>staged</code>状态，使用<code>git checkout</code>则丢弃修改，返回到<code>Unmodify</code>状态，这个<code>git checkout</code> 即从库中取出文件，覆盖当前修改。</li><li><strong>Staged</strong>：暂存状态。执行<code>git commit</code>则将修改同步到库中，这是库中文件和本地文件右边为一致，文件为<code>Unmodify</code>状态。执行<code>git reset HEAD filename</code>取消暂存，文件状态为<code>Modified</code>。</li></ul><blockquote><p><strong>查看文件状态</strong></p></blockquote><p>上面说文件有4种状态，通过如下命令可以查看文件的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看指定文件状态</span><br>git status [filename]<br><br><span class="hljs-comment"># 查看所有文件状态</span><br>git status<br><br><span class="hljs-comment"># 添加所有文件到暂存区</span><br>git add .<br><br><span class="hljs-comment"># 删除仓库中的&quot;README.en.md&quot;文件</span><br>git rm README.en.md<br><br><span class="hljs-comment"># 提交暂存区中内容到本地仓库，-m 提交信息</span><br>git commit -m <span class="hljs-string">&quot;for test&quot;</span><br><br><span class="hljs-comment"># 提交至远程仓库</span><br>git push<br></code></pre></td></tr></table></figure><blockquote><p><strong>忽略文件</strong></p></blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下面建立一个”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或者以井号(#)开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号(*)代表任意多字符，问号(?)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2,…})代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号(!)，表示例外规则，将不会忽略。</li><li>如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 为注释</span><br>*.txt      <span class="hljs-comment"># 忽略所有.txt结尾的文件，这样的话上传就不会被选中。</span><br>!lib.txt   <span class="hljs-comment"># 但lib.txt除外</span><br>/temp      <span class="hljs-comment"># 仅忽略根目录下的TODO文件，不包括其他目录temp</span><br>build/     <span class="hljs-comment"># 忽略build/目录下的所有文件</span><br>doc/*.txt  <span class="hljs-comment"># 会忽略doc/notes.txt但不包括doc/server/arch.txt</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通常前后端项目都需要的.gitignore的配置</span><br>*.class<br>*.<span class="hljs-built_in">log</span><br>*.lock<br><br><span class="hljs-comment"># Package Files #</span><br>*.jar<br>*.war<br>*.ear<br>target/<br><br><span class="hljs-comment"># idea</span><br>.idea/<br>*.iml<br><br>*velocity.log*<br><br><span class="hljs-comment">### STS ###</span><br>.apt_generated<br>.factorypath<br>.springBeans<br><br><span class="hljs-comment">### IntelliJ IDEA###</span><br>*.iml<br>*.ipr<br>*.iws<br>.idea<br>.classpath<br>.project<br>.settings/<br>bin/<br><br>*.<span class="hljs-built_in">log</span><br>tmp/<br><br><span class="hljs-comment">#rebel</span><br>*rebel.xml*<br></code></pre></td></tr></table></figure><h2 id="使用码云gitee"><a href="#使用码云gitee" class="headerlink" title="使用码云gitee"></a>使用码云gitee</h2><blockquote><p>国内一般使用gitee，而通常全球范围内大多都是用github，两者使用几乎一致，有些公司会自己搭建gitlab服务器</p></blockquote><ol><li><p>注册登录码云，完善个人信息，点击自己头像选设置</p></li><li><p>设置本机绑定SSH公钥，实现免密码登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入C:\Users\Administrator\.ssh目录</span><br><span class="hljs-comment"># 生成公钥，-t rsa是选择加密方式</span><br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_11_%E5%85%AC%E9%92%A5%E7%94%9F%E6%88%90%E7%BB%93%E6%9E%9C.png"></p></li><li><p>将公钥信息public key (打开上面的<code>.pub</code>文件，这就是公钥)添加到码云账户中即可</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_12_%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%A4%84.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_13_%E6%B7%BB%E5%8A%A0%E6%88%90%E5%8A%9F%E5%90%8E.png"></p></li><li><p>使用码云创建自己的仓库</p><p>新建仓库的位置</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_14_%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%931.png"></p><p>若公开的话有一个许可证选项：</p><p>开源是否可以随意转载，开源但是不能商用，等等各种限制协议。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_15_%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png"></p></li><li><p>最后克隆至本地即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://gitee.com/lihengxu/gitstudy.git<br></code></pre></td></tr></table></figure></li></ol><h2 id="IDEA中集成Git"><a href="#IDEA中集成Git" class="headerlink" title="IDEA中集成Git"></a>IDEA中集成Git</h2><p> <strong>(和Pycharm基本相同)</strong></p><ol><li>新建项目，绑定git<ul><li>将远程的git文件目录直接拷贝到项目中即可，或者直接创建项目到git文件目录下</li></ul></li><li>修改文件，使用IDEA操作git<ul><li>添加到暂存区：命令行 <code>git add .</code> ；或者手动鼠标右键点文件，选GIt然后点Add</li><li>commit提交：界面右上角有一个commit选项，点击后选择，并输入一下message即可</li><li>push到远程仓库：直接在命令行中输入<code>git push</code>即可</li></ul></li><li>提交测试</li></ol><hr><p><strong>以上全部都不涉及分支，全是单人操作</strong></p><hr><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支类似平行宇宙的概念，适用于多人协同开发</p><p>当存在多个分支，我们进行分支合并时，可能会有冲突产生</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_16_git%E5%88%86%E6%94%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>git分支中常见命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>git branch<br><br><span class="hljs-comment"># 列出所偶远程分支</span><br>git branch -r<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>git branch [branch -name]<br><br><span class="hljs-comment"># 切换到该分支</span><br>git checkout [branch]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><br><span class="hljs-comment"># 重命名分支</span><br>git branch -m [branch -oldname] [branch -newname]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 中止这一次提交的合并(当遇到冲突时)</span><br>$ git merge --abort<br><br><span class="hljs-comment"># 将分支变基(Rebase)到master</span><br><span class="hljs-comment"># 先切换到分支，再完成变基</span><br>$ git checkout [branch]<br>$ git rebase master<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch -name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch -name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><blockquote><p>想要形象的快速理解分支的概念，推荐一款图形化客户端<a href="https://www.gitkraken.com/">GitKraken</a></p></blockquote><blockquote><p>建议使用github账号关联登录，这里推荐<a href="https://www.bilibili.com/video/BV1KD4y1S7FL">教程</a>以及关于分支的进阶<a href="https://www.bilibili.com/video/bv1hA411v7qX/">教程</a></p></blockquote><p>注意主分支master应该非常稳定，只有分支代码稳定之后才能合并到主分支上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Git其实还是比较简单的，很多命令其实只要多用就能熟悉，尤其时分支的操作，这部分用图形界面多使用就能理解得更深刻</li><li>gitee下面有一个git大全，更多得一些插件，命令都能在里面查询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

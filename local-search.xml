<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蚂蚁大安全java开发实习面经（2+1）</title>
    <link href="/2021/04/22/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%EF%BC%9A%E8%9A%82%E8%9A%81cro%E7%BA%BF%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E7%BB%8F2+1/"/>
    <url>/2021/04/22/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%EF%BC%9A%E8%9A%82%E8%9A%81cro%E7%BA%BF%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E7%BB%8F2+1/</url>
    
    <content type="html"><![CDATA[<h1 id="蚂蚁大安全面经（2-1）"><a href="#蚂蚁大安全面经（2-1）" class="headerlink" title="蚂蚁大安全面经（2+1）"></a>蚂蚁大安全面经（2+1）</h1><p>我面试遇到的蚂蚁面试官感觉都挺和蔼的，说话很客气，面试体验非常良好。</p><h2 id="1-一面（50min）"><a href="#1-一面（50min）" class="headerlink" title="1. 一面（50min）"></a>1. 一面（50min）</h2><p>成都的面试官</p><ul><li>自我介绍</li><li>你了解设计模式么？</li><li>介绍一下单例模式？大概有哪些实现方式及其线程安全问题？（懒汉双重检查锁、懒汉静态内部类、饿汉静态变量直接加载、枚举）</li><li>你简单介绍一下其他你用过的设计模式及其思想？（装饰、构造者、代理、工厂、模板、适配器..）</li><li>这些设计模式你是怎么用到他们的？或者说怎么被应用？（回答一些经典的JDK代码中的设计模式以及Mybatis中的一些模式应用，当时spring还没怎么看完，所以没有谈在spring中的应用，说错了就画蛇添足了）</li><li>谈谈你对设计模式的理解？</li><li>你用过哪些语言？</li><li>这两种语言的区别是什么？（我说python和java了，然后主要回答了java的特性，python了解的不深入大概说了说）</li><li>浏览器访问网址的过程？</li><li>服务器响应http请求的具体过程？</li><li>线程创建方法有哪些？（回答了三种：继承thread类，runnable接口实现，以及futuretask结合callable接口是实现）</li><li>线程怎么终止有哪些方式？（考察直接终止和两阶段终止）</li><li>ThreadLocal？（我没听清面试官具体问的啥，他就说下一个问题吧..）</li><li>问项目？（简历的三个项目全问了一遍motivation和我的贡献）</li><li>项目中遇到的困难？</li><li>你为什么选我们部门？</li><li>你对我们公司有什么了解？</li></ul><h2 id="2-二面（50min）"><a href="#2-二面（50min）" class="headerlink" title="2. 二面（50min）"></a>2. 二面（50min）</h2><p>杭州的面试官</p><ul><li>自我介绍</li><li>重点介绍一下，你最主要的项目（主要对我的论文项目感兴趣）</li><li>项目的困难？（就把会议论文拓展成期刊的拓展当作困难解释了一遍，并如何解决的）</li><li>你怎么学习数据结构的？</li><li>如何用两个栈实现队列？（剑指offer原题）</li><li>上面这个问题如果是并发的压入和弹出，怎么改善？<ul><li>使用了一个volatile修饰的标志位，结合synchronize关键字实现了一个简单的balking模式（我也不知道对不对，至少看上去没啥问题）</li><li>其总感觉还有问题，当时我觉得原始的deque实现的栈依然有线程问题，但是我提了一下，如果这个也要锁的话，这道题就变成手写一个阻塞队列了，面试官没让我写下去了）</li></ul></li><li>10亿个数，找最大1000个怎么做？复杂度怎么算？（最小堆，nlog1000）</li><li>使用最小堆这个数据结构的解决方案还能改进么？<ul><li>当时没想出来</li><li>复盘和同学讨论，感觉应该可以分成10分，分别用堆排得到10个top1000，再对10个top1000再排一次，复杂度并没有变化但是并发度提高了10倍</li></ul></li><li>计网TCP你对这个的理解（回答的实现数据可靠性：确认、重传、校验和、拥塞控制、流量控制等等）</li><li>如果是支付场景你会选哪一种协议（TCP/UDP）</li><li>如果是游戏的话你会选哪一种协议（TCP/UDP）</li><li>那这种支付的场景保证安全需要加密，你了解哪些加密算法？</li><li>不对称加密的公钥和私钥是如何生成的？</li><li>你学习的渠道有哪些？</li><li>你做阿里笔试题有遇到过平时做过的题目么？</li><li>你觉得你是一个怎样的人？</li><li>你的职业规划是什么？</li></ul><h2 id="3-HR面（30min）"><a href="#3-HR面（30min）" class="headerlink" title="3. HR面（30min）"></a>3. HR面（30min）</h2><p>全是非技术问题，氛围比较轻松，面试官看上去全程挺开心的（我说话很搞笑？🐕）</p><ul><li>自我介绍</li><li>项目</li><li>最有成就的事情</li><li>遇到最大的困难</li><li>坚持最长时间的事情</li><li>你来我们公司相比别的实习生有什么优势</li><li>你的优劣是什么</li><li>你参加一些生活组织活动么</li><li>你现在的学习安排是什么</li><li>你大概什么时候能入职？你选择的base地点在哪？</li></ul><h2 id="4-准备面试的感悟"><a href="#4-准备面试的感悟" class="headerlink" title="4. 准备面试的感悟"></a>4. 准备面试的感悟</h2><p>从3月底勉强准备好开始投简历，到现在，发生了各种各样出乎意料的事情（哎~~）</p><p>从去年年底开始自学java开发，面了这么多之后感觉半路出家想找到合适的开发实习确实挺难的，很多公司笔试完就没动静了，甚至笔试都不给一点反应（可能成都岗位不多也是原因，哎，心累..）。只能每天都高强度地弥补开发基础，复习八股文。万幸的是，还好最后拿到了第一个offer。后面我应该把已经投出去的流程都走完就不投了。</p><p>这里鼓励一下大家，一定不要因为一次面试体验极差或者表现不好就否定自己，真的运气成分还是很大的（教研室周围人都被某鹅厂鞭尸后得出的结论，以上仅是个人观点）。最后希望各位都能拿到满意的offer，大家加油，求职路上、与君共勉！</p>]]></content>
    
    
    <categories>
      
      <category>Interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2021/04/17/JVM/"/>
    <url>/2021/04/17/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p><a href="https://www.bilibili.com/video/BV1yE411Z7AP"><strong>解密JVM【黑马程序员出品】</strong></a>教学视频的笔记（转载<a href="https://nyimac.gitee.io/2020/07/03/JVM%E5%AD%A6%E4%B9%A0/#2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">nyimac</a>，做一条懒🐕，这个人做的不错）</p><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" alt="img"></a></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt="img"></a></p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>method1();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> c = a + b;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" alt="img"></a></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img"></a></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.java<br></code></pre></td></tr></table></figure><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.class<br></code></pre></td></tr></table></figure></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" alt="img"></a></p></li><li><p>常量池</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" alt="img"></a></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" alt="img"></a></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String a = <span class="hljs-string">&quot;a&quot;</span>; <br>String b = <span class="hljs-string">&quot;b&quot;</span>;<br>String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">0: ldc           #2                  // String a<br>2: astore_1<br>3: ldc           #3                  // String b<br>5: astore_2<br>6: ldc           #4                  // String ab<br>8: astore_3<br>9: return<br></code></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String a = <span class="hljs-string">&quot;a&quot;</span>;<br>String b = <span class="hljs-string">&quot;b&quot;</span>;<br>String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br>String ab2 = a+b; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"> Code:<br>      stack=2, locals=5, args_size=1<br>         0: ldc           #2                  // String a<br>         2: astore_1<br>         3: ldc           #3                  // String b<br>         5: astore_2<br>         6: ldc           #4                  // String ab<br>         8: astore_3<br>         9: new           #5                  // class java/lang/StringBuilder<br>        12: dup<br>        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V<br>        16: aload_1<br>        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String<br>;)Ljava/lang/StringBuilder;<br>        20: aload_2<br>        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String<br>;)Ljava/lang/StringBuilder;<br>        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str<br>ing;<br>        27: astore        4<br>        29: return<br></code></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>String ab2 = a+b;<br><span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(ab == ab2);<br></code></pre></td></tr></table></figure><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String a = <span class="hljs-string">&quot;a&quot;</span>;<br>String b = <span class="hljs-string">&quot;b&quot;</span>;<br>String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>String ab2 = a+b;<br><span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">   Code:<br>      stack=2, locals=6, args_size=1<br>         0: ldc           #2                  // String a<br>         2: astore_1<br>         3: ldc           #3                  // String b<br>         5: astore_2<br>         6: ldc           #4                  // String ab<br>         8: astore_3<br>         9: new           #5                  // class java/lang/StringBuilder<br>        12: dup<br>        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V<br>        16: aload_1<br>        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String<br>;)Ljava/lang/StringBuilder;<br>        20: aload_2<br>        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String<br>;)Ljava/lang/StringBuilder;<br>        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str<br>ing;<br>        27: astore        4<br>        //ab3初始化时直接从串池中获取字符串<br>        29: ldc           #4                  // String ab<br>        31: astore        5<br>        33: return<br></code></pre></td></tr></table></figure><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br>String st2 = str.intern();<br><span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br>String str2 = str.intern();<br>        <span class="hljs-comment">//false</span><br>System.out.println(str == str2);<br>        <span class="hljs-comment">//false</span><br>System.out.println(str == str3);<br>        <span class="hljs-comment">//true</span><br>System.out.println(str2 == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:StringTableSize=xxxx<br></code></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span><br>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span><br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br></code></pre></td></tr></table></figure><p>对应对象的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" alt="img"></a></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img"></a></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br><br><span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br><span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>list.remove(poll);<br><span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>poll = queue.poll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img"></a></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></a></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" alt="img"></a></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" alt="img"></a></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" alt="img"></a></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" alt="img"></a></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" alt="img"></a></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" alt="img"></a></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" alt="img"></a></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" alt="img"></a></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" alt="img"></a></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;<br></code></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" alt="img"></a></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000</span> ca fe ba be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">23</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">09</span> <br><span class="hljs-attribute">0000020</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">17</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">18</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>a <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">07</span> <br><span class="hljs-attribute">0000040</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>c <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">3</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <br><span class="hljs-attribute">0000060</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">43</span> <span class="hljs-number">6</span>f <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>f <span class="hljs-number">4</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">65</span> <span class="hljs-number">4</span>e <br><span class="hljs-attribute">0000100</span> <span class="hljs-number">75</span> <span class="hljs-number">6</span>d <span class="hljs-number">62</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>f <span class="hljs-number">63</span> <br><span class="hljs-attribute">0000120</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">56</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <br><span class="hljs-attribute">0000140</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">4</span>c <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">63</span> <br><span class="hljs-attribute">0000160</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2</span>f <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2</span>f <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6</span>f <br><span class="hljs-attribute">0000200</span> <span class="hljs-number">57</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <br><span class="hljs-attribute">0000220</span> <span class="hljs-number">28</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <br><span class="hljs-attribute">0000240</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <br><span class="hljs-attribute">0000260</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <br><span class="hljs-attribute">0000300</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">6</span>f <span class="hljs-number">64</span> <span class="hljs-number">50</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <br><span class="hljs-attribute">0000320</span> <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">53</span> <span class="hljs-number">6</span>f <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">46</span> <br><span class="hljs-attribute">0000340</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>f <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6</span>f <span class="hljs-number">57</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span><br><span class="hljs-attribute">0000360</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">1</span>e <br><span class="hljs-attribute">0000400</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>f <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6</span>f <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <br><span class="hljs-attribute">0000420</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">22</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">74</span> <br><span class="hljs-attribute">0000440</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2</span>f <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2</span>f <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <br><span class="hljs-attribute">0000460</span> <span class="hljs-number">6</span>f <span class="hljs-number">57</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <br><span class="hljs-attribute">0000500</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">4</span>f <span class="hljs-number">62</span> <span class="hljs-number">6</span>a <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <br><span class="hljs-attribute">0000520</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">79</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>d <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">6</span>f <br><span class="hljs-attribute">0000540</span> <span class="hljs-number">75</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">6</span>f <span class="hljs-number">2</span>f <span class="hljs-number">50</span> <span class="hljs-number">72</span> <br><span class="hljs-attribute">0000560</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <br><span class="hljs-attribute">0000600</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">6</span>f <span class="hljs-number">2</span>f <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <br><span class="hljs-attribute">0000620</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">70</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <br><span class="hljs-attribute">0000640</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <br><span class="hljs-attribute">0000660</span> <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <br><span class="hljs-attribute">0000700</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2</span>f <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <br><span class="hljs-attribute">0000720</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">2</span>a b<span class="hljs-number">7</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> b<span class="hljs-number">1</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <br><span class="hljs-attribute">0000740</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <br><span class="hljs-attribute">0000760</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001000</span> <span class="hljs-number">0</span>f <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001020</span> <span class="hljs-number">09</span> b<span class="hljs-number">2</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b<span class="hljs-number">6</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> b<span class="hljs-number">1</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <br><span class="hljs-attribute">0001040</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <br><span class="hljs-attribute">0001060</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001100</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001120</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">14</span> <br></code></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">u4  magic<br>u2             minor_version<span class="hljs-comment">;    </span><br>u2             major_version<span class="hljs-comment">;    </span><br>u2             constant_pool_count<span class="hljs-comment">;    </span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>]<span class="hljs-comment">;    </span><br>u2             access_flags<span class="hljs-comment">;    </span><br>u2             this_class<span class="hljs-comment">;    </span><br>u2             super_class<span class="hljs-comment">;   </span><br>u2             interfaces_count<span class="hljs-comment">;    </span><br>u2             interfaces[interfaces_count]<span class="hljs-comment">;   </span><br>u2             fields_count<span class="hljs-comment">;    </span><br>field_info     fields[fields_count]<span class="hljs-comment">;   </span><br>u2             methods_count<span class="hljs-comment">;    </span><br>method_info    methods[methods_count]<span class="hljs-comment">;    </span><br>u2             attributes_count<span class="hljs-comment">;    </span><br>attribute_info attributes[attributes_count]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs shell">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy<br>F:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.class<br>Classfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class<br>  Last modified 2020-6-6; size 434 bytes<br>  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e<br>  Compiled from &quot;Demo1.java&quot;<br>public class com.nyima.JVM.day5.Demo1<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br><span class="hljs-meta">   #</span><span class="bash">1 = Methodref          <span class="hljs-comment">#6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="hljs-meta">   #</span><span class="bash">2 = Fieldref           <span class="hljs-comment">#16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="hljs-meta">   #</span><span class="bash">3 = String             <span class="hljs-comment">#18            // hello world</span></span><br><span class="hljs-meta">   #</span><span class="bash">4 = Methodref          <span class="hljs-comment">#19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="hljs-meta">   #</span><span class="bash">5 = Class              <span class="hljs-comment">#21            // com/nyima/JVM/day5/Demo1</span></span><br><span class="hljs-meta">   #</span><span class="bash">6 = Class              <span class="hljs-comment">#22            // java/lang/Object</span></span><br><span class="hljs-meta">   #</span><span class="bash">7 = Utf8               &lt;init&gt;</span><br><span class="hljs-meta">   #</span><span class="bash">8 = Utf8               ()V</span><br><span class="hljs-meta">   #</span><span class="bash">9 = Utf8               Code</span><br><span class="hljs-meta">  #</span><span class="bash">10 = Utf8               LineNumberTable</span><br><span class="hljs-meta">  #</span><span class="bash">11 = Utf8               main</span><br><span class="hljs-meta">  #</span><span class="bash">12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="hljs-meta">  #</span><span class="bash">13 = Utf8               SourceFile</span><br><span class="hljs-meta">  #</span><span class="bash">14 = Utf8               Demo1.java</span><br><span class="hljs-meta">  #</span><span class="bash">15 = NameAndType        <span class="hljs-comment">#7:#8          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="hljs-meta">  #</span><span class="bash">16 = Class              <span class="hljs-comment">#23            // java/lang/System</span></span><br><span class="hljs-meta">  #</span><span class="bash">17 = NameAndType        <span class="hljs-comment">#24:#25        // out:Ljava/io/PrintStream;</span></span><br><span class="hljs-meta">  #</span><span class="bash">18 = Utf8               hello world</span><br><span class="hljs-meta">  #</span><span class="bash">19 = Class              <span class="hljs-comment">#26            // java/io/PrintStream</span></span><br><span class="hljs-meta">  #</span><span class="bash">20 = NameAndType        <span class="hljs-comment">#27:#28        // println:(Ljava/lang/String;)V</span></span><br><span class="hljs-meta">  #</span><span class="bash">21 = Utf8               com/nyima/JVM/day5/Demo1</span><br><span class="hljs-meta">  #</span><span class="bash">22 = Utf8               java/lang/Object</span><br><span class="hljs-meta">  #</span><span class="bash">23 = Utf8               java/lang/System</span><br><span class="hljs-meta">  #</span><span class="bash">24 = Utf8               out</span><br><span class="hljs-meta">  #</span><span class="bash">25 = Utf8               Ljava/io/PrintStream;</span><br><span class="hljs-meta">  #</span><span class="bash">26 = Utf8               java/io/PrintStream</span><br><span class="hljs-meta">  #</span><span class="bash">27 = Utf8               println</span><br><span class="hljs-meta">  #</span><span class="bash">28 = Utf8               (Ljava/lang/String;)V</span><br>&#123;<br>  public com.nyima.JVM.day5.Demo1();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         4: return<br>      LineNumberTable:<br>        line 7: 0<br><br>  public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=1, args_size=1<br>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #3                  // String hello world<br>         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br><br>         8: return<br>      LineNumberTable:<br>        line 9: 0<br>        line 10: 8<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <br><span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br><span class="hljs-keyword">int</span> c = a + b;        <br>System.out.println(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;<br>x = x++;<br>i++;<br>&#125;<br>System.out.println(x); <span class="hljs-comment">//接过为0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=2, locals=3, args_size=1//操作数栈分配2个空间，局部变量表分配3个空间<br>        0: iconst_0//准备一个常数0<br>        1: istore_1//将常数0放入局部变量表的1号槽位 i=0<br>        2: iconst_0//准备一个常数0<br>        3: istore_2//将常数0放入局部变量的2号槽位 x=0<br>        4: iload_1//将局部变量表1号槽位的数放入操作数栈中<br>        5: bipush        10//将数字10放入操作数栈中，此时操作数栈中有2个数<br>        7: if_icmpge     21//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空<br>       10: iload_2//将局部变量2号槽位的数放入操作数栈中，放入的值是0<br>       11: iinc          2, 1//将局部变量2号槽位的数加1，自增后，槽位中的值为1<br>       14: istore_2//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0<br>       15: iinc          1, 1 //1号槽位的值自增1<br>       18: goto          4 //跳转到第4条指令<br>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       24: iload_2<br>       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V<br>       28: return<br></code></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(i); <span class="hljs-comment">//结果为30</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">stack=1, locals=0, args_size=0<br>         0: bipush        10<br>         2: putstatic     #3                  // Field i:I<br>         5: bipush        20<br>         7: putstatic     #3                  // Field i:I<br>        10: bipush        30<br>        12: putstatic     #3                  // Field i:I<br>        15: return<br></code></pre></td></tr></table></figure><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;<br><br>&#123;<br>b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>&#123;<br>a = <span class="hljs-string">&quot;s2&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.a = a;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>System.out.println(d.a);<br>System.out.println(d.b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=2, locals=3, args_size=3<br>        0: aload_0<br>        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>        4: aload_0<br>        5: ldc           #2                  // String s1<br>        7: putfield      #3                  // Field a:Ljava/lang/String;<br>       10: aload_0<br>       11: bipush        20<br>       13: putfield      #4                  // Field b:I<br>       16: aload_0<br>       17: bipush        10<br>       19: putfield      #4                  // Field b:I<br>       22: aload_0<br>       23: ldc           #5                  // String s2<br>       25: putfield      #3                  // Field a:Ljava/lang/String;<br>       //原始构造方法在最后执行<br>       28: aload_0<br>       29: aload_1<br>       30: putfield      #3                  // Field a:Ljava/lang/String;<br>       33: aload_0<br>       34: iload_2<br>       35: putfield      #4                  // Field b:I<br>       38: return<br></code></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();<br>demo5.test1();<br>demo5.test2();<br>demo5.test3();<br>Demo5.test4();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>      stack=2, locals=2, args_size=1<br>         0: new           #2                  // class com/nyima/JVM/day5/Demo5 <br>         3: dup<br>         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V<br>         7: astore_1<br>         8: aload_1<br>         9: invokespecial #4                  // Method test1:()V<br>        12: aload_1<br>        13: invokespecial #5                  // Method test2:()V<br>        16: aload_1<br>        17: invokevirtual #6                  // Method test3:()V<br>        20: invokestatic  #7                  // Method test4:()V<br>        23: return<br></code></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=1, locals=3, args_size=1<br>        0: iconst_0<br>        1: istore_1<br>        2: bipush        10<br>        4: istore_1<br>        5: goto          12<br>        8: astore_2<br>        9: bipush        20<br>       11: istore_1<br>       12: return<br>     //多出来一个异常表<br>     Exception table:<br>        from    to  target type<br>            2     5     8   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=1, locals=3, args_size=1<br>        0: iconst_0<br>        1: istore_1<br>        2: bipush        10<br>        4: istore_1<br>        5: goto          19<br>        8: astore_2<br>        9: bipush        20<br>       11: istore_1<br>       12: goto          19<br>       15: astore_2<br>       16: bipush        30<br>       18: istore_1<br>       19: return<br>     Exception table:<br>        from    to  target type<br>            2     5     8   Class java/lang/ArithmeticException<br>            2     5    15   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=1, locals=4, args_size=1<br>        0: iconst_0<br>        1: istore_1<br>        //try块<br>        2: bipush        10<br>        4: istore_1<br>        //try块执行完后，会执行finally    <br>        5: bipush        30<br>        7: istore_1<br>        8: goto          27<br>       //catch块     <br>       11: astore_2 //异常信息放入局部变量表的2号槽位<br>       12: bipush        20<br>       14: istore_1<br>       //catch块执行完后，会执行finally        <br>       15: bipush        30<br>       17: istore_1<br>       18: goto          27<br>       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   <br>       21: astore_3<br>       22: bipush        30<br>       24: istore_1<br>       25: aload_3<br>       26: athrow  //抛出异常<br>       27: return<br>     Exception table:<br>        from    to  target type<br>            2     5    11   Class java/lang/Exception<br>            2     5    21   any<br>           11    15    21   any<br></code></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = Demo3.test();<br>        <span class="hljs-comment">//结果为20</span><br>System.out.println(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=1, locals=3, args_size=0<br>        0: bipush        10<br>        2: istore_0<br>        3: iload_0<br>        4: istore_1  //暂存返回值<br>        5: bipush        20<br>        7: istore_0<br>        8: iload_0<br>        9: ireturn//ireturn会返回操作数栈顶的整型值20<br>       //如果出现异常，还是会执行finally块中的内容，没有抛出异常<br>       10: astore_2<br>       11: bipush        20<br>       13: istore_0<br>       14: iload_0<br>       15: ireturn//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！<br>     Exception table:<br>        from    to  target type<br>            0     5    10   any<br></code></pre></td></tr></table></figure><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i = Demo3.test();<br>      <span class="hljs-comment">//最终结果为20</span><br>      System.out.println(i);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = Demo4.test();<br>System.out.println(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=1, locals=3, args_size=0<br>        0: bipush        10<br>        2: istore_0 //赋值给i 10<br>        3: iload_0//加载到操作数栈顶<br>        4: istore_1 //加载到局部变量表的1号位置<br>        5: bipush        20<br>        7: istore_0 //赋值给i 20<br>        8: iload_1 //加载局部变量表1号位置的数10到操作数栈<br>        9: ireturn //返回操作数栈顶元素 10<br>       10: astore_2<br>       11: bipush        20<br>       13: istore_0<br>       14: aload_2 //加载异常<br>       15: athrow //抛出异常<br>     Exception table:<br>        from    to  target type<br>            3     5    10   any<br></code></pre></td></tr></table></figure><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>Lock lock = <span class="hljs-keyword">new</span> Lock();<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>System.out.println(i);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>     stack=2, locals=5, args_size=1<br>        0: bipush        10<br>        2: istore_1<br>        3: new           #2                  // class com/nyima/JVM/day06/Lock<br>        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗<br>        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V<br>       10: astore_2 //剩下的一份放到局部变量表的2号位置<br>       11: aload_2 //加载到操作数栈<br>       12: dup //复制一份，放到操作数栈，用于加锁时消耗<br>       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用<br>       14: monitorenter //加锁<br>       //锁住后代码块中的操作    <br>       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       18: iload_1<br>       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br>       //加载局部变量表中三号槽位对象的引用，用于解锁    <br>       22: aload_3    <br>       23: monitorexit //解锁<br>       24: goto          34<br>       //异常操作    <br>       27: astore        4<br>       29: aload_3<br>       30: monitorexit //解锁<br>       31: aload         4<br>       33: athrow<br>       34: return<br>     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      <br>     Exception table:<br>        from    to  target type<br>           15    24    27   any<br>           27    31    27   any<br></code></pre></td></tr></table></figure><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;<br>   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-keyword">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Integer x = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> y = x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-keyword">int</span> y = x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>);<br>      Integer x = list.get(<span class="hljs-number">0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">Code:<br>    stack=2, locals=3, args_size=1<br>       0: new           #2                  // class java/util/ArrayList<br>       3: dup<br>       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V<br>       7: astore_1<br>       8: aload_1<br>       9: bipush        10<br>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      //这里进行了泛型擦除，实际调用的是add(Objcet o)<br>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z<br><br>      19: pop<br>      20: aload_1<br>      21: iconst_0<br>      //这里也进行了泛型擦除，实际调用的是get(Object o)   <br>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<br>//这里进行了类型转换，将Object转换成了Integer<br>      27: checkcast     #7                  // class java/lang/Integer<br>      30: astore_2<br>      31: return<br></code></pre></td></tr></table></figure><p>所以调用get函数取值时，有一个类型转换的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;<br><br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;<br><span class="hljs-keyword">int</span> x = arr[i];<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果是集合使用foreach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         Integer x = iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译器中执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">//hello的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//world的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   <br>   <span class="hljs-comment">//对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>    MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> <br>   <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果匿名内部类中引用了<strong>局部变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化后代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">//多创建了一个变量</span><br>   <span class="hljs-keyword">int</span> val$x;<br>   <span class="hljs-comment">//变为了有参构造器</span><br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;<br>      <span class="hljs-keyword">this</span>.val$x = x;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(val$x);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span><br></code></pre></td></tr></table></figure><ul><li>打开HSDB</li></ul><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">java -cp F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>a-jdi.jar sun.jvm.hotspot.HSDB<br></code></pre></td></tr></table></figure><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>      ClassLoader loader = Demo1.class.getClassLoader();<br>      <span class="hljs-comment">//只加载不解析</span><br>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>   D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// to do something  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; <br><span class="hljs-comment">//这里调用了add2方法</span><br>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>方法调用被替换后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;  <br>    <span class="hljs-comment">//被替换为了方法本身</span><br>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-keyword">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="hljs-function">       InvocationTargetException</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    &#125;<br><br><span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;<br>            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());<br>            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>&#125;<br><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" alt="img"></a></p><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>内存模型内容详见 <a href="http://lihengxu.cn/2021/04/17/JUC/#%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98">JAVA并发 第四章</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC学习</title>
    <link href="/2021/04/17/JUC/"/>
    <url>/2021/04/17/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p><a href="https://www.bilibili.com/video/av81461839?from=search&seid=8445102345230304010"><strong>黑马java并发编程教程</strong></a>教学视频的笔记（转载<a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">nyimac</a>，再转一篇学习学习，补充了部分笔记，等看一遍《java并发编程的艺术》后，再整理自己的学习note吧）</p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><p><strong>进程切换和线程切换的主要区别</strong></p><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><p><strong>为什么TLB能加快访问速度</strong></p><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p><p>并行是多个CPU同时处理不同的线程。</p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</li><li>结论</li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><p>结论</p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Thread myThread = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-comment">// 启动线程</span><br>myThread.start();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;my thread running...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建线程任务</span><br>Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>&#125;<br>&#125;;<br><span class="hljs-comment">//将Runnable对象传给Thread</span><br>Thread t = <span class="hljs-keyword">new</span> Thread(r);<br><span class="hljs-comment">//启动线程</span><br>t.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread2</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;my runnable running...&quot;</span>);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();<br>      Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);<br>      thread.start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//创建线程任务</span><br>Runnable r = () -&gt; &#123;<br>            <span class="hljs-comment">//直接写方法体即可</span><br>System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Hello Thread&quot;</span>);<br>&#125;;<br><span class="hljs-comment">//将Runnable对象传给Thread</span><br>Thread t = <span class="hljs-keyword">new</span> Thread(r);<br><span class="hljs-comment">//启动线程</span><br>t.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以再Runnable上使用Alt+Enter</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" alt="img"></a></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//需要传入一个Callable对象</span><br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;线程执行!&quot;</span>);<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br>&#125;);<br><br>Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>r1.start();<br><span class="hljs-comment">//获取线程中方法执行后的返回结果</span><br>System.out.println(task.get());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>      FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCall());<br>      Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);<br>      thread.start();<br>      <span class="hljs-comment">// 获得线程运行后的返回值</span><br>      System.out.println(futureTask.get());<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h3 id="（常用）查看进程线程方法⭐"><a href="#（常用）查看进程线程方法⭐" class="headerlink" title="（常用）查看进程线程方法⭐"></a>（常用）查看进程线程方法⭐</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_1_20210417.png"></p><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<br><span class="hljs-comment">//等待thread线程执行结束</span><br>thread.join();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br>thread.join(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span><br>t1.isInterrupted();<br></code></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" alt="img"></a></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>Thread monitor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br><span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打断 park 线程（方法LockSupport.park()）, 不会清空打断状态，如果打断标记已经是 true, 则 park 会失效<ul><li>可以使用 Thread.interrupted() 清除打断状态</li></ul></li></ul><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将线程设置为守护线程, 默认为false</span><br>monitor.setDaemon(<span class="hljs-keyword">true</span>); <br></code></pre></td></tr></table></figure><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" alt="img"></a></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123; <br>    counter--; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br><span class="hljs-comment">//临界区</span><br>&#125; <br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <br><span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            <br>        <span class="hljs-keyword">synchronized</span> (room) &#123;     <br>        counter++;            <br>        &#125;       <br>    &#125;    <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;       <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;         <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;            <br>            counter--;          <br>            &#125;    <br>        &#125; <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br> <br>    t1.start();    <br>    t2.start(); <br>    t1.join();   <br>    t2.join();    <br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter); <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在成员方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">//在方法上加上synchronized关键字</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br><br>&#125;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>加在静态方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br><br>&#125;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li><p>局部变量是线程安全的</p></li><li><p>但局部变量引用的对象则未必 （要看该对象</p><p>是否被共享</p><p>且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li><li><p>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" alt="img"></a></p><ul><li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" alt="img"></a></p><ul><li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" alt="img"></a></p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer</li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" alt="img"></a></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" alt="img"></a></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li><p>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</p></li><li><p>如果</p><p>已经绑定</p><p>，则会去查询该Monitor是否已经有了Owner</p><ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" alt="img"></a></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" alt="img"></a></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" alt="img"></a></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" alt="img"></a></p><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" alt="img"></a></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为10(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" alt="img"></a></p></li></ul></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" alt="img"></a></p><ul><li>第二种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" alt="img"></a></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" alt="img"></a></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" alt="img"></a></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" alt="img"></a></p><ul><li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</p></li><li><p>处于BLOCKED和WAITING状态的线程都为</p><p>阻塞</p><p>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><br><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>LOCK.wait();<br>&#125;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span><br>LOCK.wait();<br>&#125;<br><span class="hljs-comment">//满足条件后再运行</span><br>&#125;<br><br><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br><span class="hljs-comment">//唤醒所有等待线程</span><br>LOCK.notifyAll();<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" alt="img"></a></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String hello = <span class="hljs-string">&quot;hello thread!&quot;</span>;<br>Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>System.out.println(<span class="hljs-string">&quot;想要得到结果&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (guarded) &#123;<br>System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+guarded.getResponse());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;得到结果&quot;</span>);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>System.out.println(<span class="hljs-string">&quot;设置结果&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (guarded) &#123;<br>guarded.setResponse(hello);<br>&#125;<br>&#125;).start();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要返回的结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//优雅地使用wait/notify</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span><br><span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.response = response;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">//唤醒休眠的线程</span><br><span class="hljs-keyword">this</span>.notifyAll();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Guarded&#123;&quot;</span> +<br><span class="hljs-string">&quot;response=&quot;</span> + response +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>带超时判断的暂停</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-comment">//获取开始时间</span><br><span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<br><span class="hljs-comment">//用于保存已经等待了的时间</span><br><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><br><span class="hljs-keyword">long</span> waitTime = time -passedTime;<br><span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-comment">//等待剩余时间</span><br><span class="hljs-keyword">this</span>.wait(waitTime);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//获取当前时间</span><br>passedTime = System.currentTimeMillis()-currentTime<br>            &#125;<br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> base = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-keyword">long</span> delay = millis - now;<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                wait(delay);<br>                now = System.currentTimeMillis() - base;<br>            &#125;<br>        &#125;<br>    &#125; <br></code></pre></td></tr></table></figure><h2 id="8、park-unpark"><a href="#8、park-unpark" class="headerlink" title="8、park/unpark"></a>8、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span><br>LockSupport.park;<br><br><span class="hljs-comment">//恢复线程运行</span><br>LockSupport.unpark(thread);Copy<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;park&quot;</span>);<br>            <span class="hljs-comment">//暂停线程运行</span><br>LockSupport.park();<br>System.out.println(<span class="hljs-string">&quot;resume&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>thread.start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">//恢复线程运行</span><br>LockSupport.unpark(thread);<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p><ul><li><p>先调用park再调用unpark时</p><ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的**_counter的值设为0**；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" alt="img"></a></p></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" alt="img"></a></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" alt="img"></a></p><h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" alt="img"></a></p><h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li></ul><h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li></ul></li></ul></li></ul><h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul><li><p>当前线程</p><p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul><h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li><p>当前线程调用 t.join</p><p>(long n</p><p>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li></ul><h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-comment">//额外创建对象来作为锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br><br>&#125;<br>&#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br><br>&#125;<br>&#125;<br>&#125;).start();<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p>jps+jstack ThreadID</p><ul><li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" alt="img"></a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">F:\Thread_study&gt;jps<br><span class="hljs-number">20672</span> RemoteMavenServer36<br><span class="hljs-number">22880</span> Jps<br><span class="hljs-number">4432</span> Launcher<br><span class="hljs-number">5316</span> Test5<br><span class="hljs-number">20184</span> KotlinCompileDaemon<br><span class="hljs-number">11132</span><br><br>F:\Thread_study&gt;jstack <span class="hljs-number">5316</span> <br></code></pre></td></tr></table></figure></li><li><p>打印的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//找到一个java级别的死锁</span><br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017f40de8</span> (object <span class="hljs-number">0x00000000d6188880</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017f43678</span> (object <span class="hljs-number">0x00000000d6188890</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;Thread-1&quot;</span> <br></code></pre></td></tr></table></figure></li><li><p>jconsole检测死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" alt="img"></a></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" alt="img"></a></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" alt="img"></a></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象</p><h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><br><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//加锁</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//需要执行的代码</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//释放锁</span><br>lock.unlock();<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//加锁，可打断锁</span><br>lock.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>                <span class="hljs-comment">//被打断，返回，不再向下执行</span><br><span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//释放锁</span><br>lock.unlock();<br>&#125;<br><br>&#125;);<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>t1.start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//打断</span><br>t1.interrupt();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-comment">//未设置等待时间，一旦获取失败，直接返回false</span><br><span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;<br>System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>                <span class="hljs-comment">//获取失败，不再向下执行，返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br>lock.unlock();<br>&#125;);<br><br><br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>t1.start();<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span><br><span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br><span class="hljs-comment">//获取失败，不再向下执行，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br><span class="hljs-comment">//被打断，不再向下执行，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br><span class="hljs-comment">//释放锁</span><br>lock.unlock();<br>&#125;);<br><br><br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>t1.start();<br><span class="hljs-comment">//打断等待</span><br>t1.interrupt();<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>); <br></code></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//获得条件变量</span><br>Condition condition = lock.newCondition();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">while</span>(!judge) &#123;<br>System.out.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);<br><span class="hljs-comment">//等待</span><br>condition.await();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);<br>lock.unlock();<br>&#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1</span>);<br>judge = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">//释放</span><br>condition.signal();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br><br>&#125;).start();<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>               setExclusiveOwnerThread(Thread.currentThread());<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">int</span> state = getState();<br>            compareAndSetState(state, state + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (getState() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>         &#125;<br><br>         <span class="hljs-keyword">int</span> state = getState();<br>         <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>            compareAndSetState(state, <span class="hljs-number">0</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            compareAndSetState(state, state - <span class="hljs-number">1</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> getState() &gt;= <span class="hljs-number">1</span>;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>      &#125;<br><br>   &#125;<br><br>   Sync sync = <span class="hljs-keyword">new</span> Sync();<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>      sync.acquire(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>      sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>      <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, time);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>      sync.release(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> sync.newCondition();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;<br>      MyLock lock = <span class="hljs-keyword">new</span> MyLock();<br><br>      Object syncLock = <span class="hljs-keyword">new</span> Object();<br><br>      Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>               lock.lock();<br>               <span class="hljs-keyword">try</span> &#123;<br>                  lock.lock();<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     num++;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     lock.unlock();<br>                  &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  lock.unlock();<br>               &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>            &#125;<br>         &#125;<br>      &#125;);<br><br>      Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>               lock.lock();<br>               <span class="hljs-keyword">try</span> &#123;<br>                  lock.lock();<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     num--;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     lock.unlock();<br>                  &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  lock.unlock();<br>               &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>            &#125;<br>         &#125;<br>      &#125;);<br><br>      t1.start();<br>      t2.start();<br>      t1.join();<br>      t2.join();<br><br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>   &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-comment">//判断先执行的内容是否执行完毕</span><br><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br><span class="hljs-keyword">while</span> (!judge) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>LOCK.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>judge = <span class="hljs-keyword">true</span>;<br>               <span class="hljs-comment">//执行完毕，唤醒所有等待线程</span><br>LOCK.notifyAll();<br>&#125;<br>&#125;).start();<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait/notify版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;<br><span class="hljs-keyword">static</span> Symbol symbol = <span class="hljs-keyword">new</span> Symbol();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>symbol.run(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>symbol.run(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>&#125;).start();<br>symbol.run(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><br>&#125;).start();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Symbol</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<br><span class="hljs-keyword">while</span>(flag != <span class="hljs-keyword">this</span>.flag) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>System.out.println(str);<br><span class="hljs-comment">//设置下一个运行的线程标记</span><br><span class="hljs-keyword">this</span>.flag = nextFlag;<br><span class="hljs-comment">//唤醒所有线程</span><br><span class="hljs-keyword">this</span>.notifyAll();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程的执行标记， 1-&gt;a 2-&gt;b 3-&gt;c</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFlag</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.flag = flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> loopNumber;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>await/signal版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<br><span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<br><span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<br><span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<br><span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>awaitSignal.run(<span class="hljs-string">&quot;a&quot;</span>, conditionA, conditionB);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>awaitSignal.run(<span class="hljs-string">&quot;b&quot;</span>, conditionB, conditionC);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>awaitSignal.run(<span class="hljs-string">&quot;c&quot;</span>, conditionC, conditionA);<br>&#125;).start();<br><br><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>awaitSignal.lock();<br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//唤醒一个等待的线程</span><br>conditionA.signal();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>awaitSignal.unlock();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, Condition thisCondition, Condition nextCondition)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<br>lock();<br><span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//全部进入等待状态</span><br>thisCondition.await();<br>System.out.print(str);<br>nextCondition.signal();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>unlock();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber=<span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> loopNumber;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalStudy</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 创建ThreadLocal变量</span><br>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>      ThreadLocal&lt;User&gt; userThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>      <span class="hljs-comment">// 创建两个线程，分别使用上面的两个ThreadLocal变量</span><br>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// stringThreadLocal第一次赋值</span><br>         stringThreadLocal.set(<span class="hljs-string">&quot;thread1 stringThreadLocal first&quot;</span>);<br>         <span class="hljs-comment">// stringThreadLocal第二次赋值</span><br>         stringThreadLocal.set(<span class="hljs-string">&quot;thread1 stringThreadLocal second&quot;</span>);<br>         <span class="hljs-comment">// userThreadLocal赋值</span><br>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-number">20</span>));<br><br>         <span class="hljs-comment">// 取值</span><br>         System.out.println(stringThreadLocal.get());<br>         System.out.println(userThreadLocal.get());<br>          <br>          <span class="hljs-comment">// 移除</span><br> userThreadLocal.remove();<br> System.out.println(userThreadLocal.get());<br>      &#125;);<br><br>      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// stringThreadLocal第一次赋值</span><br>         stringThreadLocal.set(<span class="hljs-string">&quot;thread2 stringThreadLocal first&quot;</span>);<br>         <span class="hljs-comment">// stringThreadLocal第二次赋值</span><br>         stringThreadLocal.set(<span class="hljs-string">&quot;thread2 stringThreadLocal second&quot;</span>);<br>         <span class="hljs-comment">// userThreadLocal赋值</span><br>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Hulu&quot;</span>, <span class="hljs-number">20</span>));<br><br>         <span class="hljs-comment">// 取值</span><br>         System.out.println(stringThreadLocal.get());<br>         System.out.println(userThreadLocal.get());<br>      &#125;);<br><br>      <span class="hljs-comment">// 启动线程</span><br>      thread1.start();<br>      thread2.start();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>   String name;<br>   <span class="hljs-keyword">int</span> age;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">thread1 stringThreadLocal second<br>thread2 stringThreadLocal second<br>User&#123;name=<span class="hljs-string">&#x27;Nyima&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>User&#123;name=<span class="hljs-string">&#x27;Hulu&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br><span class="hljs-keyword">null</span> <br></code></pre></td></tr></table></figure><p>从运行结果可以看出</p><ul><li>每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的<ul><li>从线程1和线程2的打印结果可以看出</li></ul></li><li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul><li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li></ul></li><li>ThreadLocal可以进行以下几个操作<ul><li>set 设置值</li><li>get 取出值</li><li>remove 移除值</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br> ...<br><br> ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br> <span class="hljs-comment">// 放在后面说</span><br> ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br><br> ...<br>&#125;Copy<br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125; <br></code></pre></td></tr></table></figure><p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p><h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    Thread t = Thread.currentThread();<br>    <br>    <span class="hljs-comment">// 获得ThreadLocalMap对象 </span><br>    <span class="hljs-comment">// 这里的get会返回Thread类中的threadLocals</span><br>    ThreadLocalMap map = getMap(t);<br>    <br>    <span class="hljs-comment">// 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// ThreadLocal自生的引用作为key，传入的值作为value</span><br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>如果未创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建的同时设置想放入的值</span><br>    <span class="hljs-comment">// hreadLocal自生的引用作为key，传入的值作为value</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>get方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    Thread t = Thread.currentThread();<br><span class="hljs-comment">// 获取当前线程的threadLocals变量</span><br>    ThreadLocalMap map = getMap(t);<br>    <br>    <span class="hljs-comment">// 判断threadLocals是否被初始化了</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 已经初始化则直接返回</span><br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 否则就创建threadLocals</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这个方法返回是null</span><br>    T value = initialValue();<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <br>    <span class="hljs-comment">// 无论map创建与否，最终value的值都为null</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>remove方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 如果threadLocals已经被初始化，则移除</span><br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p><p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p><h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span><br></code></pre></td></tr></table></figure><p>所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，<strong>它能够让父线程中ThreadLocal的值传给子线程。</strong></p><p>也就是从main所在的线程，传给thread1或thread2</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>      InheritableThreadLocal&lt;String&gt; stringInheritable = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();<br><br>      <span class="hljs-comment">// 主线程赋对上面两个变量进行赋值</span><br>      stringThreadLocal.set(<span class="hljs-string">&quot;this is threadLocal&quot;</span>);<br>      stringInheritable.set(<span class="hljs-string">&quot;this is inheritableThreadLocal&quot;</span>);<br><br>      <span class="hljs-comment">// 创建线程</span><br>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// 获得ThreadLocal中存放的值</span><br>         System.out.println(stringThreadLocal.get());<br><br>         <span class="hljs-comment">// 获得InheritableThreadLocal存放的值</span><br>         System.out.println(stringInheritable.get());<br>      &#125;);<br><br>      thread1.start();<br>   &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">null</span><br><span class="hljs-keyword">this</span> is inheritableThreadLocal <br></code></pre></td></tr></table></figure><p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 传入父线程中的一个值，然后直接返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">childValue</span><span class="hljs-params">(T parentValue)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> parentValue;<br>    &#125;<br><br>  <span class="hljs-comment">// 返回传入线程的inheritableThreadLocals</span><br>    <span class="hljs-comment">// Thread中有一个inheritableThreadLocals变量</span><br>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br>    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>    &#125;<br><br> <span class="hljs-comment">// 创建一个inheritableThreadLocals</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p><h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;<br>    init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;<br>   ...<br>        <br><span class="hljs-comment">// 获得当前线程的，在这里是主线程</span><br>    Thread parent = currentThread();<br>   <br>    ...<br>    <br>    <span class="hljs-comment">// 如果父线程的inheritableThreadLocals存在</span><br>    <span class="hljs-comment">// 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 设置子线程的inheritableThreadLocals</span><br>        <span class="hljs-keyword">this</span>.inheritableThreadLocals =<br>            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>    <br>    <span class="hljs-comment">/* Stash the specified stack size in case the VM cares */</span><br>    <span class="hljs-keyword">this</span>.stackSize = stackSize;<br><br>    <span class="hljs-comment">/* Set thread ID */</span><br>    tid = nextThreadID();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadLocalMap(parentMap);<br>&#125; <br></code></pre></td></tr></table></figure><p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;<br>    Entry[] parentTable = parentMap.table;<br>    <span class="hljs-keyword">int</span> len = parentTable.length;<br>    setThreshold(len);<br>    table = <span class="hljs-keyword">new</span> Entry[len];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = parentTable[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 这里调用了 childValue 方法</span><br>                <span class="hljs-comment">// 该方法会返回parent的值</span><br>                Object value = key.childValue(e.value);<br>                <br>                Entry c = <span class="hljs-keyword">new</span> Entry(key, value);<br>                <span class="hljs-keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-keyword">null</span>)<br>                    h = nextIndex(h, len);<br>                table[h] = c;<br>                size++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p><p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">//如果run为真，则一直执行</span><br>&#125;<br>&#125;).start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>run = <span class="hljs-keyword">false</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" alt="img"></a></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" alt="img"></a></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" alt="img"></a></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用易变关键字</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">//如果run为真，则一直执行</span><br>&#125;<br>&#125;).start();<br><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>run = <span class="hljs-keyword">false</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li><p>因为使用了<strong>synchronized</strong>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<br><span class="hljs-comment">//使用了synchronized关键字</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            print(x);<br>            newLine();<br>        &#125;<br>    &#125; <br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>Thread monitor;<br><span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(stop) &#123;<br>System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>        <span class="hljs-comment">//修改标记</span><br>stop = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong></p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.nyima.day1;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/3/26 16:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>Thread monitor;<br><span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">if</span> (starting) &#123;<br><span class="hljs-comment">//已被启动，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//启动监视器，改变标记</span><br>starting = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(stop) &#123;<br>System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>stop = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" alt="img"></a></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" alt="img"></a></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; <br>System.out.println( a + b );<br><br><span class="hljs-comment">// 不能重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>; <br></code></pre></td></tr></table></figure></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" alt="img"></a></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul><li>可见性<ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中</li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" alt="img"></a></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" alt="img"></a></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" alt="img"></a></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" alt="img"></a></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">instance = <span class="hljs-keyword">new</span> Singleton(); <br></code></pre></td></tr></table></figure><p>对应的汇编代码是</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span> lock addl <span class="hljs-string">...</span> <br></code></pre></td></tr></table></figure><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p><ul><li><p>Lock前缀指令会引起处理器</p><p>缓存回写到内存</p><ul><li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li></ul></li><li><p>一个处理器的缓存回写到内存会</p><p>导致其他处理器的缓存无效</p><ul><li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li></ul></li></ul><h3 id="补充：单例模式线程安全的一些问题"><a href="#补充：单例模式线程安全的一些问题" class="headerlink" title="补充：单例模式线程安全的一些问题"></a>补充：单例模式线程安全的一些问题</h3><ul><li><p>饿汉</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_2_20210420.png"></p><ul><li>问题一：final可以防止子类不适当的方法破坏单例</li><li>问题二：（见上图）在反序列化中，会把readResolve方法中的对象作为反序列化结果，保证反序列化后依然是同一个对象。</li><li>问题三：私有防止别人调用构造方法</li><li>问题四：能保证，类加载阶段完成初始化，jvm保证线程安全</li><li>问题五：<ul><li>方法提供了更好的封装性，可以内部实现懒惰初始化</li><li>可以对创建对象做更多的控制 </li><li>可以提供泛型的支持</li></ul></li></ul></li><li><p>枚举</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_3_20210420.png"></p><ul><li>问题一：枚举中定义的对象相当于枚举类的静态成员变量，定义时有几个，后面就有几个对象</li><li>问题二：静态成员变量，类加载阶段完成初始化，jvm保证线程安全</li><li>问题三：不能</li><li>问题四：可以避免反序列破坏单例</li><li>问题五：饿汉式</li><li>问题六：加一个构造方法，写入一些初始化逻辑</li></ul></li><li><p>懒汉</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_4_20210420.png"></p><ul><li>问题：是线程安全的，但是锁的范围过大，每次都加锁</li></ul></li><li><p>懒汉改进</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_5_20210420.png"></p><ul><li>问题一：防止synchronized内发生指令重排序，具体就是保证INSTANCE = new Singlenton( )；不会和前面的指令发生重排序（写屏障实现）。</li><li>问题二：缩小了同步代码块的范围，只有第一次上锁（双重检查）</li><li>问题三：防止首次创建的并发问题（首次多个线程都通过了第一个if）</li></ul></li><li><p>静态内部类实现</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_6_20210420.png"></p><ul><li>问题一：懒汉</li><li>问题二：没有，调用getInstance方法触发内部类的类加载完成初始化，jvm保证线程安全</li></ul></li></ul><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul><li>使用<strong>原子整数</strong></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AtomicInteger balance</span> = new AtomicInteger();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">long</span> start = System.nanoTime();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>account.withdraw(<span class="hljs-number">10</span>);<br>&#125;));<br>&#125;<br>ts.forEach(Thread::start);<br>ts.forEach(t -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//线程不安全的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-keyword">private</span> Integer balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = balance;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>balance -= amount;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));<br>Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//线程安全的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-comment">//使用原子整数</span><br><span class="hljs-keyword">private</span> AtomicInteger balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//得到原子整数的值</span><br><span class="hljs-keyword">return</span> balance.get();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">//获得修改前的值</span><br><span class="hljs-keyword">int</span> prev = balance.get();<br><span class="hljs-comment">//获得修改后的值</span><br><span class="hljs-keyword">int</span> next = prev-amount;<br><span class="hljs-comment">//比较并设值</span><br><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" alt="img"></a></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><p><strong>注意</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性） <br></code></pre></td></tr></table></figure><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" alt="img"></a></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p></li><li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p></li><li><p>CAS 体现的是</p><p>无锁并发、无阻塞并发</p><p>，请仔细体会这两句话的意思</p><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br> <br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span><br> <br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span><br> <br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span><br> <br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br> <br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br> <br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br> <br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br> <br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br> <br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><br><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br> <br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x)); <br></code></pre></td></tr></table></figure><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">long</span> start = System.nanoTime();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>account.withdraw(BigDecimal.TEN);<br>&#125;));<br>&#125;<br>ts.forEach(Thread::start);<br>ts.forEach(t -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><span class="hljs-comment">//原子引用，泛型类型为小数类型</span><br>AtomicReference&lt;BigDecimal&gt; balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance.get();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>BigDecimal pre = balance.get();<br>BigDecimal next = pre.subtract(amount);<br><span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.get();<br>System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C</span><br>System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));<br>&#125;).start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));<br>&#125;).start();<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" alt="img"></a></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br><span class="hljs-comment">//指定版本号</span><br><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.getReference();<br><span class="hljs-comment">//获得版本号</span><br><span class="hljs-keyword">int</span> stamp = str.getStamp();<br>System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br><span class="hljs-keyword">int</span> stamp = str.getStamp();<br>System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>&#125;).start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br><span class="hljs-keyword">int</span> stamp = str.getStamp();<br>System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));<br>&#125;).start();<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" alt="img"></a></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><span class="hljs-comment">//指定版本号</span><br><span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.getReference();<br>System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" alt="img"></a></p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li></ul><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul><li>提供者<ul><li>无参又返回</li><li>()-&gt;返回结果</li></ul></li><li>方法<ul><li>有参有返回</li><li>(参数一…)-&gt;返回结果</li></ul></li><li>消费者<ul><li>有参无返回</li><li>(参数一…)-&gt;void</li></ul></li></ul><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdate</li></ul><p>原子更新器用于帮助我们改变某个对象中的某个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Student student = <span class="hljs-keyword">new</span> Student();<br>       <br>      <span class="hljs-comment">// 获得原子更新器</span><br>      <span class="hljs-comment">// 泛型</span><br>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span><br>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span><br>      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>       <br>      <span class="hljs-comment">// 修改</span><br>      updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>      System.out.println(student);<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>   <span class="hljs-keyword">volatile</span> String name;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p><ul><li>拥有属性的类的Class</li><li>属性的Class</li><li>属性的名称</li></ul><p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p><h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; <span class="hljs-function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-title">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                Class&lt;W&gt; vclass,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                String fieldName)</span> </span>&#123;<br>    <span class="hljs-comment">// 返回了一个AtomicReferenceFieldUpdaterImpl实例</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;<br>        (tclass, vclass, fieldName, Reflection.getCallerClass());<br>&#125;<br></code></pre></td></tr></table></figure><p>从newUpdater方法还并不能看出来具体的初始化过程</p><h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png" alt="img"></a></p><p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceFieldUpdaterImpl</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReferenceFieldUpdater</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png" alt="img"></a></p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicReferenceFieldUpdaterImpl(<span class="hljs-keyword">final</span> Class&lt;T&gt; tclass,<br>                                <span class="hljs-keyword">final</span> Class&lt;V&gt; vclass,<br>                                <span class="hljs-keyword">final</span> String fieldName,<br>                                <span class="hljs-keyword">final</span> Class&lt;?&gt; caller) &#123;<br>    <span class="hljs-comment">// 用于保存要被修改的属性</span><br>    <span class="hljs-keyword">final</span> Field field;<br>    <br>    <span class="hljs-comment">// 属性的Class</span><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt; fieldClass;<br>    <br>    <span class="hljs-comment">// field的修饰符</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> modifiers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 反射获得属性</span><br>        field = AccessController.doPrivileged(<br>            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br>                    <span class="hljs-comment">// tclass为传入的属性的Class，可以通过它来获得属性</span><br>                    <span class="hljs-keyword">return</span> tclass.getDeclaredField(fieldName);<br>                &#125;<br>            &#125;);<br>        <br>        <span class="hljs-comment">// 获得属性的修饰符，主要用于判断</span><br>        <span class="hljs-comment">// 1、vclass 与 属性确切的类型是否匹配</span><br>        <span class="hljs-comment">// 2、是否为引用类型</span><br>        <span class="hljs-comment">// 3、被修改的属性是否加了volatile关键字</span><br>        modifiers = field.getModifiers();<br>        sun.reflect.misc.ReflectUtil.ensureMemberAccess(<br>            caller, tclass, <span class="hljs-keyword">null</span>, modifiers);<br>        ClassLoader cl = tclass.getClassLoader();<br>        ClassLoader ccl = caller.getClassLoader();<br>        <span class="hljs-keyword">if</span> ((ccl != <span class="hljs-keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;<br>            ((cl == <span class="hljs-keyword">null</span>) || !isAncestor(cl, ccl))) &#123;<br>            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获得属性类的Class</span><br>        fieldClass = field.getType();<br>    &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(pae.getException());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (vclass != fieldClass)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException();<br>    <span class="hljs-keyword">if</span> (vclass.isPrimitive())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be reference type&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!Modifier.isVolatile(modifiers))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be volatile type&quot;</span>);<br><br>    <span class="hljs-comment">// Access to protected field members is restricted to receivers only</span><br>    <span class="hljs-comment">// of the accessing class, or one of its subclasses, and the</span><br>    <span class="hljs-comment">// accessing class must in turn be a subclass (or package sibling)</span><br>    <span class="hljs-comment">// of the protected member&#x27;s defining class.</span><br>    <span class="hljs-comment">// If the updater refers to a protected field of a declaring class</span><br>    <span class="hljs-comment">// outside the current package, the receiver argument will be</span><br>    <span class="hljs-comment">// narrowed to the type of the accessing class.</span><br> <span class="hljs-comment">// 对类中的属性进行初始化</span><br>    <span class="hljs-keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;<br>                   tclass.isAssignableFrom(caller) &amp;&amp;<br>                   !isSamePackage(tclass, caller))<br>                  ? caller : tclass;<br>    <span class="hljs-keyword">this</span>.tclass = tclass;<br>    <span class="hljs-keyword">this</span>.vclass = vclass;<br>    <span class="hljs-comment">// 获得偏移量</span><br>    <span class="hljs-keyword">this</span>.offset = U.objectFieldOffset(field);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以看出，原子引用更新器确实使用了反射</strong></p><h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="累加器性能比较"><a href="#累加器性能比较" class="headerlink" title="累加器性能比较"></a>累加器性能比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;<br>    T adder = adderSupplier.get();<br>    <span class="hljs-keyword">long</span> start = System.nanoTime();<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>        ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>            action.accept(adder);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start());<br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        &#125;);<br>    <span class="hljs-keyword">long</span> end = System.nanoTime();<br>    System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>比较AtomicLong 与 LongAdder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>demo(() -&gt; <span class="hljs-keyword">new</span> LongAdder(), adder -&gt; adder.increment());<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>demo(() -&gt; <span class="hljs-keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">43</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">9</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">7</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">7</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">7</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">31</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">27</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">28</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">24</span><br><span class="hljs-symbol">1000000 </span>cost:<span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h3 id="源码之LongAdder"><a href="#源码之LongAdder" class="headerlink" title="源码之LongAdder"></a>源码之LongAdder</h3><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧<br>LongAdder 类有几个关键域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br><br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p>cas锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不要用于实践！！！</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockCas</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger state = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;unlock...&quot;</span>);<br>        state.set(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" alt="img"></a></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" alt="img"></a></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" alt="img"></a></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" alt="img"></a></p><p><strong>累加主要调用以下方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// as 为累加单元数组</span><br><span class="hljs-comment">// b 为基础值</span><br><span class="hljs-comment">// x 为累加值</span><br>    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;<br>    <br>    <span class="hljs-comment">// 进入 if 的两个条件</span><br>    <span class="hljs-comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span><br>    <span class="hljs-comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-comment">// uncontended 表示 cell 没有竞争</span><br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// as 还没有创建</span><br>            as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// 当前线程对应的 cell 还没有</span><br>            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>            <span class="hljs-comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span><br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            <br>            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>累加流程图</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" alt="img"></a></p><p><strong>longAccumulate方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn, <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 初始化 probe</span><br>        ThreadLocalRandom.current();<br>        <span class="hljs-comment">// h 对应新的 probe 值, 用来对应 cell</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// collide 为 true 表示需要扩容</span><br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">// 已经有了 cells</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 还没有 cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span><br>        <span class="hljs-comment">// 成功则 break, 否则继续 continue 循环</span><br>    &#125;<br>            <br>            <span class="hljs-comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)<br>                wasUncontended = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;<br><br>            <span class="hljs-comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-comment">// 加锁成功, 扩容</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 改变线程对应的 cell</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span><br>            <span class="hljs-comment">// 成功则 break;</span><br>        &#125;<br><br>        <span class="hljs-comment">// 上两种情况失败, 尝试给 base 累加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>longAccumulate 流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_7_20210502.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_8_20210502.png"></p><p><strong>每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_9_20210502.png"></p><p><strong>获取最终结果通过 sum 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-keyword">long</span> sum = base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>            sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;<br><span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>Class unsafeClass = Unsafe.class;<br><span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>Constructor constructor = unsafeClass.getDeclaredConstructor();<br><span class="hljs-comment">// 设置为允许访问私有内容</span><br>constructor.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 创建Unsafe对象</span><br>Unsafe unsafe = (Unsafe) constructor.newInstance();<br><br><span class="hljs-comment">// 创建Person对象</span><br>Person person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>Field field = Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">long</span> offset = unsafe.objectFieldOffset(field);<br><br><span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>unsafe.compareAndSwapObject(person, offset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>System.out.println(person);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br> <span class="hljs-keyword">volatile</span> String name;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br><span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h2 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h2><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><p><strong>例如</strong></p><p>SimpleDateFormat 不是线程安全的，在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        LocalDate date = dtf.parse(<span class="hljs-string">&quot;2018-10-01&quot;</span>, LocalDate::from);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看 DateTimeFormatter 的文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@implSpec</span><br>This <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">is</span> <span class="hljs-title">immutable</span> <span class="hljs-title">and</span> <span class="hljs-title">thread</span>-<span class="hljs-title">safe</span>.</span><br></code></pre></td></tr></table></figure><p>不可变对象，实际是另一种避免竞争的方式。</p><h2 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h2><h3 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>   <span class="hljs-comment">//....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ﬁnal-的使用"><a href="#ﬁnal-的使用" class="headerlink" title="ﬁnal 的使用"></a>ﬁnal 的使用</h3><p>发现该类、类中所有属性都是<strong>ﬁnal</strong>的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改</li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>        &#125;<br>        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;<br>        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>        &#125;<br>    <span class="hljs-comment">//返回的是一个新的对象</span><br>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>    &#125;<br></code></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>    &#125;<br></code></pre></td></tr></table></figure><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p><h2 id="3、享元模式"><a href="#3、享元模式" class="headerlink" title="3、享元模式"></a>3、享元模式</h2><p>由于不可变类的保护性拷贝会频繁的创建对象，因此我们可以提前创建一些常用的不可变对象作为缓存，这里涉及到享元模式的思想</p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>定义</strong> 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时</p><blockquote><p>wikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as</p><p>possible with other similar objects</p></blockquote><p><strong>出自</strong> “Gang of Four” design patterns</p><p><strong>归类</strong> Structual patterns</p><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><ul><li><p>包装类</p><ul><li><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的<br>valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对<br>象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>    <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Long(l);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>Byte, Short, Long 缓存的范围都是 -128~127</p></li><li><p>Character 缓存的范围是 0~127</p></li><li><p>Integer的默认范围是 -128~127</p><p>最小值不能变</p><p>但最大值可以通过调整虚拟机参数 <code> -Djava.lang.Integer.IntegerCache.high</code> 来改变</p></li><li><p>Boolean 缓存了 TRUE 和 FALSE</p></li></ul></blockquote></li></ul></li><li><p>String 串池（正因为串池有缓存的作用，一般不要使用String对象作为锁对象）</p></li><li><p>BigDecimal BigInteger</p><ul><li>注意虽然不可变类单个方法可以保证线程安全，但是方法组合依然是线程不安全的，因此在前面使用了原子引用类对BigDecimal进行了改进，实现CAS交换保证原子性（因为这个操作包括了读取，操作和赋值，三个操作，CAS才能保证原子性）</li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>通过享元模式思想实现数据库连接池（该实现仿照了tomcat的池实现，其他方式可以参考其他第三方数据库连接池的实现源码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.poolSize = poolSize;<br>        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br>        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>       connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-keyword">this</span>.notifyAll();<br>                &#125;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;<br><span class="hljs-comment">// 实现略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        Connection conn = pool.borrow();<br>        <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>        pool.free(conn);<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理（可以参考《java并发编程的艺术》第4章 等待超时模式 数据库连接池示例应用）</li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><h2 id="4、final原理"><a href="#4、final原理" class="headerlink" title="4、final原理"></a>4、final原理</h2><h3 id="设置-final-变量的原理（final域的内存语义）"><a href="#设置-final-变量的原理（final域的内存语义）" class="headerlink" title="设置 final 变量的原理（final域的内存语义）"></a>设置 final 变量的原理（final域的内存语义）</h3><p>理解了 volatile 原理，再对比 final 的实现就比较简单了，详细参考《java并发编程的艺术》3.6 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0<br>1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br><span class="hljs-number">4</span>: aload_0<br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><br>7: putfield #2 // Field a:I<br>&lt;-- 写屏障<br><span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到<br>它的值时不会出现为 0 的情况</p><h3 id="获取-final-变量的原理"><a href="#获取-final-变量的原理" class="headerlink" title="获取 final 变量的原理"></a>获取 final 变量的原理</h3><p>final可优化静态成员变量的共享，实现读取优化</p><ul><li>使用final修饰的静态成员变量，访问时可以直接访问复制到栈内存的拷贝（效率高），而不是访问静态成员变量的共享内存（堆）</li><li>静态成员变量超过了short的最大值，则会放在常量池（堆）中，使用final修饰同样可以实现访问复制到栈内存的拷贝（效率高）</li></ul><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png" alt="img"></a></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li><li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li><li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,  TimeUnit.SECONDS, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>         threadPool.execute(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               TimeUnit.SECONDS.sleep(<span class="hljs-number">10000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;任务正在执行!&quot;</span>);<br>         &#125;);<br>      &#125;<br>   &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义线程池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 自定义阻塞队列</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 核心线程数</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;<br><br>   <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用于指定线程最大存活时间</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 工作线程类</span><br><span class="hljs-comment">    * 内部封装了Thread类，并且添加了一些属性</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>      Runnable task;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;初始化任务&quot;</span>);<br>         <span class="hljs-keyword">this</span>.task = task;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-comment">// 如果有任务就执行</span><br>         <span class="hljs-comment">// 如果阻塞队列中有任务，就继续执行</span><br>         <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = blockingQueue.take()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span>);<br>               task.run();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               <span class="hljs-comment">// 任务执行完毕，设为空</span><br>               System.out.println(<span class="hljs-string">&quot;任务执行完毕&quot;</span>);<br>               task = <span class="hljs-keyword">null</span>;<br>            &#125;<br>         &#125;<br>         <span class="hljs-comment">// 移除任务</span><br>         <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            System.out.println(<span class="hljs-string">&quot;移除任务&quot;</span>);<br>            workers.remove(<span class="hljs-keyword">this</span>);<br>         &#125;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, TimeUnit timeUnit, <span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.coreSize = coreSize;<br>      <span class="hljs-keyword">this</span>.timeUnit = timeUnit;<br>      blockingQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(capacity);<br>      <span class="hljs-keyword">this</span>.timeout = timeout;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>      <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>         <span class="hljs-comment">// 创建任务</span><br>         <span class="hljs-comment">// 池中还有空余线程时，可以运行任务</span><br>         <span class="hljs-comment">// 否则阻塞</span><br>         <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>            Worker worker = <span class="hljs-keyword">new</span> Worker(task);<br>            workers.add(worker);<br>            worker.start();<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程池中线程已用完，请稍等&quot;</span>);<br>            blockingQueue.put(task);<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阻塞队列</span><br><span class="hljs-comment"> * 用于存放主线程或其他线程产生的任务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 阻塞队列</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span>  Deque&lt;T&gt; blockingQueue;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 阻塞队列容量</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 锁</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> ReentrantLock lock;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 条件队列</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Condition fullQueue;<br>   <span class="hljs-keyword">private</span> Condition emptyQueue;<br><br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>      blockingQueue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(capacity);<br>      lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>      fullQueue = lock.newCondition();<br>      emptyQueue = lock.newCondition();<br>      <span class="hljs-keyword">this</span>.capacity = capacity;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取任务的方法</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// 加锁</span><br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// 如果阻塞队列为空（没有任务），就一直等待</span><br>         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               emptyQueue.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>         <span class="hljs-comment">// 获取任务并唤醒生产者线程</span><br>         T task = blockingQueue.removeFirst();<br>         fullQueue.signalAll();<br>         <span class="hljs-keyword">return</span> task;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">takeNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;<br>      <span class="hljs-comment">// 转换等待时间</span><br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">// awaitNanos会返回剩下的等待时间</span><br>               nanos = emptyQueue.awaitNanos(nanos);<br>               <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>               &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>         T task = blockingQueue.removeFirst();<br>         fullQueue.signalAll();<br>         <span class="hljs-keyword">return</span> task;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 放入任务的方法</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> task 放入阻塞队列的任务</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;<br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (blockingQueue.size() == capacity) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;阻塞队列已满&quot;</span>);<br>               fullQueue.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>            &#125;<br>         &#125;<br>         blockingQueue.add(task);<br>         <span class="hljs-comment">// 唤醒等待的消费者</span><br>         emptyQueue.signalAll();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">return</span> blockingQueue.size();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了一个简单的线程池</p><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png" alt="img"></a></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// RUNNING 高3位为111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// SHUTDOWN 高3位为000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 010</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 011</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 并不是所有平台的int都是32位。</span><br><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="hljs-comment">// CAPACITY 的高3位为 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>获取线程池状态、线程数量以及合并两个值的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-comment">// 获取运行状态</span><br><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><br><span class="hljs-comment">// 获取运行线程数</span><br><span class="hljs-comment">// 该操作会让高3位为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br><span class="hljs-comment">// 计算ctl新值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-comment">// 锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();<br></code></pre></td></tr></table></figure><h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p><p>也是构造自定义线程池的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize = 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li>阻塞队列满了，使用救急线程来执行任务<ul><li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ul></li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png" alt="img"></a></p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-keyword">static</span> AtomicInteger threadId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 手动创建线程池</span><br>      <span class="hljs-comment">// 创建有界阻塞队列</span><br>      ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">10</span>);<br>      <span class="hljs-comment">// 创建线程工厂</span><br>      ThreadFactory threadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;working_thread_&quot;</span>+threadId.getAndIncrement());<br>            <span class="hljs-keyword">return</span> thread;<br>         &#125;<br>      &#125;;<br><br>      <span class="hljs-comment">// 手动创建线程池</span><br>      <span class="hljs-comment">// 拒绝策略采用默认策略</span><br>      ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>         executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               System.out.println(Thread.currentThread());<br>               <span class="hljs-keyword">try</span> &#123;<br>                  Thread.sleep(<span class="hljs-number">100000</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>               &#125;<br>            &#125;<br>         &#125;);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFixedThreadPool</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 自定义线程工厂</span><br>      ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>         AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;myThread_&quot;</span> + atomicInteger.getAndIncrement());<br>         &#125;<br>      &#125;;<br><br>      <span class="hljs-comment">// 创建核心线程数量为2的线程池</span><br>      <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span><br><br>      ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>, factory);<br><br>      <span class="hljs-comment">// 任务</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            System.out.println(<span class="hljs-string">&quot;this is fixedThreadPool&quot;</span>);<br>         &#125;<br>      &#125;;<br>      <br>      executorService.execute(runnable);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>固定大小的线程池可以传入两个参数</p><ul><li>核心线程数：nThreads</li><li>线程工厂：threadFactory</li></ul><p>内部调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(nThreads, nThreads,<br>                              <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                              <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                              threadFactory);<br></code></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService executorService = Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p><strong>内部构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br></code></pre></td></tr></table></figure><ul><li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p></li><li><p>阻塞队列使用的是SynchronousQueue</p><ul><li><p>SynchronousQueue</p><p>是一种特殊的队列</p><ul><li><strong>没有容量</strong>，没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li></ul></li></ul><h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService service = Executors.newSingleThreadExecutor();<br></code></pre></td></tr></table></figure><p><strong>内部构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>    (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                            <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                            <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br></code></pre></td></tr></table></figure><p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p><h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul><li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p><ul><li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li></ul></li><li><p>SingleThread和newFixedThreadPool(1)的区别</p><ul><li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span><br>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 改变核心线程数</span><br>threadPool.setCorePoolSize(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><ul><li>而SingleThread无法修改核心线程数</li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execute(Runnable command)<br></code></pre></td></tr></table></figure><p>传入一个Runnable对象，执行其中的run方法</p><p><strong>源码解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>    <span class="hljs-comment">// 获取ctl</span><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <br>    <span class="hljs-comment">// 判断当前启用的线程数是否小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">// 为该任务分配线程</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-comment">// 分配成功就返回</span><br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 分配失败再次获取ctl</span><br>        c = ctl.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分配和信息线程失败以后</span><br>    <span class="hljs-comment">// 如果池状态为RUNNING并且插入到任务队列成功</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <br>        <span class="hljs-comment">// 双重检测，可能在添加后线程池状态变为了非RUNNING</span><br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <br>        <span class="hljs-comment">// 如果池状态为非RUNNING，则不会执行新来的任务</span><br>        <span class="hljs-comment">// 将该任务从阻塞队列中移除</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            <span class="hljs-comment">// 调用拒绝策略，拒绝该任务的执行</span><br>            reject(command);<br>        <br>        <span class="hljs-comment">// 如果没有正在运行的线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 就创建新线程来执行该任务</span><br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果添加失败了（任务队列已满），就调用拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中调用了**addWoker()**方法，再看看看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">// 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-comment">// 创建新线程失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获得当前工作线程数</span><br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>            <span class="hljs-comment">// 参数中 core 为true</span><br>            <span class="hljs-comment">// CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span><br>            <span class="hljs-comment">// 如果工作线程数大于了核心线程数，则创建失败</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 通过CAS操作改变c的值</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-comment">// 更改成功就跳出多重循环，且不再运行循环</span><br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 更改失败，重新获取ctl的值</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 跳出多重循环，且重新进入循环</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 用于标记work中的任务是否成功执行</span><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 用于标记worker是否成功加入了线程池中</span><br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建新线程来执行任务</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            <span class="hljs-comment">// 加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-comment">// 加锁的同时再次检测</span><br>                <span class="hljs-comment">// 避免在释放锁之前调用了shut down</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">// 将线程添加到线程池中</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    <span class="hljs-comment">// 添加成功标志位变为true</span><br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 如果worker成功加入了线程池，就执行其中的任务</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                <span class="hljs-comment">// 启动成功</span><br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果执行失败</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">// 调用添加失败的函数</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span><br></code></pre></td></tr></table></figure><p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><br><span class="hljs-comment">// 通过Future来捕获返回值</span><br>Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello submit&quot;</span>;<br>   &#125;<br>&#125;);<br><br><span class="hljs-comment">// 查看捕获的返回值</span><br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将线程池的状态改为 SHUTDOWN</span><br><span class="hljs-comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <br>        <span class="hljs-comment">// 修改线程池状态为 SHUTDOWN</span><br>        advanceRunState(SHUTDOWN);<br>        <br>  <span class="hljs-comment">// 中断空闲线程（没有执行任务的线程）</span><br>        <span class="hljs-comment">// Idle：空闲的</span><br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结，不一定成功</span><br>    <span class="hljs-comment">// </span><br>    tryTerminate();<br>&#125;Copy<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">// 终结失败的条件</span><br>        <span class="hljs-comment">// 线程池状态为RUNNING</span><br>        <span class="hljs-comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span><br>        <span class="hljs-comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 如果活跃线程数不为0</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            <span class="hljs-comment">// 中断空闲线程</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处于可以终结的状态</span><br>            <span class="hljs-comment">// 通过CAS将线程池状态改为TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 通过CAS将线程池状态改为TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将线程池的状态改为 STOP</span><br><span class="hljs-comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><br><span class="hljs-comment">* 会将阻塞队列中未执行的任务返回给调用者</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <br>        <span class="hljs-comment">// 修改状态为STOP，不执行任何任务</span><br>        advanceRunState(STOP);<br>        <br>        <span class="hljs-comment">// 中断所有线程</span><br>        interruptWorkers();<br>        <br>        <span class="hljs-comment">// 将未执行的任务从队列中移除，然后返回给调用者</span><br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span><br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC并发标记的问题</title>
    <link href="/2021/04/11/GC%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/11/GC%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="GC并发标记的问题"><a href="#GC并发标记的问题" class="headerlink" title="GC并发标记的问题"></a>GC并发标记的问题</h1><p>在最开始学习垃圾回收器并发标记的问题时，理解的不够到位，这里结合马士兵的讲解记录一下(马士兵喜欢讲一半，故弄玄虚😒)</p><h2 id="1-垃圾回收器（10种）"><a href="#1-垃圾回收器（10种）" class="headerlink" title="1.垃圾回收器（10种）"></a>1.垃圾回收器（10种）</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_1_20210411.png"></p><p>java 1.8默认Parallel Scavenge + Parallel Old</p><p>垃圾回收器分为</p><ul><li>分代模型（左6）</li><li>不分代模型（右3）</li></ul><h2 id="2-判断对象能否回收"><a href="#2-判断对象能否回收" class="headerlink" title="2. 判断对象能否回收"></a>2. 判断对象能否回收</h2><h3 id="2-1-引用计数"><a href="#2-1-引用计数" class="headerlink" title="2.1 引用计数"></a>2.1 引用计数</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_3_20210411.png"></p><p>循环引用对象无法回收，导致内存泄露</p><h3 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_2_20210411.png"></p><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h2 id="3-并发标记的问题"><a href="#3-并发标记的问题" class="headerlink" title="3. 并发标记的问题"></a>3. 并发标记的问题</h2><h3 id="3-1-两种情况"><a href="#3-1-两种情况" class="headerlink" title="3.1 两种情况"></a>3.1 两种情况</h3><ul><li>一个对象被GC认为不是垃圾，但是随着业务进行，变成垃圾<ul><li>浮动垃圾 floating garbage</li><li>解决方法：下一次GC清除</li></ul></li><li>一个对象被GC认为是垃圾，随着业务进行，变成不是垃圾<ul><li>缓存</li></ul></li></ul><h3 id="3-2-三色标记法"><a href="#3-2-三色标记法" class="headerlink" title="3.2 三色标记法"></a>3.2 三色标记法</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_4_20210411.png"></p><p>CMS和G1都是用的三色标记法（基于可达性分析）</p><h3 id="3-3-解决方法"><a href="#3-3-解决方法" class="headerlink" title="3.3 解决方法"></a>3.3 解决方法</h3><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_5_20210411.png"></p><p>先B-&gt;D</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_6_20210411.png"></p><p>后B-&gt;D消失</p><blockquote><p>解决：下一次GC清除浮动垃圾</p></blockquote><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_7_20210411.png"></p><p>先B-&gt;D</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_8_20210411.png"></p><p>后B-&gt;D消失，A-&gt;D增加，倒是D漏标</p><blockquote><p>CMS的解决方案（Incremental Update）：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_9_20210411.png"></p><p>存在bug</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_10_20210411x.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_11_20210411.png"></p><p>因此CMS垃圾回收器必须要有remark重写标记阶段，从头扫一遍</p><blockquote><p>G1的方案（SATB Snapshot-At-The-Begining）<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/lu322313/article/details/104763933">[2]</span></a></sup></p></blockquote><ul><li>SATB—Snapshot-At-The-Begining<br>在G1中,使用的是SATB方式,删除的时候记录所有的对象<br>它有3个步骤<ul><li><p>在开始标记的时候生成一个快照图,标记存活对象</p></li><li><p>在并发标记的时候所有被改变的对象入列(<font color="FF0000">在write barrier(写屏障)里把所有旧的的引用所指向的对象都变成非白的</font>)<img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0_12_20210411.png"></p></li><li><p>可能存在浮动垃圾,将在下次被收集</p></li></ul></li></ul><p>SATB是维持并发GC的一种手段. G1并发的基础就是SATB</p><p>  SATB可以理解成在GC开始之前对堆内存里的对象做一次快照,此时活的对象就认为是活的,从而形成一个对象图</p><ul><li><p>标记GC过程找那个分配的对象<br>在GC收集的时候,新生代的对象也认为是活的对象,除此之外其他不可达的对象都认为是垃圾对象</p><p>如何找到在GC过程中分配的对象呢?每个region记录这两个<font color="FF0000">top-at-mark-start(TAMS)指针</font>, 分别为</p><ul><li><font color="FF0000">prevTAMS</font></li><li><font color="FF0000">nextTAMS</font><br>在TAMS以上的对象就是新分配的,因而被视为<font color="FF0000">隐式marked</font><br>通过这种方式我们就找到了在GC过程中新分配的对象,并把这些对象认为是活的的对象</li></ul></li></ul><ul><li><p>如何解决GC过程中的引用变化<br>解决了对象在GC过程中分配的问题,那么在GC过程中引用发生变化的问题是怎么解决呢?</p><p>G1给出的解决办法是通过<font color="FF0000">Write Barrier</font>—写屏障,其作用就是<font color="FF0000">对引用字段进行赋值做了额外的处理</font></p><p>通过Write Barrier`就可以了解到哪些对象发生了什么样的变化</p></li></ul><ul><li>SATB的完整过程<br>mark的过程就是遍历Heap标记live Object的过程,采用的是三色标记算法,这三种颜色为<ul><li>white—表示还未访问到</li><li>gray—访问到但是它用到的引用还没有完全扫描完</li><li>black—访问到而且其用到的引用已经完全扫描完</li></ul>整个三色标记算法就是从GC root是出发遍历Heap, 针对可达到的对象先标记为white为gray,然后再标记gray为black遍历完成之后所有可达的对象都是black的,所有white都是可以回收的</li></ul><ul><li><p>并发标记对象漏标记情形<br>SATB仅仅对于在marking开始阶段进行”Snapshot”—mark all reachable at mark start, 但是concurrent的时候并发修改可能造成对象漏标记</p><p>对象漏标记情形可能有如下几种:</p><ul><li><p>对black新引用了一个white对象,然后又从gray对象中删除了对该white对象的引用,这样会造成该white对象的娄标吉</p></li><li><p>对black新引用了一个white对象,然后从gray对象删除了一个引用该white对象的white对象,这样也会造成改对象的漏标记</p></li><li><p>对black新引用了一个刚new出来的white对象,没有其他gray对象引用改wihte对象.这样也会造成了该white对象漏标记</p></li></ul><p>SATB提供的解决办法<br>对于三色算法在concurent的时候可能会产品的漏标记问题,SATB在marking阶段中</p><ul><li><font color="FF0000">对于从gray对象移除的目标引用对象标记为gray</font></li><li><font color="FF0000">对于black引用的新产生的对象标记为black</font></li></ul><p>由于是在开始的时候进行snapshot, 因而可能存在Floating Garbage</p></li></ul><ul><li>漏标与误标<br>误标没什么关系,顶多是造成浮动垃圾,在下次GC还是可以回收的但是漏标的后果是致命的,把本应该存活的对象给回收了,从而影响程序的正确性<ul><li>漏标<br>漏标的情况只会发生在白色对象中,且满足一下任一条件<ul><li>并发标记时, 应用线程给一个黑色对象的引用类型赋值了该白色类型的引用<br><font color="FF0000"><strong>解决办法</strong></font>—利用post-write- barrier<font color="FF0000">写后屏障</font>,记录所有新增的引用关系,然后根据这些引用关系为根重新扫描一遍</li><li>并发标记时, 应用线程给删除所有灰色对象到该白色对应的引用<br><font color="FF0000"><strong>解决办法</strong></font>—利用pre-write barrier<font color="FF0000">写前屏障</font>,将所有即将被删除的引用关系的旧引用记录下来,最后以这些旧引用为根重新扫描一遍</li></ul></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>马士兵JVM公开课<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/lu322313/article/details/104763933">https://blog.csdn.net/lu322313/article/details/104763933</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Class类和Class.forName()使用总结</title>
    <link href="/2021/04/05/Class%E7%B1%BB%E5%92%8CClass.forName()%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/05/Class%E7%B1%BB%E5%92%8CClass.forName()%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Class类和Class-forName-使用总结"><a href="#Class类和Class-forName-使用总结" class="headerlink" title="Class类和Class.forName()使用总结"></a>Class类和Class.forName()使用总结</h1><p>结合着反射的内容，发现有很多知识点以前没理清楚，mark一下Class和类加载Class.forName().</p><h2 id="1-Class类简介"><a href="#1-Class类简介" class="headerlink" title="1. Class类简介"></a>1. Class类简介</h2><p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p><p>Class 没有公共构造方法。Class 对象是在加载类时由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 </p><p>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p><p>基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 </p><p>每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p><p>一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</p><h3 id="1-1-Class对象的获取"><a href="#1-1-Class对象的获取" class="headerlink" title="1.1 Class对象的获取"></a>1.1 Class对象的获取</h3><ul><li><p>1、调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">MyObject x;<br>Class c1 = x.getClass();<br></code></pre></td></tr></table></figure></li><li><p>2、使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c2 = Class.forName(<span class="hljs-string">&quot;MyObject&quot;</span>)<br></code></pre></td></tr></table></figure><p>,Employee必须是接口或者类的名字。</p></li><li><p>3、获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cl1 = Manager.class;<br>Class cl2 = <span class="hljs-keyword">int</span>.class;<br>Class cl3 = Double[].class;<br></code></pre></td></tr></table></figure><p>注意：Class对象实际上描述的只是类型，而这类型未必是类或者接口。例如上面的int.class是一个Class类型的对象。由于历史原因，数组类型的getName方法会返回奇怪的名字。</p></li></ul><h3 id="1-2-Class类的常用方法"><a href="#1-2-Class类的常用方法" class="headerlink" title="1.2 Class类的常用方法"></a>1.2 Class类的常用方法</h3><ul><li><p>getName() </p><p>一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</p></li><li><p>newInstance()<br>Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如：<br>x.getClass.newInstance()，创建了一个同x一样类型的新实例。newInstance()方法调用默认构造器（无参数构造器）初始化新建对象。</p></li><li><p>getClassLoader() </p><p>返回该类的类加载器。</p></li><li><p>getComponentType() </p><p>返回表示数组组件类型的 Class。</p></li><li><p>getSuperclass() </p><p>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</p></li><li><p>isArray() </p><p>判定此 Class 对象是否表示一个数组类</p></li></ul><h3 id="1-3-Class的一些使用技巧"><a href="#1-3-Class的一些使用技巧" class="headerlink" title="1.3 Class的一些使用技巧"></a>1.3 Class的一些使用技巧</h3><ol><li><p>forName和newInstance结合起来使用，可以根据存储在字符串中的类名创建对象。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj = Class.forName(s).newInstance();<br></code></pre></td></tr></table></figure></li><li><p>虚拟机为每种类型管理一个独一无二的Class对象。因此可以使用==操作符来比较类对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(e.getClass() == Employee.class)...<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-Class-forName-方法"><a href="#2-Class-forName-方法" class="headerlink" title="2. Class.forName()方法"></a>2. Class.forName()方法</h2><p><font color="0000FF">Class.forName</font>：返回与给定的字符串名称相关联类或接口的Class对象。</p><p><font color="0000FF">Class.forName</font>是一个<strong>静态方法</strong>，同样可以用来<strong>加载类</strong>。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)<br/>Returns the Class object associated with the class or interface with the given string name.</td></tr><tr><td>static Class&lt;?&gt;</td><td>forName(String name, boolean initialize, ClassLoader loader)<br />Returns the Class object associated with the class or interface with the given string name, using the given class loader.</td></tr></tbody></table><p><font color="FF0000">说明</font>：</p><p>publicstatic Class&lt;?&gt; forName(String className)</p><p>Returns the Class object associated withthe class or interface with the given string name. <font color="FF0000">Invokingthis method is equivalent to:Class.forName(className,true, currentLoader)</font></p><p>where currentLoader denotes the definingclass loader of the current class.</p><p>For example, thefollowing code fragment returns the runtime Class descriptor for theclass named java.lang.Thread:</p><p>Class t =Class.forName(“java.lang.Thread”)</p><p><font color="FF0000">A call to forName(“X”) causes theclass named X to beinitialized.</font></p><p><strong>Parameters</strong>:</p><p>className - the fully qualifiedname of the desired class.</p><p><strong>Returns</strong>:</p><p>the Class object for the classwith the specified name.</p><blockquote><p>从官方给出的API文档中可以看出:</p><p>Class.forName(className)实际上是调Class.forName(className,true,this.getClass().getClassLoader()).</p><p>第二个参数，是指Class被loading后是不是必须被初始化。</p><p>可以看出，使用Class.forName（className）加载类时则已初始化。</p><p><font color="FF0000">所以Class.forName(className)可以简单的理解为：获得字符串参数中指定的类，并初始化该类。</font></p></blockquote><h3 id="2-1-任何class都要装载在虚拟机上才能运行"><a href="#2-1-任何class都要装载在虚拟机上才能运行" class="headerlink" title="2.1 任何class都要装载在虚拟机上才能运行"></a>2.1 任何class都要装载在虚拟机上才能运行</h3><ol><li><pre><code> forName这句话就是&lt;font color=&quot;FF0000&quot;&gt;装载类&lt;/font&gt;用的(new是根据加载到内存中的类创建一个实例，要分清楚)。 </code></pre></li><li><p>至于什么时候用，可以考虑一下这个问题，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = (A) Class.forName(<span class="hljs-string">&quot;pacage.A&quot;</span>).newInstance();<br>A a = <span class="hljs-keyword">new</span> A();<br></code></pre></td></tr></table></figure><p>是一样的效果。</p></li><li><p>jvm在装载类时会执行类的静态代码段，要记住<font color="FF0000">静态代码是和class绑定的</font>，class装载成功就表示执行了你的静态代码了，而且以后不会再执行这段静态代码了。</p></li><li><p>Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。</p></li><li><p>动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = 用户输入的字符串;<br>Class t = Class.forName(str);  <br>t.newInstance(); <br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-在初始化一个类，生成一个实例的时候，newInstance-方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？"><a href="#2-2-在初始化一个类，生成一个实例的时候，newInstance-方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？" class="headerlink" title="2.2 在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？"></a>2.2 在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？</h3><ol><li><p>创建对象的方式不一样，前者是使用<strong>类加载机制</strong>，后者是创建一个<strong>新类</strong>。</p></li><li><p>那么为什么会有两种创建对象方式？</p><p>这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。  Java中<font color="FF0000">工厂模式</font>经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c</span> </span>= Class.forName(“Example”);  <br>factory = (ExampleInterface) c.newInstance();  <br></code></pre></td></tr></table></figure><p>其中ExampleInterface是Example的接口，可以写成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = <span class="hljs-string">&quot;Example&quot;</span>;  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c</span> </span>= Class.forName(className);  <br>factory = (ExampleInterface) c.newInstance();<br></code></pre></td></tr></table></figure><p>进一步可以写成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = readfromXMlConfig;<span class="hljs-comment">//从xml 配置文件中获得字符串</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c</span> </span>= Class.forName(className); <br>factory = (ExampleInterface) c.newInstance(); <br></code></pre></td></tr></table></figure><p>上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。  </p></li><li><p>从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。 但是使用newInstance()方法的时候，就必须保证：</p><ul><li>这个类已经加载</li><li>这个类已经连接</li></ul><p>而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。</p><p>现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。</p></li></ol><h3 id="2-3-Class-forName和ClassLoader的区别"><a href="#2-3-Class-forName和ClassLoader的区别" class="headerlink" title="2.3 Class.forName和ClassLoader的区别"></a>2.3 Class.forName和ClassLoader的区别</h3><blockquote><p>java中class.forName()和classLoader都可用来对类进行加载。</p><ol><li>class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块</li><li>classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。</li></ol></blockquote><p>java类加载分三步：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA_2_20210405.png"></p><ul><li><p>加载<br>Jvm把class文件字节码加载到内存中，并将这些静态数据装换成运行时数据区中方法区的类型数据，在运行时数据区堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。<br>*注：方法区不仅仅是存放方法，它存放的是类的类型信息。</p></li><li><p>链接：执行下面的校验、准备和解析步骤，其中解析步骤是可选的</p><ul><li><p>校验：检查加载的class文件的正确性和安全性</p></li><li><p>准备：为类变量分配存储空间并设置类变量初始值，类变量随类型信息存放在方法区中,生命周期很长，使用不当和容易造成内存泄漏。</p><p>注：类变量就是static变量；初始值指的是类变量类型的默认值而不是实际要赋的值</p></li><li><p>解析：jvm将常量池内的符号引用转换为直接引用</p></li></ul></li><li><p>初始化：执行类变量赋值和静态代码块</p></li></ul><h4 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h4><ul><li><p>Classloder.loaderClass(String name)<br>其实该方法内部调用的是：Classloder. loadClass(name, false)<br>方法：Classloder. loadClass(String name, boolean resolve)</p><ul><li>参数name代表类的全限定类名</li><li>参数resolve代表是否解析，resolve为true是解析该类</li></ul></li><li><p>Class.forName(String name)<br>其实该方法内部调用的是：Class.forName(className, true, ClassLoader.getClassLoader(caller))<br>方法：Class.forName0(String name, boolean initialize, ClassLoader loader)</p><ul><li><p>参数name代表全限定类名</p></li><li><p>参数initialize代表是否初始化该类，为true是初始化该类</p></li><li><p>参数loader代表对应的类加载器</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Class.forName(String className)  这是1.8的源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;?&gt; caller = Reflection.getCallerClass();<br>    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);<br>&#125;<br><span class="hljs-comment">//注意第二个参数，是指Class被loading后是不是必须被初始化。 不初始化就是不执行static的代码即静态代码</span><br></code></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><font color="FF0000">Class.forName得到的class是已经初始化完成的</font></p><p><font color="FF0000">Classloder.loaderClass得到的class是还没有链接的</font></p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.reflect;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Line</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块执行: loading line&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.reflect;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块执行: loading point&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.reflect;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassloaderAndForNameTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String wholeNameLine = <span class="hljs-string">&quot;com.reflect.Line&quot;</span>;<br>        String wholeNamePoint = <span class="hljs-string">&quot;com.reflect.Point&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;下面是测试Classloader的效果&quot;</span>);<br>        testClassloader(wholeNameLine, wholeNamePoint);<br>        System.out.println(<span class="hljs-string">&quot;----------------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;下面是测试Class.forName的效果&quot;</span>);<br>        testForName(wholeNameLine, wholeNamePoint);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * classloader</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wholeNameLine</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wholeNamePoint</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testClassloader</span><span class="hljs-params">(String wholeNameLine, String wholeNamePoint)</span> </span>&#123;<br>        Class&lt;?&gt; line;<br>        Class&lt;?&gt; point;<br>        ClassLoader loader = ClassLoader.getSystemClassLoader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            line = loader.loadClass(wholeNameLine);<br>            point = loader.loadClass(wholeNamePoint);<br>            System.out.println(<span class="hljs-string">&quot;line &quot;</span> + line.getName());<br>            System.out.println(<span class="hljs-string">&quot;point &quot;</span> + point.getName());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Class.forName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wholeNameLine</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wholeNamePoint</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testForName</span><span class="hljs-params">(String wholeNameLine, String wholeNamePoint)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; line = Class.forName(wholeNameLine);<br>            Class&lt;?&gt; point = Class.forName(wholeNamePoint);<br>            System.out.println(<span class="hljs-string">&quot;line   &quot;</span> + line.getName());<br>            System.out.println(<span class="hljs-string">&quot;point   &quot;</span> + point.getName());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">下面是测试Classloader的效果<br><span class="hljs-type">line</span> com.reflect.Line<br><span class="hljs-type">point</span> com.reflect.Point<br><span class="hljs-comment">----------------------------------</span><br>下面是测试<span class="hljs-keyword">Class</span>.forName的效果<br>静态代码块执行: loading <span class="hljs-type">line</span><br>静态代码块执行: loading <span class="hljs-type">point</span><br><span class="hljs-type">line</span>   com.reflect.Line<br><span class="hljs-type">point</span>   com.reflect.Point<br></code></pre></td></tr></table></figure><p>根据运行结果，可以看到，classloader并没有执行静态代码块，如开头的理论所说。</p><p>而下面的Class.forName则是夹在完之后，就里面执行了静态代码块，可以看到，2个类，line和point的静态代码块执行结果是一起的，然后才是各自的打印结果。</p><p>也说明上面理论是OK的。</p><hr><p>接下来修改下Line的代码，添加了几个静态的方法和变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.reflect;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Line</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块执行: loading line&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String s = getString();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;给静态变量赋值的静态方法执行：loading line&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mask&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通静态方法执行：loading line&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Line</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造方法执行&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">下面是测试Classloader的效果<br><span class="hljs-type">line</span> com.reflect.Line<br><span class="hljs-type">point</span> com.reflect.Point<br><span class="hljs-comment">----------------------------------</span><br>下面是测试<span class="hljs-keyword">Class</span>.forName的效果<br>静态代码块执行: loading <span class="hljs-type">line</span><br>给静态变量赋值的静态方法执行：loading <span class="hljs-type">line</span><br>静态代码块执行: loading <span class="hljs-type">point</span><br><span class="hljs-type">line</span>   com.reflect.Line<br><span class="hljs-type">point</span>   com.reflect.Point<br></code></pre></td></tr></table></figure><p>除了，静态代码块的执行外，竟然还有一个静态方法被执行，就是给静态变量赋值的静态方法被执行了.</p><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><h3 id="3-1-场景一：加载数据库驱动"><a href="#3-1-场景一：加载数据库驱动" class="headerlink" title="3.1 场景一：加载数据库驱动"></a>3.1 场景一：加载数据库驱动</h3><blockquote><p>利用了类加载和静态代码块绑定的特点</p></blockquote><p>使用new加载注册</p><p>static void registerDriver(Driver driver) : 注册与给定的驱动程序 DriverManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br></code></pre></td></tr></table></figure><p>而通常都是通过反射，加载与注册驱动类，<strong>解耦合（不直接依赖）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br></code></pre></td></tr></table></figure><p>为什么在我们加载数据库驱动包的时候有的却没有调用newInstance( )方法呢？(即有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一些Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？)</p><p>刚才提到，Class.forName() 的作用是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。</p><p>而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBCDriver的Driver类的代码都必须类似如下:</p><p>com.mysql.jdbc.Driver类中存在静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>  java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>  &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了。</p><h3 id="3-2-场景二-使用AIDL与电话管理Servic进行通信"><a href="#3-2-场景二-使用AIDL与电话管理Servic进行通信" class="headerlink" title="3.2 场景二: 使用AIDL与电话管理Servic进行通信"></a>3.2 场景二: 使用AIDL与电话管理Servic进行通信</h3><blockquote><p>获取类对象，通过反射实现代理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Method method = Class.forName(<span class="hljs-string">&quot;android.os.ServiceManager&quot;</span>).getMethod(<span class="hljs-string">&quot;getService&quot;</span>,String.class);<br><span class="hljs-comment">// 获取远程TELEPHONY_SERVICE的IBinder对象的代理</span><br>IBinder binder =(IBinder) method.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Object[] &#123; TELEPHONY_SERVICE&#125;);<br><span class="hljs-comment">// 将IBinder对象的代理转换为ITelephony对象</span><br>ITelephonytelephony = ITelephony.Stub.asInterface(binder);<br><span class="hljs-comment">// 挂断电话</span><br>telephony.endCall();<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/fengyuzhengfan/article/details/38086743">https://blog.csdn.net/fengyuzhengfan/article/details/38086743</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>JDK1.8_API…/docs/api/java/lang/Class.html<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="http://www.ibm.com/developerworks/cn/java/j-lo-classloader/">http://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/riemann_/article/details/86769805">https://blog.csdn.net/riemann_/article/details/86769805</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java初始化发生时机</title>
    <link href="/2021/04/05/Java%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA/"/>
    <url>/2021/04/05/Java%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Java初始化的时机"><a href="#Java初始化的时机" class="headerlink" title="Java初始化的时机"></a>Java初始化的时机</h1><p>Java虚拟机规范没有强制性约束在什么时候开始类加载过程，但是对于初始化阶段，虚拟机规范则严格规定了有且只有四种情况必需立即对类进行“初始化”（而加载、验证、准备、连接阶段则必需在此之前开始）</p><p>黑马的JVM课程中提到过<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV1yE411Z7AP">[3]</span></a></sup></p><blockquote><p><strong>初始化发生时机</strong></p></blockquote><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h2 id="1-四种情况归类"><a href="#1-四种情况归类" class="headerlink" title="1. 四种情况归类"></a>1. 四种情况归类</h2><ul><li><p>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时、以及调用一个类的静态方法的时候。</p></li><li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要触发父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的类），虚拟机会先初始化这个类。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA_1_20210405.png"></p><p>对于这四种触发类进行初始化的场景，在java虚拟机规范中限定了“<strong>有且只有</strong>”这四种场景会触发。这四种场景的行为称为对类的主动引用，除此以外的所有引用类的方式都不会触发类的初始化，称为被动引用。</p><h2 id="2-三个实例说明被动引用"><a href="#2-三个实例说明被动引用" class="headerlink" title="2. 三个实例说明被动引用"></a>2. 三个实例说明被动引用</h2><ul><li>示例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类SuperClass.java </span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * ClassName:SuperClass &lt;br/&gt; </span><br><span class="hljs-comment"> * Function: 被动使用类：通过子类引用父类的静态字段，不会导致子类初始化. &lt;br/&gt;    </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>&#123;  <br>    <span class="hljs-keyword">static</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;SuperClass init!&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;  <br>&#125;  <br><br><span class="hljs-comment">// 子类SubClass.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>&#123;  <br>    <span class="hljs-keyword">static</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;SubClass init!&quot;</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-comment">// 主类NotInitialization.java </span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * ClassName:NotInitialization &lt;br/&gt; </span><br><span class="hljs-comment"> * Function: 非主动使用类字段演示. &lt;br/&gt;     </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotInitialization</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        System.out.println(SubClass.value);  <br>    &#125;  <br>&#125;  <br><br><br>输出结果：<br>Txt代码  收藏代码<br>SuperClass init!  <br><span class="hljs-number">123</span>  <br></code></pre></td></tr></table></figure><blockquote><p>由结果可以看出只输出了“SuperClass init！”，没有输出“SubClass init！”。这是因为对于静态字段，只有直接定义该字段的类才会被初始化，因此当我们通过子类来引用父类中定义的静态字段时，只会触发父类的初始化，而不会触发子类的初始化。</p></blockquote><ul><li>示例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类SuperClass.java如上一个示例一样</span><br><br><span class="hljs-comment">// 主类NotInitialization.java </span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * ClassName:NotInitialization &lt;br/&gt; </span><br><span class="hljs-comment"> * Function: 通过数组定义来引用类，不会触发此类的初始化. &lt;br/&gt;     </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotInitialization</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        SuperClass[] scs = <span class="hljs-keyword">new</span> SuperClass[<span class="hljs-number">10</span>];  <br>    &#125;  <br>&#125;  <br><br>输出结果为空<br></code></pre></td></tr></table></figure><blockquote><p>没有输出“SuperClass init！”说明没有触发类com.chenzhou.classloading.SuperClass的初始化阶段，但是这段代码会触发“[Lcom.chenzhou.classloading.SuperClass”类的初始化阶段。这个类是由虚拟机自动生成的，该创建动作由newarray触发。</p></blockquote><ul><li>示例三</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常量类ConstClass.java</span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * ClassName:ConstClass &lt;br/&gt; </span><br><span class="hljs-comment"> * Function: 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化. &lt;br/&gt;       </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstClass</span> </span>&#123;  <br>    <span class="hljs-keyword">static</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ConstClass init!&quot;</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HELLOWORLD = <span class="hljs-string">&quot;hello world&quot;</span>;  <br>&#125; <br><br><span class="hljs-comment">// 主类NotInitialization.java </span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * ClassName:NotInitialization &lt;br/&gt; </span><br><span class="hljs-comment"> * Function: 非主动实用类字段演示. &lt;br/&gt;      </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotInitialization</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        System.out.println(ConstClass.HELLOWORLD);  <br>    &#125;  <br>&#125;  <br><br>输出：<br>hello world<br></code></pre></td></tr></table></figure><blockquote><p>上面的示例代码运行后也没有输出“SuperClass init！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但是在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中，对于常量ConstClass.HELLOWORLD的引用实际上都被转化为NotInitialization类对自身常量池的引用了。实际上NotInitialization的Class文件之中已经不存在ConstClass类的符号引用入口了。</p></blockquote><h2 id="3-接口加载"><a href="#3-接口加载" class="headerlink" title="3. 接口加载"></a>3. 接口加载</h2><p>接口的加载过程与类加载的区别在于上面提到的四种场景中的第三种，当类在初始化时要求其父类都已经初始化过了，但是一个接口在初始化时，并不要求其父类都完成了初始化，只有在真正用到父类接口的时候（如引用父接口的常量）才会初始化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://chenzhou123520.iteye.com/blog/1597597">http://chenzhou123520.iteye.com/blog/1597597</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.360doc.com/content/20/0602/17/70282097_916085081.shtml">http://www.360doc.com/content/20/0602/17/70282097_916085081.shtml</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1yE411Z7AP">https://www.bilibili.com/video/BV1yE411Z7AP</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUnit单元测试、反射、注解、动态代理</title>
    <link href="/2021/04/03/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/04/03/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="JUnit单元测试、反射、注解、动态代理"><a href="#JUnit单元测试、反射、注解、动态代理" class="headerlink" title="JUnit单元测试、反射、注解、动态代理"></a>JUnit单元测试、反射、注解、动态代理</h1><p>直接上传的黑马的官方笔记。</p><p><strong>反射</strong>、注解、<strong>动态代理</strong>在许多框架都有使用。</p><p>最近看Mybatis代码时，有点忘了，传上来好经常复习。</p><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li><input disabled="" type="checkbox"> 能够使用Junit进行单元测试</li><li><input disabled="" type="checkbox"> 能够通过反射技术获取Class字节码对象</li><li><input disabled="" type="checkbox"> 能够通过反射技术获取构造方法对象，并创建对象。</li><li><input disabled="" type="checkbox"> 能够通过反射获取成员方法对象，并且调用方法。</li><li><input disabled="" type="checkbox"> 能够通过反射获取属性对象，并且能够给对象的属性赋值和取值。</li><li><input disabled="" type="checkbox"> 能够说出注解的作用 </li><li><input disabled="" type="checkbox"> 能够自定义注解和使用注解</li><li><input disabled="" type="checkbox"> 能够说出常用的元注解及其作用</li><li><input disabled="" type="checkbox"> 能够解析注解并获取注解中的数据</li><li><input disabled="" type="checkbox"> 能够完成注解的MyTest案例</li><li><input disabled="" type="checkbox"> 能够说出动态代理模式的作用</li><li><input disabled="" type="checkbox"> 能够使用Proxy的方法生成代理对象</li><li><input disabled="" type="checkbox"> 能够使用四种方法的引用</li><li><input disabled="" type="checkbox"> 能够使用Base64对基本数据、URL和MIME类型进行编解码</li></ul><h1 id="第一章-Junit单元测试"><a href="#第一章-Junit单元测试" class="headerlink" title="第一章 Junit单元测试"></a>第一章 Junit单元测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">Junit是什么<br>    *  Junit是Java语言编写的第三方单元测试框架(工具类)<br>    *  类库 ==&gt; 类  junit.jar<br><br>单元测试概念<br>    * 单元：在Java中，一个类就是一个单元<br>    * 单元测试：程序猿编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试。<br><br>Junit单元测试框架的作用<br>    * 用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性。<br>    * 能够让方法独立运行起来。<br><br>Junit单元测试框架的使用步骤<br>    * 编写业务类，在业务类中编写业务方法。比如增删改查的方法<br>    * 编写测试类，在测试类中编写测试方法，在测试方法中编写测试代码来测试。<br>        * 测试类的命名规范：以Test开头，以业务类类名结尾，使用驼峰命名法<br>            * 每一个单词首字母大写，称为大驼峰命名法，比如类名，接口名...<br>            * 从第二单词开始首字母大写，称为小驼峰命名法，比如方法命名<br>            * 比如业务类类名：ProductDao，那么测试类类名就应该叫：TestProductDao<br>        * 测试方法的命名规则：以test开头，以业务方法名结尾<br>            * 比如业务方法名为：save，那么测试方法名就应该叫：testSave<br><br>测试方法注意事项<br>    * 必须是<span class="hljs-keyword">public</span>修饰的，没有返回值，没有参数<br>    * 必须使注解<span class="hljs-meta">@Test</span>修饰<br><br>如何运行测试方法<br>    * 选中方法名 --&gt; 右键 --&gt; Run <span class="hljs-string">&#x27;测试方法名&#x27;</span>  运行选中的测试方法<br>    * 选中测试类类名 --&gt; 右键 --&gt; Run <span class="hljs-string">&#x27;测试类类名&#x27;</span>  运行测试类中所有测试方法<br>    * 选中模块名 --&gt; 右键 --&gt; Run <span class="hljs-string">&#x27;All Tests&#x27;</span>  运行模块中的所有测试类的所有测试方法<br><br>如何查看测试结果<br>    * 绿色：表示测试通过<br>    * 红色：表示测试失败，有问题<br><br>Junit常用注解(Junit4.xxxx版本)<br>    * <span class="hljs-meta">@Before</span>：用来修饰方法，该方法会在每一个测试方法执行之前执行一次。<br>    * <span class="hljs-meta">@After</span>：用来修饰方法，该方法会在每一个测试方法执行之后执行一次。<br>    * <span class="hljs-meta">@BeforeClass</span>：用来静态修饰方法，该方法会在所有测试方法之前执行一次。<br>    * <span class="hljs-meta">@AfterClass</span>：用来静态修饰方法，该方法会在所有测试方法之后执行一次。<br><br>Junit常用注解(Junit5.xxxx版本)<br>     * <span class="hljs-meta">@BeforeEach</span>：用来修饰方法，该方法会在每一个测试方法执行之前执行一次。<br>     * <span class="hljs-meta">@AfterEach</span>：用来修饰方法，该方法会在每一个测试方法执行之后执行一次。<br>     * <span class="hljs-meta">@BeforeAll</span>：用来静态修饰方法，该方法会在所有测试方法之前执行一次。<br>     * <span class="hljs-meta">@AfterAll</span>：用来静态修饰方法，该方法会在所有测试方法之后执行一次。<br></code></pre></td></tr></table></figure><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 业务类：实现加减乘除运算</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cacluate</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     业务方法1：求a和b之和</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  a + b + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     业务方法2:求a和b之差</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  a - b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCacluate</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Cacluate c = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-meta">@BeforeClass</span> <span class="hljs-comment">// 用来静态修饰方法，该方法会在所有测试方法之前执行一次。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化操作&quot;</span>);<br>        <span class="hljs-comment">// 创建Cacluate对象</span><br>        c = <span class="hljs-keyword">new</span> Cacluate();<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span> <span class="hljs-comment">// 用来静态修饰方法，该方法会在所有测试方法之后执行一次。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;释放资源&quot;</span>);<br>        c = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>   <span class="hljs-comment">/* @Before // 用来修饰方法，该方法会在每一个测试方法执行之前执行一次。</span><br><span class="hljs-comment">    public void init()&#123;</span><br><span class="hljs-comment">        System.out.println(&quot;初始化操作&quot;);</span><br><span class="hljs-comment">        // 创建Cacluate对象</span><br><span class="hljs-comment">        c = new Cacluate();</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    @After // 用来修饰方法，该方法会在每一个测试方法执行之后执行一次。</span><br><span class="hljs-comment">    public void close()&#123;</span><br><span class="hljs-comment">        System.out.println(&quot;释放资源&quot;);</span><br><span class="hljs-comment">        c = null;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSum</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> result = c.sum(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            断言：预习判断某个条件一定成立，如果条件不成立，则直接奔溃。</span><br><span class="hljs-comment">            assertEquals方法的参数</span><br><span class="hljs-comment">            (String message, double expected, double actual)</span><br><span class="hljs-comment">            message： 消息字符串</span><br><span class="hljs-comment">            expected: 期望值</span><br><span class="hljs-comment">            actual: 实际值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 如果期望值和实际值一致，则什么也不发生，否则会直接奔溃。</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;期望值和实际值不一致&quot;</span>,<span class="hljs-number">12</span>,result);<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSub</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 创建Cacluate对象</span><br>        <span class="hljs-comment">// Cacluate c = new Cacluate();</span><br><br>        <span class="hljs-keyword">int</span> result = c.sub(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 如果期望值和实际值一致，则什么也不发生，否则会直接奔溃。</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;期望值和实际值不一致&quot;</span>,<span class="hljs-number">0</span>,result);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-反射"><a href="#第二章-反射" class="headerlink" title="第二章 反射"></a>第二章 反射</h1><h2 id="2-1-反射的概述"><a href="#2-1-反射的概述" class="headerlink" title="2.1 反射的概述"></a>2.1 反射的概述</h2><h3 id="2-1-1-反射的引入"><a href="#2-1-1-反射的引入" class="headerlink" title="2.1.1  反射的引入"></a>2.1.1  反射的引入</h3><ul><li>问题：IDEA中的对象是怎么知道类有哪些属性，哪些方法的呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">通过反射技术对象类进行了解剖得到了类的所有成员。<br></code></pre></td></tr></table></figure><h3 id="2-1-2-反射的概念"><a href="#2-1-2-反射的概念" class="headerlink" title="2.1.2  反射的概念"></a>2.1.2  反射的概念</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">反射是一种机制，利用该机制可以在程序运行过程中对类进行解剖并操作类中的所有成员(成员变量，成员方法，构造方法)<br></code></pre></td></tr></table></figure><h3 id="2-1-3-使用反射操作类成员的前提"><a href="#2-1-3-使用反射操作类成员的前提" class="headerlink" title="2.1.3 使用反射操作类成员的前提"></a>2.1.3 使用反射操作类成员的前提</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">要获得该类字节码文件对象，就是Class对象<br></code></pre></td></tr></table></figure><h3 id="2-1-4-反射在实际开发中的应用"><a href="#2-1-4-反射在实际开发中的应用" class="headerlink" title="2.1.4 反射在实际开发中的应用"></a>2.1.4 反射在实际开发中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">* 开发IDE(集成开发环境)，比如IDEA,Eclipse<br>* 各种框架的设计和学习 比如Spring，Hibernate，Struct，Mybaits....<br></code></pre></td></tr></table></figure><h2 id="2-2-Class对象的获取方式"><a href="#2-2-Class对象的获取方式" class="headerlink" title="2.2 Class对象的获取方式"></a>2.2 Class对象的获取方式</h2><h3 id="2-2-1-三种获取方法"><a href="#2-2-1-三种获取方法" class="headerlink" title="2.2.1 三种获取方法"></a>2.2.1 三种获取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">* 方式<span class="hljs-number">1</span>: 通过类名.class获得<br>* 方式<span class="hljs-number">2</span>：通过对象名.getClass()方法获得<br>* 方式<span class="hljs-number">3</span>：通过Class类的静态方法获得： <span class="hljs-function"><span class="hljs-keyword">static</span> Class <span class="hljs-title">forName</span><span class="hljs-params">(<span class="hljs-string">&quot;类全名&quot;</span>)</span></span><br><span class="hljs-function">    * 每一个类的Class对象都只有一个。</span><br></code></pre></td></tr></table></figure><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 获得Student类对应的Class对象</span><br>        Class c1 = Student.class;<br><br>        <span class="hljs-comment">// 创建学生对象</span><br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        <span class="hljs-comment">// 通过getClass方法</span><br>        Class c2 = stu.getClass();<br>        System.out.println(c1 == c2);<br><br>        <span class="hljs-comment">// 通过Class类的静态方法获得： static Class forName(&quot;类全名&quot;)</span><br>        Class c3 = Class.forName(<span class="hljs-string">&quot;com.itheima._03反射.Student&quot;</span>);<br>        System.out.println(c1 == c3);<br>        System.out.println(c2 == c3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-Class类常用方法"><a href="#2-2-2-Class类常用方法" class="headerlink" title="2.2.2 Class类常用方法"></a>2.2.2 Class类常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">getSimpleName</span><span class="hljs-params">()</span></span>; 获得类名字符串：类名<br><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;  获得类全名：包名+类名<br><span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>;  创建Class对象关联类的对象<br></code></pre></td></tr></table></figure><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <span class="hljs-comment">// 获得类名字符串：类名</span><br>        System.out.println(c.getSimpleName());<br>        <span class="hljs-comment">// 获得类全名：包名+类名</span><br>        System.out.println(c.getName());<br>        <span class="hljs-comment">// 创建对象</span><br>        Student stu = (Student) c.newInstance();<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-反射之操作构造方法"><a href="#2-3-反射之操作构造方法" class="headerlink" title="2.3 反射之操作构造方法"></a>2.3 反射之操作构造方法</h2><h3 id="2-3-1-Constructor类概述"><a href="#2-3-1-Constructor类概述" class="headerlink" title="2.3.1 Constructor类概述"></a>2.3.1 Constructor类概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">反射之操作构造方法的目的<br>    * 获得Constructor对象来创建类的对象。<br><br>Constructor类概述<br>    * 类中的每一个构造方法都是一个Constructor类的对象<br></code></pre></td></tr></table></figure><h3 id="2-3-2-Class类中与Constructor相关的方法"><a href="#2-3-2-Class类中与Constructor相关的方法" class="headerlink" title="2.3.2 Class类中与Constructor相关的方法"></a>2.3.2 Class类中与Constructor相关的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-function">Constructor <span class="hljs-title">getConstructor</span><span class="hljs-params">(Class... parameterTypes)</span></span><br><span class="hljs-function">        * 根据参数类型获得对应的Constructor对象。</span><br><span class="hljs-function">        * 只能获得<span class="hljs-keyword">public</span>修饰的构造方法</span><br><span class="hljs-function"> 2. Constructor <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(Class... parameterTypes)</span></span><br><span class="hljs-function">         * 根据参数类型获得对应的Constructor对象，包括<span class="hljs-keyword">private</span></span><br><span class="hljs-function"> 3. Constructor[] <span class="hljs-title">getConstructors</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        获得类中的所有构造方法对象，只能获得<span class="hljs-keyword">public</span>的</span><br><span class="hljs-function"> 4. Constructor[] <span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        获得类中的所有构造方法对象，包括<span class="hljs-keyword">private</span>修饰的</span><br></code></pre></td></tr></table></figure><h3 id="2-3-3-Constructor对象常用方法"><a href="#2-3-3-Constructor对象常用方法" class="headerlink" title="2.3.3 Constructor对象常用方法"></a>2.3.3 Constructor对象常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Object... initargs)</span></span><br><span class="hljs-function"> 根据指定的参数创建对象</span><br><span class="hljs-function">2. <span class="hljs-keyword">void</span> <span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">   设置是否取消权限检查，<span class="hljs-keyword">true</span>取消权限检查，<span class="hljs-keyword">false</span>表示不取消<span class="hljs-params">(暴力反射)</span></span><br></code></pre></td></tr></table></figure><h3 id="2-3-4-示例代码"><a href="#2-3-4-示例代码" class="headerlink" title="2.3.4 示例代码"></a>2.3.4 示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo03</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      Constructor[] getConstructors()</span><br><span class="hljs-comment">           获得类中的所有构造方法对象，只能获得public的</span><br><span class="hljs-comment">      Constructor[] getDeclaredConstructors()</span><br><span class="hljs-comment">            获得类中的所有构造方法对象，包括private修饰的</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <span class="hljs-comment">//  获得类中的所有构造方法对象，只能获得public的</span><br>        <span class="hljs-comment">// Constructor[] cons = c.getConstructors();</span><br>        Constructor[] cons = c.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor con:cons) &#123;<br>            System.out.println(con);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       Constructor getDeclaredConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">           根据参数类型获得对应的Constructor对象</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <span class="hljs-comment">// 获得两个参数构造方法对象</span><br>        Constructor con = c.getDeclaredConstructor(String.class,String.class);<br>        <span class="hljs-comment">// 取消权限检查(暴力反射)</span><br>        con.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 根据构造方法创建对象</span><br>        Object obj = con.newInstance(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-string">&quot;女&quot;</span>);<br>        System.out.println(obj);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Constructor getConstructor(Class... parameterTypes)</span><br><span class="hljs-comment">            根据参数类型获得对应的Constructor对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <span class="hljs-comment">// 获得无参数构造方法对象</span><br>        Constructor con = c.getConstructor();<br>        <span class="hljs-comment">// 根据构造方法创建对象</span><br>        Object obj = con.newInstance();<br>        System.out.println(obj);<br><br>        <span class="hljs-comment">// 获得有参数的构造方法对象</span><br>        Constructor con2 = c.getConstructor(String.class, String.class,<span class="hljs-keyword">int</span>.class);<br>        <span class="hljs-comment">// 创建对象</span><br>        Object obj2 = con2.newInstance(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-number">18</span>);<br>        System.out.println(obj2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-反射之操作成员方法"><a href="#2-4-反射之操作成员方法" class="headerlink" title="2.4 反射之操作成员方法"></a>2.4 反射之操作成员方法</h2><h3 id="2-4-1-Method类概述"><a href="#2-4-1-Method类概述" class="headerlink" title="2.4.1 Method类概述"></a>2.4.1 Method类概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">反射之操作成员方法的目的<br>    * 操作Method对象来调用成员方法<br>Method类概述<br>    * 每一个成员方法都是一个Method类的对象。<br></code></pre></td></tr></table></figure><h3 id="2-4-2-Class类中与Method相关的方法"><a href="#2-4-2-Class类中与Method相关的方法" class="headerlink" title="2.4.2 Class类中与Method相关的方法"></a>2.4.2 Class类中与Method相关的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">* <span class="hljs-function">Method <span class="hljs-title">getMethod</span><span class="hljs-params">(String name,Class...args)</span></span>;<br>    * 根据方法名和参数类型获得对应的构造方法对象，只能获得<span class="hljs-keyword">public</span>的<br><br>* <span class="hljs-function">Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name,Class...args)</span></span>;<br>    * 根据方法名和参数类型获得对应的构造方法对象，包括<span class="hljs-keyword">private</span>的<br><br>* Method[] getMethods();<br>    * 获得类中的所有成员方法对象，返回数组，只能获得<span class="hljs-keyword">public</span>修饰的且包含父类的<br><br>* Method[] getDeclaredMethods();<br>    * 获得类中的所有成员方法对象，返回数组,只获得本类的，包含<span class="hljs-keyword">private</span>修饰的<br></code></pre></td></tr></table></figure><h3 id="2-4-3-Method对象常用方法"><a href="#2-4-3-Method对象常用方法" class="headerlink" title="2.4.3 Method对象常用方法"></a>2.4.3 Method对象常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">*  <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    * 调用指定对象obj的该方法</span><br><span class="hljs-function">    * args：调用方法时传递的参数</span><br><span class="hljs-function">*  <span class="hljs-keyword">void</span> <span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">    设置是否取消权限检查，<span class="hljs-keyword">true</span>取消权限检查，<span class="hljs-keyword">false</span>表示不取消<span class="hljs-params">(暴力反射)</span></span><br></code></pre></td></tr></table></figure><h3 id="2-4-4-示例代码"><a href="#2-4-4-示例代码" class="headerlink" title="2.4.4 示例代码"></a>2.4.4 示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo04</span> </span>&#123;<br><br>    <span class="hljs-comment">// 反射操作静态方法</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <span class="hljs-comment">// 根据方法名获得对应的成员方法对象</span><br>        Method method = c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>,String.class);<br>        <span class="hljs-comment">// 通过method执行对应的方法</span><br>        method.invoke(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;蛋炒饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Method[] getMethods();</span><br><span class="hljs-comment">        * 获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span><br><span class="hljs-comment">     * Method[] getDeclaredMethods();</span><br><span class="hljs-comment">        * 获得类中的所有成员方法对象，返回数组,只获得本类的，包含private修饰的</span><br><span class="hljs-comment">   */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <span class="hljs-comment">// 获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span><br>        <span class="hljs-comment">// Method[] methods = c.getMethods();</span><br>        <span class="hljs-comment">// 获得类中的所有成员方法对象，返回数组,只获得本类的，包含private修饰的</span><br>        Method[] methods = c.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method m: methods) &#123;<br>            System.out.println(m);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       Method getDeclaredMethod(String name,Class...args);</span><br><span class="hljs-comment">           * 根据方法名和参数类型获得对应的构造方法对象，</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br><br>        <span class="hljs-comment">// 根据Class对象创建学生对象</span><br>        Student stu = (Student) c.newInstance();<br>        <span class="hljs-comment">// 获得sleep方法对应的Method对象</span><br>        Method m =  c.getDeclaredMethod(<span class="hljs-string">&quot;sleep&quot;</span>);<br>        <span class="hljs-comment">// 暴力反射</span><br>        m.setAccessible(<span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-comment">// 通过m对象执行stuy方法</span><br>        m.invoke(stu);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Method getMethod(String name,Class...args);</span><br><span class="hljs-comment">            * 根据方法名和参数类型获得对应的构造方法对象，</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = Student.class;<br>        <br>        <span class="hljs-comment">// 根据Class对象创建学生对象</span><br>        Student stu = (Student) c.newInstance();<br>        <span class="hljs-comment">// 获得study方法对应的Method对象</span><br>        Method m =  c.getMethod(<span class="hljs-string">&quot;study&quot;</span>);<br>        <span class="hljs-comment">// 通过m对象执行stuy方法</span><br>        m.invoke(stu);<br><br><br>        <span class="hljs-comment">/// 获得study方法对应的Method对象</span><br>        Method m2  = c.getMethod(<span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-keyword">int</span>.class);<br>        <span class="hljs-comment">// 通过m2对象执行stuy方法</span><br>        m2.invoke(stu,<span class="hljs-number">8</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-反射之操作成员变量"><a href="#2-5-反射之操作成员变量" class="headerlink" title="2.5 反射之操作成员变量"></a>2.5 反射之操作成员变量</h2><h3 id="2-5-1-Field类概述"><a href="#2-5-1-Field类概述" class="headerlink" title="2.5.1 Field类概述"></a>2.5.1 Field类概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">反射之操作成员变量的目的<br>    * 通过Field对象给对应的成员变量赋值和取值<br><br>Field类概述<br>    * 每一个成员变量都是一个Field类的对象。<br></code></pre></td></tr></table></figure><h3 id="2-5-2-Class类中与Field相关的方法"><a href="#2-5-2-Class类中与Field相关的方法" class="headerlink" title="2.5.2 Class类中与Field相关的方法"></a>2.5.2 Class类中与Field相关的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">* <span class="hljs-function">Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span></span>;<br>    *  根据成员变量名获得对应Field对象，只能获得<span class="hljs-keyword">public</span>修饰<br>* <span class="hljs-function">Field <span class="hljs-title">getDeclaredField</span><span class="hljs-params">(String name)</span></span>;<br>    *  根据成员变量名获得对应Field对象，包含<span class="hljs-keyword">private</span>修饰的<br>* Field[] getFields();<br>    * 获得所有的成员变量对应的Field对象，只能获得<span class="hljs-keyword">public</span>的<br>* Field[] getDeclaredFields();<br>    * 获得所有的成员变量对应的Field对象，包含<span class="hljs-keyword">private</span>的<br></code></pre></td></tr></table></figure><h3 id="2-5-3-Field对象常用方法"><a href="#2-5-3-Field对象常用方法" class="headerlink" title="2.5.3 Field对象常用方法"></a>2.5.3 Field对象常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">set</span><span class="hljs-params">(Object obj, Object value)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInt</span><span class="hljs-params">(Object obj, <span class="hljs-keyword">int</span> i)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLong</span><span class="hljs-params">(Object obj, <span class="hljs-keyword">long</span> l)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBoolean</span><span class="hljs-params">(Object obj, <span class="hljs-keyword">boolean</span> z)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDouble</span><span class="hljs-params">(Object obj, <span class="hljs-keyword">double</span> d)</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function">Object <span class="hljs-title">get</span><span class="hljs-params">(Object obj)</span>  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span><span class="hljs-title">getInt</span><span class="hljs-params">(Object obj)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getLong</span><span class="hljs-params">(Object obj)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">getBoolean</span><span class="hljs-params">(Object ob)</span></span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getDouble</span><span class="hljs-params">(Object obj)</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span>;暴力反射，设置为可以直接访问私有类型的属性。<br><span class="hljs-function">Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>; 获取属性的类型，返回Class对象。<br></code></pre></td></tr></table></figure><blockquote><p>setXxx方法都是给对象obj的属性设置使用，针对不同的类型选取不同的方法。</p><p>getXxx方法是获取对象obj对应的属性值的，针对不同的类型选取不同的方法。</p></blockquote><h3 id="2-5-4-示例代码"><a href="#2-5-4-示例代码" class="headerlink" title="2.5.4 示例代码"></a>2.5.4 示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo05</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Field[] getFields();</span><br><span class="hljs-comment">            * 获得所有的成员变量对应的Field对象，只能获得public的</span><br><span class="hljs-comment">        Field[] getDeclaredFields();</span><br><span class="hljs-comment">            * 获得所有的成员变量对应的Field对象，包含private的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c  = Student.class;<br>        <span class="hljs-comment">// 获得所有的成员变量对应的Field对象</span><br>        <span class="hljs-comment">// Field[] fields = c.getFields();</span><br>        <span class="hljs-comment">// 获得所有的成员变量对应的Field对象，包括private</span><br>        Field[] fields = c.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field f: fields) &#123;<br>            System.out.println(f);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Field getField(String name);</span><br><span class="hljs-comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span><br><span class="hljs-comment">        Field getDeclaredField(String name);</span><br><span class="hljs-comment">            *  根据成员变量名获得对应Field对象，包含private修饰的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c  = Student.class;<br>        <span class="hljs-comment">// 创建对象</span><br>        Object obj = c.newInstance();<br>        <span class="hljs-comment">// 获得成员变量name对应的Field对象</span><br>        Field f = c.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// 给成员变量name赋值</span><br>        <span class="hljs-comment">// 给指定对象obj的name属性赋值为jack</span><br>        f.set(obj,<span class="hljs-string">&quot;jack&quot;</span>);<br><br>        <span class="hljs-comment">// 获得指定对象obj成员变量name的值</span><br>        System.out.println(f.get(obj)); <span class="hljs-comment">// jack</span><br>        <span class="hljs-comment">// 获得成员变量的名字</span><br>        System.out.println(f.getName()); <span class="hljs-comment">// name</span><br><br><br>        <span class="hljs-comment">// 给成员变量gender赋值</span><br>        <span class="hljs-comment">// 获得成员变量gender对应的Field对象</span><br>        Field f1 = c.getDeclaredField(<span class="hljs-string">&quot;gender&quot;</span>);<br>        <span class="hljs-comment">// 暴力反射</span><br>        f1.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 给指定对象obj的gender属性赋值为男</span><br>        f1.set(obj,<span class="hljs-string">&quot;男&quot;</span>);<br><br>        System.out.println(obj);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章-注解"><a href="#第三章-注解" class="headerlink" title="第三章 注解"></a>第三章 注解</h1><h2 id="3-1-注解的概述"><a href="#3-1-注解的概述" class="headerlink" title="3.1 注解的概述"></a>3.1 注解的概述</h2><h3 id="3-1-1-注解的概念"><a href="#3-1-1-注解的概念" class="headerlink" title="3.1.1 注解的概念"></a>3.1.1 注解的概念</h3><ul><li><p>注解是JDK1.5的新特性。</p></li><li><p>注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。</p></li><li><p>标记(注解)可以加在包，类，字段，方法，方法参数以及局部变量上。</p></li><li><p>注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。</p><h6 id="注解-Annotation-相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种-标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。"><a href="#注解-Annotation-相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种-标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。" class="headerlink" title="注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种    标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。"></a><em>注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种    标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。</em></h6></li></ul><h3 id="3-1-2-注解的作用"><a href="#3-1-2-注解的作用" class="headerlink" title="3.1.2 注解的作用"></a>3.1.2 注解的作用</h3><p> <strong>注解的作用就是给程序带入参数。</strong></p><p>以下几个常用操作中都使用到了注解：</p><ol><li><p><strong>生成帮助文档</strong>：**@author和@version**</p><ul><li><p><strong>@author</strong>：用来标识作者姓名。</p></li><li><p><strong>@version</strong>：用于标识对象的版本号，适用范围：文件、类、方法。</p><ul><li><p>使用**@author和@version<strong>注解就是告诉</strong>Javadoc工具**在生成帮助文档时把作者姓名和版本号也标记在文档中。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E6%B3%A8%E8%A7%A3_1_20210403.png"></p></li></ul></li></ul></li><li><p><strong>编译检查</strong>：**@Override**</p><ul><li><p><strong>@Override</strong>：用来修饰方法声明。</p><ul><li>用来告诉<strong>编译器</strong>该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。如下图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E6%B3%A8%E8%A7%A3_2_20210403.png"></p></li></ul></li><li><p><strong>框架的配置(框架=代码+配置)</strong></p><ul><li>具体使用请关注框架课程的内容的学习。</li></ul></li></ol><h3 id="3-1-3-常见注解"><a href="#3-1-3-常见注解" class="headerlink" title="3.1.3 常见注解"></a>3.1.3 常见注解</h3><ol><li><strong>@author</strong>：用来标识作者名，eclipse开发工具默认的是系统用户名。</li><li><strong>@version</strong>：用于标识对象的版本号，适用范围：文件、类、方法。</li><li><strong>@Override</strong> ：用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。</li></ol><h2 id="3-2-自定义注解"><a href="#3-2-自定义注解" class="headerlink" title="3.2 自定义注解"></a>3.2 自定义注解</h2><h3 id="3-2-1-定义格式"><a href="#3-2-1-定义格式" class="headerlink" title="3.2.1 定义格式"></a>3.2.1 定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名&#123;<br><br>&#125;<br>如：定义一个名为Student的注解<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Student &#123;<br><br>&#125; <br></code></pre></td></tr></table></figure><h3 id="3-2-2-注解的属性"><a href="#3-2-2-注解的属性" class="headerlink" title="3.2.2 注解的属性"></a>3.2.2 注解的属性</h3><ol><li><p><strong>属性的格式</strong></p><ul><li><strong>格式1：数据类型 属性名();</strong></li><li><strong>格式2：数据类型 属性名() default 默认值;</strong></li></ul></li><li><p><strong>属性定义示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 姓名</span><br><span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 年龄</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 18</span>;<br><span class="hljs-comment">// 爱好</span><br>String[] hobby();<br></code></pre></td></tr></table></figure></li><li><p><strong>属性适用的数据类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">* 八种数据数据类型(<span class="hljs-keyword">int</span>，<span class="hljs-keyword">short</span>，<span class="hljs-keyword">long</span>，<span class="hljs-keyword">double</span>，<span class="hljs-keyword">byte</span>，<span class="hljs-keyword">char</span>，<span class="hljs-keyword">boolean</span>，<span class="hljs-keyword">float</span>)<br>* String，Class，注解类型，枚举类<br>* 以上类型的数组形式<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-3-使用自定义注解"><a href="#3-3-使用自定义注解" class="headerlink" title="3.3 使用自定义注解"></a>3.3 使用自定义注解</h2><h3 id="3-3-1-定义和注解"><a href="#3-3-1-定义和注解" class="headerlink" title="3.3.1 定义和注解"></a>3.3.1 定义和注解</h3><ol><li><strong>定义一个注解：Book</strong><ul><li>包含属性：String value()   书名</li><li>包含属性：double price()  价格，默认值为 100</li><li>包含属性：String[] authors() 多位作者    </li></ul></li><li>代码实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Book &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 100</span>;<br>    String[] authros();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-2-使用注解"><a href="#3-3-2-使用注解" class="headerlink" title="3.3.2 使用注解"></a>3.3.2 使用注解</h3><ol><li><strong>定义类在成员方法上使用Book注解</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><ol start="2"><li>使用注意事项<ul><li>如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。</li><li>如果属性没有默认值，那么在使用注解时一定要给属性赋值。 </li></ul></li></ol><h3 id="3-3-3-特殊属性value"><a href="#3-3-3-特殊属性value" class="headerlink" title="3.3.3 特殊属性value"></a>3.3.3 特殊属性value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    特殊属性value</span><br><span class="hljs-comment">        * 如果注解中只有一个属性且名字叫value，则在使用该注解时可以直接给该属性赋值，而不需要给出属性名。</span><br><span class="hljs-comment">        * 如果注解中除了value属性之外还有其他属性且只要有一个属性没有默认值，则在给属性赋值时</span><br><span class="hljs-comment">            value属性名也不能省略了。</span><br><span class="hljs-comment">    小结：如果注解中只有一个属性时，一般都会将该属性名命名为value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@interface</span> TestA&#123;<br>   String[] value();<br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 100</span>;<br>   <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@interface</span> TestB&#123;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@TestB(name = &quot;zzz&quot;)</span><br><span class="hljs-meta">@TestA(name = &quot;yyy&quot;,value = &#123;&quot;xxx&quot;,&quot;xxx&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationDemo02</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-注解之元注解"><a href="#3-4-注解之元注解" class="headerlink" title="3.4 注解之元注解"></a>3.4 注解之元注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">元注解概述<br>    * Java官方提供的注解<br>    * 用来定义注解的注解<br>    * 任何官方提供的非元注解的定义都使用到了元注解。<br><br>常用的元注解<br>    * <span class="hljs-meta">@Target</span><br>        * 作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。<br>        * 可使用的值定义在ElementType枚举类中，常用值如下<br>            TYPE，类，接口<br>            FIELD, 成员变量<br>            METHOD, 成员方法<br>            PARAMETER, 方法参数<br>            CONSTRUCTOR, 构造方法<br>            LOCAL_VARIABLE, 局部变量<br><br>    * <span class="hljs-meta">@Retention</span><br>        * 作用：用来标识注解的生命周期(有效范围)<br>        * 可使用的值定义在RetentionPolicy枚举类中，常用值如下<br>            * SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在<br>            * CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值<br>            * RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段<br></code></pre></td></tr></table></figure><h2 id="3-5-注解解析"><a href="#3-5-注解解析" class="headerlink" title="3.5 注解解析"></a>3.5 注解解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">什么是注解解析<br>      * 使用Java技术获得注解上数据的过程则称为注解解析。<br>  与注解解析相关的接口<br>      * Annotation: 注解类，该类是所有注解的父类。<br>      * AnnotatedElement:该接口定义了与注解解析相关的方法<br>           <span class="hljs-function">T <span class="hljs-title">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span> 根据注解类型获得对应注解对象</span><br><span class="hljs-function">           Annotation[]<span class="hljs-title">getAnnotations</span><span class="hljs-params">()</span></span><br><span class="hljs-function">              * 获得当前对象上使用的所有注解，返回注解数组，包含父类继承的</span><br><span class="hljs-function">           Annotation[]<span class="hljs-title">getDeclaredAnnotations</span><span class="hljs-params">()</span></span><br><span class="hljs-function">              * 获得当前对象上使用的所有注解，返回注解数组,只包含本类的</span><br><span class="hljs-function">           <span class="hljs-keyword">boolean</span><span class="hljs-title">isAnnotationPresent</span><span class="hljs-params">(Class&lt;Annotation&gt; annotationClass)</span></span><br><span class="hljs-function">              * 判断当前对象是否使用了指定的注解，如果使用了则返回<span class="hljs-keyword">true</span>，否则<span class="hljs-keyword">false</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">      获取注解数据的原理</span><br><span class="hljs-function">          * 注解作用在哪个成员上就会得该成员对应的对象来获得注解</span><br><span class="hljs-function">              * 比如注解作用成员方法，则要获得该成员方法对应的Method对象</span><br><span class="hljs-function">              * 比如注解作用在类上，则要该类的Class对象</span><br><span class="hljs-function">              * 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象。</span><br><span class="hljs-function">          * Field,Method,Constructor，Class等类都是实现了AnnotatedElement接口</span><br></code></pre></td></tr></table></figure><h4 id="3-5-4-1-需求说明"><a href="#3-5-4-1-需求说明" class="headerlink" title="3.5.4.1 需求说明"></a>3.5.4.1 需求说明</h4><ol><li>定义注解Book，要求如下：<ul><li>包含属性：String value()   书名</li><li>包含属性：double price()  价格，默认值为 100</li><li>包含属性：String[] authors() 多位作者  </li><li>限制注解使用的位置：类和成员方法上</li><li>指定注解的有效范围：RUNTIME</li></ul></li><li>定义BookStore类，在类和成员方法上使用Book注解</li><li>定义TestAnnotation测试类获取Book注解上的数据</li></ol><h4 id="3-5-4-2-代码实现"><a href="#3-5-4-2-代码实现" class="headerlink" title="3.5.4.2 代码实现"></a>3.5.4.2 代码实现</h4><ol><li><strong>注解Book</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Book &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 100</span>;<br>    String[] authros();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>BookShelf类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Book(value = &quot;红楼梦&quot;,authros = &#123;&quot;曹雪芹&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookShelf</span>  </span>&#123;<br><br>    <span class="hljs-meta">@Book(value = &quot;西游记&quot;,authros = &#123;&quot;吴承恩&quot;,&quot;白求恩&quot;&#125;,price = 200)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBook</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>TestAnnotation类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    什么是注解解析</span><br><span class="hljs-comment">        * 使用Java技术获得注解上数据的过程则称为注解解析。</span><br><span class="hljs-comment">    与注解解析相关的接口</span><br><span class="hljs-comment">        * Annotation: 注解类，该类是所有注解的父类。</span><br><span class="hljs-comment">        * AnnotatedElement:该接口定义了与注解解析相关的方法</span><br><span class="hljs-comment">             T getAnnotation(Class&lt;T&gt; annotationClass) 根据注解类型获得对应注解对象</span><br><span class="hljs-comment">             Annotation[]getAnnotations()</span><br><span class="hljs-comment">                * 获得当前对象上使用的所有注解，返回注解数组，包含父类继承的</span><br><span class="hljs-comment">             Annotation[]getDeclaredAnnotations()</span><br><span class="hljs-comment">                * 获得当前对象上使用的所有注解，返回注解数组,只包含本类的</span><br><span class="hljs-comment">             booleanisAnnotationPresent(Class&lt;Annotation&gt; annotationClass)</span><br><span class="hljs-comment">                * 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        获取注解数据的原理</span><br><span class="hljs-comment">            * 注解作用在哪个成员上就会得该成员对应的对象来获得注解</span><br><span class="hljs-comment">                * 比如注解作用成员方法，则要获得该成员方法对应的Method对象</span><br><span class="hljs-comment">                * 比如注解作用在类上，则要该类的Class对象</span><br><span class="hljs-comment">                * 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象。</span><br><span class="hljs-comment">            * Field,Method,Constructor，Class等类都是实现了AnnotatedElement接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationDemo04</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        获得类上使用的注解数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = BookShelf.class;<br>        <span class="hljs-comment">// 判断类上是否使用Book注解</span><br>        <span class="hljs-keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;<br>            <span class="hljs-comment">// 根据注解的Class对象获得对应的注解对象</span><br>            Book annotation = (Book) c.getAnnotation(Book.class);<br>            <span class="hljs-comment">// 获得书名</span><br>            System.out.println(annotation.value());<br>            <span class="hljs-comment">// 获得作者</span><br>            System.out.println(Arrays.toString(annotation.authros()));<br>            <span class="hljs-comment">// 获得价格</span><br>            System.out.println(annotation.price());<br>        &#125;<br>        <span class="hljs-comment">// 获得当前对象上使用的所有注解，返回注解数组</span><br>        <span class="hljs-comment">// Annotation[] annotations = c.getAnnotations();</span><br>        Annotation[] annotations = c.getDeclaredAnnotations();<br>        System.out.println(Arrays.toString(annotations));<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       获得成员方法上注解的数据</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = BookShelf.class;<br>        <span class="hljs-comment">// 获得成员方法对应的Method对象</span><br>        Method m = c.getMethod(<span class="hljs-string">&quot;showBook&quot;</span>);<br>        <span class="hljs-comment">// 根据注解的Class对象获得对应的注解对象</span><br>        Book annotation = m.getAnnotation(Book.class);<br>        <span class="hljs-comment">// 获得书名</span><br>        System.out.println(annotation.value());<br>        <span class="hljs-comment">// 获得作者</span><br>        System.out.println(Arrays.toString(annotation.authros()));<br>        <span class="hljs-comment">// 获得价格</span><br>        System.out.println(annotation.price());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-注解案例"><a href="#3-6-注解案例" class="headerlink" title="3.6 注解案例"></a>3.6 注解案例</h2><h3 id="3-6-1-案例说明"><a href="#3-6-1-案例说明" class="headerlink" title="3.6.1 案例说明"></a>3.6.1 案例说明</h3><ul><li>模拟Junit测试的@Test</li></ul><h3 id="3-6-2-案例分析"><a href="#3-6-2-案例分析" class="headerlink" title="3.6.2 案例分析"></a>3.6.2 案例分析</h3><ol><li>模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。</li><li>然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。</li><li>最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行。</li></ol><h3 id="3-6-3-案例代码"><a href="#3-6-3-案例代码" class="headerlink" title="3.6.3 案例代码"></a>3.6.3 案例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTest &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tests01</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test01&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tests02</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test02&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@MyTest</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tests03</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test03&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pkxing</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span> com.itheima</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/6/23  下午9:10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationDemo05</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得Class对象</span><br>        Class c = TestMyTest.class;<br>        Object obj = c.newInstance();<br>        <span class="hljs-comment">// 获得所有成员方法</span><br>        Method[] methods = c.getMethods();<br>        <span class="hljs-keyword">for</span>(Method m:methods)&#123;<br>            <span class="hljs-comment">// 判断m方法是否使用了MyTest注解</span><br>            <span class="hljs-keyword">if</span>(m.isAnnotationPresent(MyTest.class))&#123;<br>                <span class="hljs-comment">// 调用方法</span><br>                m.invoke(obj);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章-动态代理"><a href="#第四章-动态代理" class="headerlink" title="第四章 动态代理"></a>第四章 动态代理</h1><h2 id="4-1-代理模式【Proxy-Pattern】"><a href="#4-1-代理模式【Proxy-Pattern】" class="headerlink" title="4.1 代理模式【Proxy Pattern】"></a>4.1 代理模式【Proxy Pattern】</h2><p>​            为什么要有“代理”？生活中就有很多例子，例如委托业务等等，<strong>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事</strong>，这才是“代理”存在的原因。例如，我现在需要出国，但是我不愿意自己去办签证、预定机票和酒店（觉得麻烦 ，那么就可以找旅行社去帮我办，这时候旅行社就是代理，而我自己就是被代理了。</p><h2 id="4-2-动态代理概述"><a href="#4-2-动态代理概述" class="headerlink" title="4.2  动态代理概述"></a>4.2  动态代理概述</h2><p>​            动态代理简单来说是：<strong>拦截对真实对象方法的直接访问，增强真实对象方法的功能</strong></p><p>​            动态代理详细来说是：代理类在程序运行时创建的代理对象被称为动态代理，也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。也就是说你想获取哪个对象的代理，动态代理就会动态的为你生成这个对象的代理对象。<strong>动态代理可以对被代理对象的方法进行增强</strong>，<strong>可以在不修改方法源码的情况下，增强被代理对象方法的功能</strong>，<strong>在方法执行前后做任何你想做的事情</strong>。动态代理技术都是在框架中使用居多，例如：Struts1、Struts2、Spring和Hibernate等后期学的一些主流框架技术中都使用了动态代理技术。</p><h2 id="4-3-案例引出"><a href="#4-3-案例引出" class="headerlink" title="4.3 案例引出"></a>4.3 案例引出</h2><p>​    现在，假设我们要实现这样的需求：在企业的大型系统中，每个业务层方法的执行，都需要有对应的日志记录，比如这个方法什么时候调用完成的，耗时多久等信息，根据这些日志信息，我们可以看到系统执行的情况，尤其是在系统出现错误的时候，这些日志信息就显得尤为重要了。现在有一种实现思路是这样的，业务层实现类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SchoolService</span></span>&#123;<br>     <span class="hljs-function">String <span class="hljs-title">login</span><span class="hljs-params">(String loginName, String passWord)</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">getAllClazzs</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> class SchoolServiceImpl implements SchoolService </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String loginName, String passWord)</span> </span>&#123;<br><br><span class="hljs-comment">// 方法执行的开始时间点</span><br><span class="hljs-keyword">long</span> startTimer = System.currentTimeMillis();<br><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(passWord))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;登录异常&quot;</span>);<br>&#125;<br><span class="hljs-keyword">long</span> endTimer = System.currentTimeMillis();<br><span class="hljs-comment">// 在什么时刻执行完，花费了多长时间完成</span><br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;login方法执行-&gt;&quot;</span>+sdf.format(endTimer)+<span class="hljs-string">&quot;，耗时：&quot;</span>+(endTimer - startTimer));<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录名称或者密码不正确&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAllClazzs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 时间点</span><br><span class="hljs-keyword">long</span> startTimer = System.currentTimeMillis();<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回了所有的班级(1班，2班，3班)&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;查询班级异常&quot;</span>);<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-keyword">long</span> endTimer = System.currentTimeMillis();<br><span class="hljs-comment">// 在什么时刻执行完，花费了多长时间完成</span><br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;getAllClazzs方法执行-&gt;&quot;</span>+sdf.format(endTimer)+<span class="hljs-string">&quot;，耗时：&quot;</span>+(endTimer - startTimer));<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>.</p><p>​        我们在业务层的方法每次执行的时候都去记录了开始时间和结束时间，这样虽然可以记录每个方法运行的截止时间和耗时情况，但是代码显得很臃肿，这些日记记录代码本身也是与业务功能无关的代码。</p><h2 id="4-4-使用动态代理优化代码"><a href="#4-4-使用动态代理优化代码" class="headerlink" title="4.4 使用动态代理优化代码"></a>4.4 使用动态代理优化代码</h2><p>​    <strong>那么有没有一种方式可以解决这个问题呢？</strong></p><p>​        <strong>动态代理就是解决此类问题非常好的实现手段，通过动态代理我们可以为该业务层实现类对象提供一个动态的代理对象。该代理对象，可以为实现类的所有方法进行代理，并对代理的方法功能进行增强。也就是说只要调用了被代理实现类对象的方法，该方法的执行会先进入到代理对象中去，代理对象可以在该方法执行前记录开始时间，然后去触发该方法的执行，在方法执行完成以后再由代理对象去记录结束时间然后计算时间差作为日志记录，因为方法的日记记录由代理完成了，所以被代理对象的方法就无需自己单独记录日志操作了。这样就产生了一种非常好的设计模型。</strong></p><p>现在我们来使用动态代理写一个日志记录的代理类：</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogProxy</span> </span>&#123;<br><span class="hljs-comment">// 提供一个方法，用于生产需要被代理对象的代理对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj<br>.getClass().getInterfaces(), <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-comment">// 先记录开始时间点</span><br><span class="hljs-keyword">long</span> startTimer = System.currentTimeMillis();<br><span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">// 真正去触发被代理对象中该方法的执行</span><br><span class="hljs-keyword">return</span> method.invoke(obj, args);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">long</span> endTimer = System.currentTimeMillis();<br><span class="hljs-comment">// 在什么时刻执行完，花费了多长时间完成</span><br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<br><span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行-&gt;&quot;</span><br>+ sdf.format(endTimer) + <span class="hljs-string">&quot;，耗时：&quot;</span><br>+ (endTimer - startTimer));<br>&#125;<br>&#125;<br>&#125;);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-重点类和方法"><a href="#4-5-重点类和方法" class="headerlink" title="4.5 重点类和方法"></a>4.5 重点类和方法</h2><p>在上述代码中 getProxy 方法即是用于获取某个实现类对象的一个代理对象。在该代码中，如果要了解 Java 动态代理的机制，首先需要了解以下相关的类或接口：</p><p>java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一个静态方法来为一组接口的实现类动态地生成代理类及其对象。</p><p><strong>newProxyInstance方法的三个参数的详解:</strong></p><p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class[] interfaces, InvocationHandler h)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">1、obj.<span class="hljs-title">getClass</span><span class="hljs-params">()</span>.<span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span>目标对象通过getClass方法获取类的所有信息后，调用<span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> 方法来获取类加载器。获取类加载器后，可以通过这个类型的加载器，在程序运行时，将生成的代理类加载到JVM即Java虚拟机中，以便运行时需要！ </span><br><span class="hljs-function"></span><br><span class="hljs-function">2、obj.<span class="hljs-title">getClass</span><span class="hljs-params">()</span>.<span class="hljs-title">getInterfaces</span><span class="hljs-params">()</span>获取被代理类的所有接口信息，以便于生成的代理类可以具有代理类接口中的所有方法。 </span><br><span class="hljs-function"></span><br><span class="hljs-function">3、InvocationHandler 这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类方法的处理以及访问.</span><br></code></pre></td></tr></table></figure><p><strong>invoke方法的参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">1、Object proxy生成的代理对象，在这里不是特别的理解这个对象，但是个人认为是已经在内存中生成的proxy对象。 </span><br><span class="hljs-function">2、Method method：被代理的对象中被代理的方法的一个抽象。</span><br><span class="hljs-function">3、Object[] args：被代理方法中的参数。这里因为参数个数不定，所以用一个对象数组来表示。</span><br></code></pre></td></tr></table></figure><p>​    代理类定义完成以后业务层实现类的方法就无需再自己申明日记记录的代码了，因为代理对象会帮助做日志记录，修改后实现类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SchoolService</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String loginName, String passWord)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(passWord))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;登录异常&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录名称或者密码不正确&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAllClazzs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回了所有的班级(1班，2班，3班)&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;查询班级异常&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开始使用动态代理去访问方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 获取业务层实现类对象的代理对象，那么业务层实现类对象就会被代理了</span><br>SchoolService schoolService = (SchoolService) LogProxy.getProxy(<span class="hljs-keyword">new</span> SchoolServiceImpl());<br><br>System.out.println(schoolService.login(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;1234256&quot;</span>));<br><br>System.out.println(schoolService.getAllClazzs());<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        此代码中业务层对象已经是被代理的了，那么以后调用业务层对象的方法时，方法的调用会先被代理对象处理，代理会先记录方法执行的开始时间，然后通过method.invoke(obj, args)去真正触发该方法的执行，接下来代理对象进行方法结束时间的记录和日志的输出即可。这样整个过程就通过代理完美的实现了。</p><h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h2><p>动态代理非常的灵活，可以为任意的接口实现类对象做代理</p><p>动态代理可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，</p><p>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。<br>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</p><p>动态代理同时也提高了开发效率。</p><p>缺点：只能针对接口的实现类做代理对象，普通类是不能做代理对象的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL_Join优化</title>
    <link href="/2021/04/01/MySQL_Join%E4%BC%98%E5%8C%96/"/>
    <url>/2021/04/01/MySQL_Join%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-Join优化"><a href="#MySQL-Join优化" class="headerlink" title="MySQL_Join优化"></a>MySQL_Join优化</h1><h2 id="1-Simple-Nested-Loop-Join"><a href="#1-Simple-Nested-Loop-Join" class="headerlink" title="1. Simple Nested-Loop Join"></a>1. Simple Nested-Loop Join</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_join_1_20210401.png"></p><ul><li><p>r为驱动表，s为匹配表，可以看到从r中分别取出每一个记录区匹配s表的列，然后合并数据，对s表进行r表的行数次访问，对数据库开箱比较大</p></li><li><p>建议小表驱动大表</p></li></ul><h2 id="2-Index-Nested-Loop-Join"><a href="#2-Index-Nested-Loop-Join" class="headerlink" title="2. Index Nested-Loop Join"></a>2. Index Nested-Loop Join</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_join_2_20210401.png"></p><ul><li><p>这个要求非驱动表（s）上有索引，可以通过索引来减少比较，加速查询。</p></li><li><p>在查询时，驱动表（r）会根据关联字段的索引进行查找，当在索引上找到符合的值，再回表进行查询，也就是只有当匹配到索引以后才会进行回表查询。</p></li><li><p>如果非驱动表（s）的关联键是主键的话，性能会非常高，如果不是主键的话，要进行多次回表查询，先关联索引，然后根据二级索引的主键ID进行回表操作，性能上比索引是主键要慢</p></li></ul><h2 id="3-Block-Nested-Loop-Join"><a href="#3-Block-Nested-Loop-Join" class="headerlink" title="3. Block Nested-Loop Join"></a>3. Block Nested-Loop Join</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_join_3_20210401.png"></p><p>如果有索引，会选取第二种方式进行join，但如果join列没有索引，就会采用Block Nested-Loop Join。可以看到中间有个join buffer缓冲区，是将驱动表的所有join相关的列都先缓存到join buffer中，然后批量于匹配表进行比配，将第一种多次比较合并为一次，降低了非驱动表（s）的访问频率。默认情况下join_buffer_size=256K，再查找的时候MySQL会将所有的需要的列缓存到join_buffer当中，包括select的列，而不是仅仅只缓存关联列。在一个有N个JOIN关联的SQL当中会在执行时候分配N-1个join_buffer。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的MVCC机制和锁</title>
    <link href="/2021/04/01/MySQL_MVCC%E6%9C%BA%E5%88%B6%E5%92%8C%E9%94%81/"/>
    <url>/2021/04/01/MySQL_MVCC%E6%9C%BA%E5%88%B6%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MVCC机制和锁"><a href="#MVCC机制和锁" class="headerlink" title="MVCC机制和锁"></a>MVCC机制和锁</h1><h2 id="1-当前读和快照读"><a href="#1-当前读和快照读" class="headerlink" title="1. 当前读和快照读"></a>1. 当前读和快照读</h2><p>MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以<strong>部分</strong>防止幻读, 而非完全防止。为什么是部分防止幻读, 而不是完全防止?</p><ul><li>效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!（可以再结合<a href="#demo">后面的解释</a>加以理解）</li><li>因为在innodb中的操作可以分为<code>当前读(current read)</code>和<code>快照读(snapshot read)</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_2_20210401.png"></p><p>innodb在RR级别中</p><ul><li><p>当前读通过record lock和gap lock实现的</p></li><li><p>快照读通过MVCC和undolog实现的</p></li></ul><p>innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读</p><h2 id="2-MVCC机制"><a href="#2-MVCC机制" class="headerlink" title="2. MVCC机制"></a>2. MVCC机制</h2><blockquote><p>MVCC是多版本并发控制</p></blockquote><p>MVCC可以主要参考文章对比着看：<a href="https://segmentfault.com/a/1190000012650596">https://segmentfault.com/a/1190000012650596</a></p><h3 id="2-1-行数据的后面三个字段"><a href="#2-1-行数据的后面三个字段" class="headerlink" title="2.1 行数据的后面三个字段"></a>2.1 行数据的后面三个字段</h3><ul><li><p>InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p></li><li><p>innodb存储引擎每次再进行数据插入的时候，数据必须要跟某一个索引列绑定在一起，这个索引列有一个选择的顺序： 主键 &gt; 唯一键 &gt; 自动生成6字节的rowid</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_1_20210401.png"></p><h3 id="2-2-undolog保证了原子性"><a href="#2-2-undolog保证了原子性" class="headerlink" title="2.2 undolog保证了原子性"></a>2.2 undolog保证了原子性</h3><p>事务中数据的历史版本保存在undolog，可以通过回滚指针实现事务回滚</p><p>事务提交后可以清除无效的历史数据</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_3_20210401.png"></p><h3 id="2-3-Read-view"><a href="#2-3-Read-view" class="headerlink" title="2.3 Read view"></a>2.3 Read view</h3><p>当前存在多个历史版本数据的时候，会涉及到一个可见性算法，来计算当前事务读取的是哪一个版本的历史数据</p><blockquote><p>read view:</p><p>当进行快照读的时候会生成一个事务id的列表，来保存不同的信息，通过这些星系来做可见性判断</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_4_20210401.png"></p><p>上面的id都是行数据后面三字段中的事务id</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_5_20210401.png"></p><p>MVCC中隔离级别RC和RR的区别：在于<strong>readview的生成时机</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_6_20210401.png"></p><h2 id="3-锁"><a href="#3-锁" class="headerlink" title="3. 锁"></a>3. 锁</h2><blockquote><p>MySQL锁的分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_7_20210401.png"></p><h3 id="3-1-三种行锁的区别"><a href="#3-1-三种行锁的区别" class="headerlink" title="3.1 三种行锁的区别"></a>3.1 三种行锁的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL_8_20210401.png"></p><h3 id="3-2-幻读"><a href="#3-2-幻读" class="headerlink" title="3.2 幻读"></a>3.2 幻读</h3><p><a id="demo">部分解决幻读的理解</a></p><p>如果全是快照读不会出现幻读（MVCC保证的）</p><p>如果全是当前读也是不会出现幻读的（记录锁和间隙锁保证的）</p><p>一个实例分析（出现幻读）：</p><ul><li>当前事务1先快照读（select）</li><li>随后事务2在当前事务1执行过程中插入或者删除行数据并成功提交</li><li>当前事务1又执行了<strong>当前读</strong>(如update)，发现突然突然增加或者减少了一行</li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MVCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存数据库双写不一致</title>
    <link href="/2021/04/01/Redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <url>/2021/04/01/Redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis缓存数据库双写不一致"><a href="#Redis缓存数据库双写不一致" class="headerlink" title="Redis缓存数据库双写不一致"></a>Redis缓存数据库双写不一致</h1><p>学习笔记</p><h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h2><h3 id="1-1-示例一"><a href="#1-1-示例一" class="headerlink" title="1.1 示例一"></a>1.1 示例一</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_9_20210331.png"></p><p>线程一：写数据库stock=10，之后发生卡顿或者延迟了很久才更新缓存</p><p>线程二：在线程一之后写数据库stock=6，然后更新了缓存stock=6</p><p>线程一：再线程二更新缓存结束后，卡顿或者延迟结束，更新缓存stock=10</p><p>结果：导致数据库stock=6，而缓存stock=10</p><p>解决方法：更新数据库之后删除缓存。</p><p>但是依然有问题，见示例二</p><h3 id="1-2-示例二"><a href="#1-2-示例二" class="headerlink" title="1.2 示例二"></a>1.2 示例二</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_10_20210331.png"></p><p>线程一：更新数据库stock=10，然后删除缓存</p><p>线程三：在线程一更新后查缓存，发现缓存为空；于是查数据库，发现为stock=10，此时发成卡顿或者延迟；</p><p>线程二：在线程三查数据库，更新缓存之前，重写了数据库stock=6，并删除缓存</p><p>线程三：卡顿或者延迟结束，更新缓存stock=10</p><p>结果：导致缓存stock = 10，数据库stock=6</p><p>我们可以发现更新数据库后删除缓存并没有解决双写不一致问题。</p><p>一些解决方案：</p><ul><li><p><strong>延迟双删</strong>（可靠性不高，且导致吞吐量下降，不推荐）</p><p>更新数据库，立刻删除缓存，然后sleep一段时间后再删一次缓存</p></li><li><p><strong>内存队列</strong>（并发问题串行化，实现复杂，性能不高，不推荐）</p><p>把同一个商品的CRUD操作都放在一个队列里面串行化执行</p></li><li><p><strong>分布式锁</strong>（并发问题串行化，实现简单，性能不高，<strong>推荐</strong>）</p><p>具体见我的上一篇<a href="http://lihengxu.cn/2021/03/31/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">blog</a></p></li></ul><h2 id="2-较好的解决方案"><a href="#2-较好的解决方案" class="headerlink" title="2. 较好的解决方案"></a>2. 较好的解决方案</h2><h3 id="2-1-读写锁（读多写少场景）"><a href="#2-1-读写锁（读多写少场景）" class="headerlink" title="2.1 读写锁（读多写少场景）"></a>2.1 读写锁（读多写少场景）</h3><p>分布式锁实现简单，但性能有待优化，我们可以通过读写锁来进一步提高性能，读共享，写互斥（排他）</p><ul><li><p>查询方法<code>getStock()</code>使用读锁</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_11_20210331.png"></p></li><li><p>更新方法<code>updateStock()</code>使用写锁</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_12._20210331.png"></p></li><li><p>这两个读改方法是互斥的</p></li><li><p>读写锁Redisson的底层实现</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_13._20210331.png"></p><h3 id="2-2-缓存设置超时清除（适用于缓存不追求绝对一致）"><a href="#2-2-缓存设置超时清除（适用于缓存不追求绝对一致）" class="headerlink" title="2.2 缓存设置超时清除（适用于缓存不追求绝对一致）"></a>2.2 缓存设置超时清除（适用于缓存不追求绝对一致）</h3><p>详情页面显示100，但是下单后发现已经（数据库库存为0）卖完了，其实并不影响业务逻辑，所以设置缓存失效时间就行了。</p><p>该方法没有较好的解决双写不一致问题，但是简单，且性能较好。</p><h3 id="2-3-分布式数据库（读多写多的场景）"><a href="#2-3-分布式数据库（读多写多的场景）" class="headerlink" title="2.3 分布式数据库（读多写多的场景）"></a>2.3 分布式数据库（读多写多的场景）</h3><p>如果写多的话，就已经不适合缓存了，所以直接就在数据库上操作了</p><p>如果MySQL扛不住高并发请求可以通过分布式数据库来改善，如TiDB</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁的深入理解</title>
    <link href="/2021/03/31/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/2021/03/31/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis分布式锁的深入理解"><a href="#Redis分布式锁的深入理解" class="headerlink" title="Redis分布式锁的深入理解"></a>Redis分布式锁的深入理解</h1><p>学习笔记</p><h2 id="1-高并发下的超卖bug"><a href="#1-高并发下的超卖bug" class="headerlink" title="1. 高并发下的超卖bug"></a>1. 高并发下的超卖bug</h2><p>先看一个简单的减库存代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson<br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> Redssion redisson;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/deduct_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>        <span class="hljs-keyword">if</span>(stock &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> realStock = stock -<span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key, value)</span><br>            System.out.println(<span class="hljs-string">&quot;扣减成功， 剩余库存：&quot;</span> + realStock);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;扣减失败， 剩余库存不足&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个问题，并发问题很明显</p><p>首先我们用传统的synchronized代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson<br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> Redssion redisson;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/deduct_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// synchronized代码块</span><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>            <span class="hljs-keyword">if</span>(stock &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> realStock = stock -<span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key, value)</span><br>                System.out.println(<span class="hljs-string">&quot;扣减成功， 剩余库存：&quot;</span> + realStock);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;扣减失败， 剩余库存不足&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然分布式部署情况下仍然存在严重的并发问题</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_1_20210331.png"></p><p>只能锁一个tomcat服务器的，所以我们需要通过Redis的分布式锁来解决并发问题</p><h2 id="2-分布式锁的使用"><a href="#2-分布式锁的使用" class="headerlink" title="2. 分布式锁的使用"></a>2. 分布式锁的使用</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_2_20210331.png"></p><h3 id="2-1-基本使用（入门使用）"><a href="#2-1-基本使用（入门使用）" class="headerlink" title="2.1 基本使用（入门使用）"></a>2.1 基本使用（入门使用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson<br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> Redssion redisson;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/deduct_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span></span>&#123;<br>        String lockKey = <span class="hljs-string">&quot;product_100&quot;</span>;<br>        <span class="hljs-comment">// 1.设置分布式锁</span><br>        Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, <span class="hljs-string">&quot;xlh&quot;</span>); <span class="hljs-comment">//jedis.setnx(k,v)</span><br>        <br>        <span class="hljs-keyword">if</span>(!result)&#123;<br>            <span class="hljs-comment">// 2.1 如果设置不成功，这表示别人在使用</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error_code&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.2 如果设置成功，这进行库存扣除操作</span><br>        <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>        <span class="hljs-keyword">if</span>(stock &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> realStock = stock -<span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key, value)</span><br>            System.out.println(<span class="hljs-string">&quot;扣减成功， 剩余库存：&quot;</span> + realStock);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;扣减失败， 剩余库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3. 释放锁</span><br>        stringRedisTemplate.delete(lockKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-改进代码"><a href="#2-2-改进代码" class="headerlink" title="2.2 改进代码"></a>2.2 改进代码</h3><p>分析基础代码：显然系统在加锁后抛异常，或者中断，就无法释放锁</p><p>解决：</p><ul><li>抛异常用try-catch-finally解决</li><li>系统中断、宕机，可以通过给锁设置存活时间，超时自动解锁<font color="FF0000">(注意要在设置锁的同时设置生命长度，保证原子性)</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson<br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> Redssion redisson;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/deduct_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span></span>&#123;<br>        String lockKey = <span class="hljs-string">&quot;product_100&quot;</span>;<br>        <span class="hljs-comment">// 1.设置分布式锁</span><br>        <span class="hljs-comment">// Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;xlh&quot;); //jedis.setnx(k,v)</span><br>        <span class="hljs-comment">// stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS); // 给锁设置10s的有效时间（但任然有风险在执行本句前宕机）</span><br>        Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, <span class="hljs-string">&quot;xlh&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-keyword">if</span>(!result)&#123;<br>            <span class="hljs-comment">// 2.1 如果设置不成功，这表示别人在使用</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error_code&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 2.2 如果设置成功，这进行库存扣除操作</span><br>            <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>            <span class="hljs-keyword">if</span>(stock &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> realStock = stock -<span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key, value)</span><br>                System.out.println(<span class="hljs-string">&quot;扣减成功， 剩余库存：&quot;</span> + realStock);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;扣减失败， 剩余库存不足&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span>&#123;<br>             <span class="hljs-comment">// 3. 释放锁</span><br>        stringRedisTemplate.delete(lockKey);<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-再次优化"><a href="#2-3-再次优化" class="headerlink" title="2.3 再次优化"></a>2.3 再次优化</h3><ul><li><p>分析优化代码：我们发现我们设置锁的时长是固定的，这是有问题的</p></li><li><p>举个例子：设置锁持续时长10s</p><ul><li>线程a：加锁后，执行了15s到释放锁，释放线程b加的锁</li><li>线程b：在11s时来访问，发现没有锁，加锁</li></ul><p>可以发现有着非常严重的并发问题，锁有可能永久失效</p></li><li><p>解决方法：</p><ul><li>给锁的value设为当前client特有的值，在释放锁匙时判断，只释放自己加的锁<font color="FF0000">（判断和释放也要保证原子性，不然判断成功后，线程卡顿一下几率极小，锁自动释放，然后到真正释放锁的时候可能释放的不是自己的锁）</font></li><li>线程执行时间超时，锁自动释放，通过<strong>锁续命</strong>保证线程未结束时，锁一直延时</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson<br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> Redssion redisson;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/deduct_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span></span>&#123;<br>        String lockKey = <span class="hljs-string">&quot;product_100&quot;</span>;<br>        <span class="hljs-comment">// 为当前线程设置一个UUID给锁的值，用于判断是不是自己上的锁，避免删除别人的锁</span><br>        String clientId = UUID.randomUUID().toString();          <br>        Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clientId, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-keyword">if</span>(!result)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error_code&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>            <span class="hljs-keyword">if</span>(stock &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> realStock = stock -<span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key, value)</span><br>                System.out.println(<span class="hljs-string">&quot;扣减成功， 剩余库存：&quot;</span> + realStock);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;扣减失败， 剩余库存不足&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">// 判断是不是自己加的锁(保证原子操作，所以下面的if需要继续改进)</span><br>            <span class="hljs-keyword">if</span>(clientId.equals(stringRedisTemplate.opsForValue().get(lockKey)))<br>        stringRedisTemplate.delete(lockKey);<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然锁续命和判断/释放锁的原子操作还没有实现</p><p>这里我们可以通过<a href="https://github.com/redisson">redisson</a>中间件来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson<br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> Redssion redisson;<br>    <br>    <span class="hljs-meta">@Autiwired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/deduct_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span></span>&#123;<br>        String lockKey = <span class="hljs-string">&quot;product_100&quot;</span>;<br>        <span class="hljs-keyword">if</span>(!result)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error_code&quot;</span>;<br>        &#125;<br>        <br>        Rlock redissonLock = redisson.getLock(lockKey);<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            redissonLock.lock(); <span class="hljs-comment">// setIfAbsent(lockKey, clientId, 10, TimeUnit.SECONDS)</span><br>            <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>            <span class="hljs-keyword">if</span>(stock &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> realStock = stock -<span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key, value)</span><br>                System.out.println(<span class="hljs-string">&quot;扣减成功， 剩余库存：&quot;</span> + realStock);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;扣减失败， 剩余库存不足&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span>&#123;<br>            redissonLock.unlock();<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Redisson实现分布式锁的流程</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_3_20210331.png"></p><h2 id="3-Redisson加锁分析"><a href="#3-Redisson加锁分析" class="headerlink" title="3. Redisson加锁分析"></a>3. Redisson加锁分析</h2><p>前面使用了redisson优化代码，我们可以分析源码</p><blockquote><p>通过lua脚本实现原子操作(redisson中有着大量的lua脚本代码)</p></blockquote><p>看看redisson底层的加锁代码，可以发现时通过Lua脚本实现的：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_4_20210331.png"></p><p>Redis在2.6推出了脚本功能，允许开发者使用<a href="https://segmentfault.com/a/1190000037518418"><strong>Lua语言</strong></a>编写脚本传到Redis中执行。</p><p>Lua脚本的好处有：</p><ul><li><strong>减少网络开销</strong>：<ul><li>本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少网络往返时延。<strong>这点和管道类似</strong>。</li></ul></li><li><strong>原子操作</strong>：<ul><li>Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。<strong>管道不是原子的，不过redis的批量操作命令（类似mset）是原子的</strong>。</li></ul></li><li><strong>代替redis的事务功能</strong>：<ul><li>redis自带的事务功能很鸡肋，报错不支持回滚，而redis的lua脚本几乎实现了常规的事务功能，支持报错回滚操作，官方推荐使用redis的事务功能可以用redis lua代替。</li></ul></li></ul><blockquote><p>注意：</p><p>不要再Lua脚本中出限死循环和耗时的运算，否则redis会阻塞，将不接受其他的命令，所以使用时要注意不能出限死循环，耗时的运算。redis时但进程、单线程执行脚本。管道不会阻塞redis。</p></blockquote><p>初始化<code>internalLockLeaseTime</code>是30s</p><p>然后外面有一个TimerTask的任务，每过<code>internalLockLeaseTime/3</code>执行一次（下面三张图是一个方法，凑合着看233）</p><p>下面就是递归锁续命</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_6_20210331.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_5_20210331.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_7_20210331.png"></p><h2 id="4-后续的问题"><a href="#4-后续的问题" class="headerlink" title="4.  后续的问题"></a>4.  后续的问题</h2><p>通过上面的分析我们使用redisson成功解决的分布式部署的并发问题。</p><p>其他的问题</p><ul><li>主从Redis锁失效问题<ul><li>redis主从结构，Master上了锁，但是还没有来得及给slave同步就挂了，slave变为master之后其他线程就能进来，又出现并发问题</li></ul></li><li>性能如何进一步优化<ul><li>分布式锁相当于是把并发问题串行化了，性能受到影响</li></ul></li></ul><h3 id="4-1-主从Redis锁失效问题"><a href="#4-1-主从Redis锁失效问题" class="headerlink" title="4.1 主从Redis锁失效问题"></a>4.1 主从Redis锁失效问题</h3><blockquote><p>解决方法1：使用zookeeper</p></blockquote><p><strong>Redis</strong>  vs  <strong>zookeeper</strong> </p><p>CAP原则：（A是可用性，C是一致性）</p><ul><li>redis更多的满足AP，性能更好</li><li>zookeeper更多的满足CP，一致性更好</li></ul><p>zookeeper如何保持更好的一致性的：</p><p>在集群中node节点的分布式锁同步到一半以上之后，才会回复客户端加锁成功（过半写）；在master挂掉之后，一定会选举同步成功的slave作为新master。</p><blockquote><p>解决方法2：Redlock（不推荐使用，很多小问题，比如回滚麻烦，性能低下）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_8_20210331.png"></p><p>redis节点没有主从关系，超过一半以上的加锁才算加锁成功；其中一个挂了也不会锁失效。</p><h3 id="4-2-性能优化"><a href="#4-2-性能优化" class="headerlink" title="4.2 性能优化"></a>4.2 性能优化</h3><p> 使用<strong>分段锁</strong>的思想</p><p>比如最开始库存是200个库存</p><p>把库存分成10个库存，一个key可以存20个，并发度提高了10倍。（底层比较复杂）</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类注意点</title>
    <link href="/2021/03/29/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2021/03/29/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="包装类的注意点"><a href="#包装类的注意点" class="headerlink" title="包装类的注意点"></a>包装类的注意点</h1><p>前言：</p><p>今天在刷<a href="https://leetcode-cn.com/problems/minimum-window-substring/">leetcode76</a>时候遇到一个奇怪的bug，发现是一个常见的笔试考题</p><p>补充（2021.05.03）：</p><p>其实就是一个享元模式的应用，以及常见面试考点，关于享元模式在<a href="">并发编程笔记</a>中有详细解释</p><h2 id="1-bug"><a href="#1-bug" class="headerlink" title="1. bug"></a>1. bug</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, length = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br>            <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(need.get(c) == window.get(c))&#123;<br>                    valid++;<br>                &#125; <br>            &#125;<br>            right++;<br><br>            <br>            <span class="hljs-keyword">while</span>(valid == need.size())&#123;<br>                <br>                <span class="hljs-keyword">if</span>(right - left &lt; length)&#123;<br>                    start = left;<br>                    length = right - left;<br>                &#125;<br><br>                c = s.charAt(left);<br>                <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>                    <span class="hljs-keyword">if</span>(window.get(c) == need.get(c))&#123;<br>                        valid--;<br>                    &#125; <br>                    window.put(c, window.get(c) - <span class="hljs-number">1</span>);<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + length);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题是滑动窗口的典型题目，但是我发现，<code>valid</code>在字符串较大的实例总是不能自增。</p><p>也就是在14行和30行的<code>window.get(c) == need.get(c)</code>判断始终不成立</p><h2 id="2-Integer源码分析"><a href="#2-Integer源码分析" class="headerlink" title="2. Integer源码分析"></a>2. Integer源码分析</h2><p>问题出在Integer包装类上，因为我们在hashmap中只能存放包装类，会把我们put的int类型自动装箱</p><p>我们可以看一下包装类的代码。</p><p>自动装箱调用valueOf方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>IntegerCache 的源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-built_in">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = <span class="hljs-number">-128</span>;<br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Integer</span> cache[];<br><br>    <span class="hljs-built_in">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>        <span class="hljs-keyword">String</span> integerCacheHighPropValue =<br>            sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, <span class="hljs-keyword">Integer</span>.MAX_VALUE - (-low) <span class="hljs-number">-1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br><br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> j = low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>(j++);<br><br>        <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        assert IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> IntegerCache() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察源码，我们可以发现，在[IntegerCache.low, IntegerCache.high]之间的int类型在装箱后放在IntegerCache.cache数组里面的，所以在此范围之间的Integer的引用是相同的，所以在[-127, 128]范围<code>==</code>的判断能够成立，而超过之后<code>==</code>判断失效。</p><p>补充：<strong>Double 和 Float 没有缓存机制，都是直接返回新的对象；Integer、Short、Byte、Character 有缓存机制</strong></p><h2 id="3-debug代码"><a href="#3-debug代码" class="headerlink" title="3. debug代码"></a>3. debug代码</h2><p>那么我们只要拆箱比较就好了，Integer转int使用Integer类的intValue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, length = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br>            <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>                window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// debug</span><br>                <span class="hljs-keyword">if</span>(need.get(c).intValue() == window.get(c).intValue())&#123;<br>                    valid++;<br>                &#125; <br>            &#125;<br>            right++;<br><br>            <span class="hljs-keyword">while</span>(valid == need.size())&#123;<br>                <br>                <span class="hljs-keyword">if</span>(right - left &lt; length)&#123;<br>                    start = left;<br>                    length = right - left;<br>                &#125;<br><br>                c = s.charAt(left);<br>                <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>                    <span class="hljs-comment">// debug</span><br>                    <span class="hljs-keyword">if</span>(window.get(c).intValue() == need.get(c).intValue())&#123;<br>                        valid--;<br>                    &#125; <br>                    window.put(c, window.get(c) - <span class="hljs-number">1</span>);<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + length);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-相关经典笔试题"><a href="#4-相关经典笔试题" class="headerlink" title="4. 相关经典笔试题"></a>4. 相关经典笔试题</h2><p>这里参考了<a href="https://blog.csdn.net/babycan5/article/details/81942230">帖子</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/babycan5/article/details/81942230">[1]</span></a></sup></p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">10</span>;<br>Integer b = <span class="hljs-number">20</span>;<br>Integer c = <span class="hljs-number">30</span>;<br>Integer d = <span class="hljs-number">30</span>;<br>Integer e = <span class="hljs-number">300</span>;<br>Integer f = <span class="hljs-number">300</span>;<br>Integer g = a + b;<br><br>c == d;<br>e == f;<br>c == g;<br>c == (a + b);<br>c.equals(a + b);<br></code></pre></td></tr></table></figure><p>结果：true、false、true、true、true</p><p><strong>第三个</strong>：由于运用了算术运算符(+)，因此右边的算式在进行计算之前会先调用 intVal() 方法进行拆箱，在进行相加，然后得到的结果30之后，由于前面是 Integer g，因此还会再调用 valueOf() 方法进行装箱。由于此时 cache() 数组中已经有了 30 了，因此直接指向缓存池中的 30 这个 Integer 对象。此时 c == g 比较的还是对象的地址是否相同</p><p><strong>第四个</strong>：由于右边是 a+b，包含算术运算，因此会调用 intVal() 方法，将左边的 c 进行拆箱，之后又分别对 a 和 b 进行拆箱，即一共调用了三次拆箱过程，<strong>最后比较的是数值大小，而不是地址</strong></p><p><strong>第五个</strong>：通过 equals 的源码看到，传入的参数需要是一个对象，这就意味着，和 equals 比较的时候，一定是装完箱之后的结果a + b 的时候，a 和 b 各自执行 intVal() 方法进行拆箱，完成相加的计算之后，再对计算出的结果执行 valueOf() 方法进行装箱，此时再传入 equals 方法进行比较。equals 比较两个对象的时候，直接比较两个值拆箱之后的结果，即比较的是数值，本例中两个数值相同，所以输出为 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>        <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">10</span>;<br>Integer b = <span class="hljs-number">20</span>;<br>Long g = <span class="hljs-number">30L</span>;<br>Long h = <span class="hljs-number">20L</span>;<br><br>g == (a + b);<br>g.equals(a + b);<br>g.equals(a + h);<br></code></pre></td></tr></table></figure><p>结果：true、false、true</p><p>和上面一样，同样是使用拆箱，第一题比较的拆完箱之后的值，但是需要注意的是，Integer 类型调用 Integer.valueOf 进行拆箱，而 Long 类型调用 Long.valueOf 进行拆箱</p><p>最后一个结果是 true，因为 a + h 会使小的精度转为大的精度，最终的 30 是 Long 类型的，因此结果是 true</p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Double i1 = <span class="hljs-number">100.0</span>;<br>Double i2 = <span class="hljs-number">100.0</span>;<br>Double i3 = <span class="hljs-number">200.0</span>;<br>Double i4 = <span class="hljs-number">200.0</span>;<br><br>i1 == i2<br>i3 == i4<br></code></pre></td></tr></table></figure><p>结果：false、false</p><p>Double没有缓存机制</p><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Boolean b1 = <span class="hljs-keyword">false</span>;<br>Boolean b2 = <span class="hljs-keyword">false</span>;<br>Boolean b3 = <span class="hljs-keyword">true</span>;<br>Boolean b4 = <span class="hljs-keyword">true</span>;<br><br>b1 == b2<br>b3 == b4<br>b1 == b3<br></code></pre></td></tr></table></figure><p>结果：true、true、false</p><p>为什么会这样呢？看一下 Boolean 的 valueOf() 的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (b ? TRUE : FALSE);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 TRUE 和 FALSE，代表两个静态成员属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean TRUE = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">true</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean FALSE = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>因此可以知道了，每次传入的 true 或 false，都是指向同一个 Boolean 对象，因此他们的引用肯定相同了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/babycan5/article/details/81942230">https://blog.csdn.net/babycan5/article/details/81942230</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>leetcode No.76<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见攻击HTTP协议的五大方式</title>
    <link href="/2021/03/28/HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5/"/>
    <url>/2021/03/28/HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="常见攻击HTTP协议的五大方式"><a href="#常见攻击HTTP协议的五大方式" class="headerlink" title="常见攻击HTTP协议的五大方式"></a>常见攻击HTTP协议的五大方式</h1><p><strong>http协议</strong>从诞生至今伴随着互联网走过了相当长的岁月，就在当下，http协议依旧是搭建网站的主流协议。http协议的存在有其特定的历史意义，但是面对如今日益严峻的安全问题，http协议的不安全性也越发暴露，下面列举常见的攻击http协议的五大方式。</p><h2 id="一-跨站脚本攻击-XSS"><a href="#一-跨站脚本攻击-XSS" class="headerlink" title="一.跨站脚本攻击(XSS)"></a>一.跨站脚本攻击(XSS)</h2><p>跨站脚本攻击(XSS，Cross-site scripting)是最常见和基本的攻击WEB网站的方法。攻击者在网页上发布包含攻击性代码的数据。当浏览者看到此网页时，特定的脚本就会以浏览者用户的身份和权限来执行。通过XSS可以比较容易地修改用户数据、窃取用户信息，以及造成其它类型的攻击，例如CSRF攻击。</p><h2 id="二-跨站请求伪造攻击-CSRF"><a href="#二-跨站请求伪造攻击-CSRF" class="headerlink" title="二. 跨站请求伪造攻击(CSRF)"></a>二. 跨站请求伪造攻击(CSRF)</h2><p>跨站请求伪造(CSRF，Cross-site request forgery)是另一种常见的攻击。攻击者通过各种方法伪造一个请求，模仿用户提交表单的行为，从而达到修改用户的数据，或者执行特定任务的目的。为了假冒用户的身份，CSRF攻击常常和XSS攻击配合起来做，但也可以通过其它手段，例如诱使用户点击一个包含攻击的链接。</p><h2 id="三-Http-Heads攻击"><a href="#三-Http-Heads攻击" class="headerlink" title="三.Http Heads攻击"></a>三.Http Heads攻击</h2><p>凡是用浏览器查看任何WEB网站，无论你的WEB网站采用何种技术和框架，都用到了HTTP协议.HTTP协议在Response header和content之间，有一个空行，即两组CRLF(0x0D 0A)字符。这个空行标志着headers的结束和content的开始。“聪明”的攻击者可以利用这一点。只要攻击者有办法将任意字符“注入”到headers中，这种攻击就可以发生。</p><p>以登陆为例:有这样一个url:</p><p><a href="http://localhost/login?page=http://localhost/index">http://localhost/login?page=http%3A%2F%2Flocalhost%2Findex</a></p><p>当登录成功以后，需要重定向回page参数所指定的页面。下面是重定向发生时的response headers.</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">302</span> Moved Temporarily<br><br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 17 Aug 2010 20:00:29 GMT<br><br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache mod_fcgid/2.3.5 mod_auth_passthrough/2.1 mod_bwlimited/1.4 FrontPage/5.0.2.2635<br><br><span class="hljs-attribute">Location</span><span class="hljs-punctuation">: </span>http://localhost/index<br></code></pre></td></tr></table></figure><p>假如把URL修改一下，变成这个样子：</p><p><a href="http://localhost/login?page=http://localhost/checkout%0D%0A%0D%0A%3Cscript%3Ealert(%27hello%27)%3C/script%3E">http://localhost/login?page=http%3A%2F%2Flocalhost%2Fcheckout%0D%0A%0D%0A%3Cscript%3Ealert%28%27hello%27%29%3C%2Fscript%3E</a></p><p>那么重定向发生时的reponse会变成下面的样子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">302</span> Moved Temporarily<br><br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 17 Aug 2010 20:00:29 GMT<br><br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache mod_fcgid/2.3.5 mod_auth_passthrough/2.1 mod_bwlimited/1.4 FrontPage/5.0.2.2635<br><br><span class="hljs-attribute">Location</span><span class="hljs-punctuation">: </span>http://localhost/checkout<br></code></pre></td></tr></table></figure><p>这个页面可能会意外地执行隐藏在URL中的javascript。类似的情况不仅发生在重定向(Location header)上，也有可能发生在其它headers中，如Set-Cookie header。这种攻击如果成功的话，可以做很多事，例如：执行脚本、设置额外的cookie(Set-Cookie: evil=value)等。</p><h2 id="四-Cookie攻击"><a href="#四-Cookie攻击" class="headerlink" title="四.Cookie攻击"></a>四.Cookie攻击</h2><p>通过Java Script非常容易访问到当前网站的cookie。你可以打开任何网站，然后在浏览器地址栏中输入：javascript:alert(doucment.cookie),立刻就可以看到当前站点的cookie(如果有的话)。攻击者可以利用这个特性来取得你的关键信息。例如，和XSS攻击相配合，攻击者在你的浏览器上执行特定的Java Script脚本，取得你的cookie。假设这个网站仅依赖cookie来验证用户身份，那么攻击者就可以假冒你的身份来做一些事情。</p><h2 id="五-重定向攻击"><a href="#五-重定向攻击" class="headerlink" title="五.重定向攻击"></a>五.重定向攻击</h2><p>最常用的攻击手段就是“钓鱼”。钓鱼攻击者，通常会发送给受害者一个合法链接，当链接被点击时，用户被导向一个似是而非的非法网站，从而达到骗取用户信任、窃取用户资料的目的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>转载自：<a href="https://freessl.wosign.com/1336.html">https://freessl.wosign.com/1336.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Network</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL的加密过程</title>
    <link href="/2021/03/28/SSL%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/03/28/SSL%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="SSL的加密过程"><a href="#SSL的加密过程" class="headerlink" title="SSL的加密过程"></a>SSL的加密过程</h1><blockquote><p><strong>SSL</strong>（Secure Socket Layer）安全套接字层：</p><p>SSL通过采用机密性、数据完整性、服务器鉴别和客户鉴别来强化TCP，经常用来为发生在HTTP之上的事务提供安全性。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="计算机网络自顶向下方法，第8章，使TCP连接安全：SSL">[1]</span></a></sup></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/SSL_1_20210328.jpg"></p><p><strong>HTTP + SSL = HTTPS</strong></p><h2 id="1-加密方法"><a href="#1-加密方法" class="headerlink" title="1. 加密方法"></a>1. 加密方法</h2><ul><li>对称加密</li><li>非对称加密</li></ul><h2 id="2-公钥认证"><a href="#2-公钥认证" class="headerlink" title="2. 公钥认证"></a>2. 公钥认证</h2><p>非对称加密不能保证你获得的公钥是否是你要进行通信的实体的公钥。</p><p>于是有了<strong>数字证书</strong>的概念：</p><blockquote><p>数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E8%AF%81">数字身份证</a>，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）</p></blockquote><p>数字证书内容大体如下：</p><ul><li>签发证书的机构;</li><li>鲍勃的加密算法;</li><li>鲍勃所使用的Hash算法;</li><li>鲍勃的公钥;</li><li>证书到期时间;</li><li>等等;</li></ul><p>数字证书是由权威机构——CA机构统一来进行发行，我们绝对信任这个机构，至于CA机构的安全性…反正99.99%之下都是安全的。🕵</p><p>为了防止中间有人对证书内容进行更改，有了一个<strong>数字签名</strong>的概念，所谓的数字签名就是把以上所有的内容做一个Hash操作，得到一个固定长度然后再传给鲍勃。然而如果别人截取了这个证书然后更改内容，同时生成了新的Hash值那怎么办？处于这个考虑，CA机构在颁发这个证书的时候会用自己的私钥将Hash值加密，从而防止了数字证书被篡改。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/SSL_2_20210328.jpg"></p><h2 id="3-SSL握手过程"><a href="#3-SSL握手过程" class="headerlink" title="3. SSL握手过程"></a>3. SSL握手过程</h2><p>先用语言来阐述下：</p><ol><li><strong>第一步</strong>：爱丽丝给出支持SSL协议版本号，一个客户端<strong>随机数</strong>（不重数）(Client random，请注意这是第一个随机数)，客户端支持的加密方法等信息；</li><li><strong>第二步：</strong>鲍勃收到信息后，确认双方使用的加密方法，并返回数字证书，一个服务器生成的<strong>随机数</strong>(Server random，注意这是第二个随机数)等信息；</li><li><strong>第三步：</strong>爱丽丝确认数字证书的有效性，然后生成一个新的<strong>随机数</strong>（不重数）(Premaster secret)，然后使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li><li><strong>第四步：</strong>鲍勃使用自己的私钥，获取爱丽丝发来的<strong>随机数</strong>（不重数）(即Premaster secret)；(第三、四步就是非对称加密的过程了)</li><li><strong>第五步：</strong>爱丽丝和鲍勃通过约定的加密方法(通常是<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES算法</a>)，使用前面三个随机数，生成<strong>对话密钥</strong>（Master Secret，MS），MS被切片以生成两个密码和两个MAC密钥。用来加密接下来的通信内容；</li><li><strong>最后</strong>（补充）：Alice发送所有握手报文的一个MAC；Bob发送所有握手报文的一个MAC。（目的是防止第一步中支持加密方法列表是明文发送，容易被删除较强算法，强制选择较弱算法，通过最后的MAC的一致性比较检查是否被篡改。）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/SSL_3_20210328.png"></p><p>SSL中：</p><ul><li>不重数：用于防御“连续重放”。<ul><li>预防示例：Trudy第二天冒充Alice向Bob发送前一天Alice向Bob发送的相同报文序列</li></ul></li><li>序号<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="计算机网络自顶向下方法，第8章，使TCP连接安全：SSL">[1]</span></a></sup>：用于防御在一个进行中的会话中重放个别分组。<ul><li>预防示例：Trudy俘获中间的两个报文段，颠倒次序，调换TCP报文段的序号（未被加密）</li><li>序号包括在了MAC的计算中：MAC是 （数据+MAC密钥+当前序号）的散列</li></ul></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>整个进行数据加密的过程结束：</p><ul><li>CA机构颁发数字证书给鲍勃；</li><li>爱丽丝和鲍勃进行SSL握手，爱丽丝通过数字证书确定鲍勃的身份；</li><li>爱丽丝和鲍勃传递三个随机数，第三个随机数通过非对称加密算法进行传递；</li><li>爱丽丝和鲍勃通过一个对称加密算法生成一个对话密钥，加密接下来的通信内容。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>计算机网络自顶向下方法，第8章，使TCP连接安全：SSL<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.damonare.cn/2017/12/29/SSL%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/#more">https://blog.damonare.cn/2017/12/29/SSL%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/#more</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Network</tag>
      
      <tag>HTTPS</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群与企业级解决方案</title>
    <link href="/2021/03/28/Redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/03/28/Redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis集群与企业级解决方案"><a href="#Redis集群与企业级解决方案" class="headerlink" title="Redis集群与企业级解决方案"></a>Redis集群与企业级解决方案</h1><p>基于<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>的视频的学习笔记</p><h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><h3 id="1-1-主从复制简介"><a href="#1-1-主从复制简介" class="headerlink" title="1.1 主从复制简介"></a>1.1 主从复制简介</h3><h4 id="1-1-1-互联网“三高”架构"><a href="#1-1-1-互联网“三高”架构" class="headerlink" title="1.1.1 互联网“三高”架构"></a>1.1.1 互联网“三高”架构</h4><ul><li>高并发</li><li>高性能</li><li>高可用</li></ul><h4 id="1-1-2-单机redis的风险和问题"><a href="#1-1-2-单机redis的风险和问题" class="headerlink" title="1.1.2 单机redis的风险和问题"></a>1.1.2 单机redis的风险和问题</h4><ul><li>机器故障</li><li>容量瓶颈</li><li>结论：<ul><li>避免单点redis服务器故障，准备堕胎服务器互联</li><li>互联服务器保证数据同步</li><li>实现Redis高可用，实现数据冗余备份</li></ul></li></ul><h4 id="1-1-3-多台服务器连接方案"><a href="#1-1-3-多台服务器连接方案" class="headerlink" title="1.1.3 多台服务器连接方案"></a>1.1.3 多台服务器连接方案</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_32_20210327.png"></p><ul><li>提供数据方：master<ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li>接收数据的方：slave<ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li>需要解决的问题<ul><li><strong>数据同步</strong></li></ul></li><li>核心工作<ul><li>master的数据<strong>复制</strong>到slave中</li></ul></li></ul><h4 id="1-1-4-主从复制"><a href="#1-1-4-主从复制" class="headerlink" title="1.1.4 主从复制"></a>1.1.4 主从复制</h4><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中</p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p><p>职责：</p><ul><li>master:<ul><li>写数据</li><li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave</li><li>读数据（可忽略）</li></ul></li><li>slave:<ul><li>读数据</li><li>写数据（<strong>禁止</strong>）</li></ul></li></ul><h4 id="1-1-5-主从复制的作用"><a href="#1-1-5-主从复制的作用" class="headerlink" title="1.1.5 主从复制的作用"></a>1.1.5 主从复制的作用</h4><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul><h3 id="1-2-主从复制工作流程"><a href="#1-2-主从复制工作流程" class="headerlink" title="1.2 主从复制工作流程"></a>1.2 主从复制工作流程</h3><h4 id="1-2-1-总述"><a href="#1-2-1-总述" class="headerlink" title="1.2.1 总述"></a>1.2.1 总述</h4><ul><li>主从复制过程大体可以分为3个阶段<ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_33_20210327.png"></p><h4 id="1-2-2-第一阶段：建立连接"><a href="#1-2-2-第一阶段：建立连接" class="headerlink" title="1.2.2 第一阶段：建立连接"></a>1.2.2 第一阶段：建立连接</h4><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_34_20210327.png"></p><p>**主从连接（slave连接master） **</p><ul><li><p>方式一：客户端发送命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方式二：启动服务器参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方式三：服务器配置 （常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave系统信息</p><ul><li>master_link_down_since_seconds</li><li>masterhost</li><li>masterport</li></ul></li><li><p>master系统信息</p><ul><li>slave_listening_port(多个)</li></ul></li></ul><p><strong>主从断开连接</strong></p><ul><li><p><strong>客户端</strong>发送命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one<br></code></pre></td></tr></table></figure><ul><li>说明： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据</li></ul></li></ul><p><strong>授权访问</strong></p><ul><li><p>master客户端发送命令设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>master配置文件设置密码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> requirepass &lt;password&gt; <br>config <span class="hljs-builtin-name">get</span> requirepass<br></code></pre></td></tr></table></figure></li><li><p>slave客户端发送命令设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave配置文件设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave启动服务器设置密码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-3-第二阶段：数据同步"><a href="#1-2-3-第二阶段：数据同步" class="headerlink" title="1.2.3 第二阶段：数据同步"></a>1.2.3 第二阶段：数据同步</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_35_20210327.png"></p><ul><li>全量复制<ul><li>将master执行bgsave之前，master中所有的数据同步到slave中</li></ul></li><li>部分复制（增量复制）<ul><li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li></ul></li></ul><h5 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h5><ol><li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行</li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 在master端修改</span><br><span class="hljs-attribute">repl</span>-backlog-size <span class="hljs-number">1</span>mb<br></code></pre></td></tr></table></figure><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><h5 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h5><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></p></li></ol><h4 id="1-2-4-第三阶段：命令传播"><a href="#1-2-4-第三阶段：命令传播" class="headerlink" title="1.2.4 第三阶段：命令传播"></a>1.2.4 第三阶段：命令传播</h4><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong></li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li></ul><h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><ul><li><p>命令传播阶段出现了断网现象</p><ul><li>网络闪断闪连（忽略）</li><li>短时间网络中断（部分复制）</li><li>长时间网络中断（全量复制）</li></ul></li><li><p>部分复制的<font color="FF0000"><strong>三个核心要素</strong></font></p><ul><li>服务器的运行 id（run id）</li><li>主服务器的复制积压缓冲区</li><li>主从服务器的复制偏移量</li></ul></li></ul><h5 id="核心一：服务器运行ID（runid）"><a href="#核心一：服务器运行ID（runid）" class="headerlink" title="核心一：服务器运行ID（runid）"></a>核心一：服务器运行ID（runid）</h5><ul><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 <ul><li>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li></ul></li><li>作用：运行id被用于在服务器间进行传输，识别身份<ul><li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li></ul></li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid</li></ul><h5 id="核心二：复制缓冲区"><a href="#核心二：复制缓冲区" class="headerlink" title="核心二：复制缓冲区"></a>核心二：复制缓冲区</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_36_20210327.png"></p><ul><li><p>概念：</p><p>复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p></li><li><p>由来：</p><p>每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</p></li><li><p>作用：</p><p>用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</p></li><li><p>数据来源：</p><p>当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</p></li><li><p>复制缓冲区的工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_37_20210327.png"></p></li></ul><h5 id="核心三：主从服务器复制偏移量（offset）"><a href="#核心三：主从服务器复制偏移量（offset）" class="headerlink" title="核心三：主从服务器复制偏移量（offset）"></a>核心三：主从服务器复制偏移量（offset）</h5><ul><li>概念：一个数字，描述复制缓冲区中的指令字节位置</li><li>分类：<ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul></li><li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li><li>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用</li></ul><h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_38_20210327.png"></p><h4 id="1-2-5-心跳机制"><a href="#1-2-5-心跳机制" class="headerlink" title="1.2.5 心跳机制"></a>1.2.5 心跳机制</h4><ul><li>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li><li>master心跳：<ul><li>指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul></li><li>slave心跳任务<ul><li>指令：REPLCONF ACK {offset}</li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li></ul><h5 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h5><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><ul><li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li></ul></li><li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li><li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li></ul><h4 id="1-2-6-主从复制完整流程"><a href="#1-2-6-主从复制完整流程" class="headerlink" title="1.2.6 主从复制完整流程"></a>1.2.6 主从复制完整流程</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_39_20210327.png"></p><h3 id="1-3-主从复制常见问题"><a href="#1-3-主从复制常见问题" class="headerlink" title="1.3 主从复制常见问题"></a>1.3 主从复制常见问题</h3><h5 id="频繁的全量复制"><a href="#频繁的全量复制" class="headerlink" title="频繁的全量复制"></a>频繁的全量复制</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_40_20210327.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_41_20210327.png"></p><h5 id="网络中断"><a href="#网络中断" class="headerlink" title="网络中断"></a>网络中断</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_42_20210327_.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_43_20210327.png"></p><h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_44_20210327.png"></p><h2 id="2-哨兵模式"><a href="#2-哨兵模式" class="headerlink" title="2. 哨兵模式"></a>2. 哨兵模式</h2><h3 id="2-1-哨兵简介"><a href="#2-1-哨兵简介" class="headerlink" title="2.1 哨兵简介"></a>2.1 哨兵简介</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_45_20210327.png"></p><h3 id="2-2-哨兵的定义"><a href="#2-2-哨兵的定义" class="headerlink" title="2.2 哨兵的定义"></a>2.2 哨兵的定义</h3><blockquote><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_46_20210327.png"></p><h3 id="2-3-哨兵的作用"><a href="#2-3-哨兵的作用" class="headerlink" title="2.3 哨兵的作用"></a>2.3 哨兵的作用</h3><ul><li>监控<ul><li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li></ul></li><li>自动故障转移<ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li></ul></li></ul><p><strong>注意：</strong><br>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong></p><h3 id="2-4-哨兵的配置"><a href="#2-4-哨兵的配置" class="headerlink" title="2.4 哨兵的配置"></a>2.4 哨兵的配置</h3><ul><li><p>配置一拖二的主从结构</p></li><li><p>配置三个哨兵（配置相同，端口不同）</p><ul><li>参看sentinel.conf</li></ul></li><li><p>启动哨兵</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">redis-sentinel sentinel端口号 <span class="hljs-string">.conf</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_47_20210327.png"></p><h3 id="2-5-哨兵工作原理"><a href="#2-5-哨兵工作原理" class="headerlink" title="2.5 哨兵工作原理"></a>2.5 哨兵工作原理</h3><p>主从切换</p><ul><li>哨兵在进行主从切换过程中经历三个阶段<ul><li>监控</li><li>通知</li><li>故障转移</li></ul></li></ul><h4 id="2-5-1-监控阶段"><a href="#2-5-1-监控阶段" class="headerlink" title="2.5.1 监控阶段"></a>2.5.1 监控阶段</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_48_20210327.png"></p><ul><li><p>用于同步各个节点的状态信息</p><ul><li><p>获取各个sentinel的状态（是否在线）</p></li><li><p>获取master的状态</p><ul><li><p>master属性</p><ul><li><p>runid</p></li><li><p>role：master</p></li></ul></li><li><p>各个slave的详细信息</p></li></ul></li><li><p>获取所有slave的状态（根据master中的slave信息）</p><ul><li>slave属性<ul><li>runid</li><li>role：slave</li><li>master_host、master_port</li><li>offset</li><li>…</li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_49_20210327.png"></p><h4 id="2-5-2-通知阶段"><a href="#2-5-2-通知阶段" class="headerlink" title="2.5.2 通知阶段"></a>2.5.2 通知阶段</h4><ul><li>各个哨兵将得到的信息相互同步（信息对称）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_50_20210327.png"></p><h4 id="2-5-3-故障转移阶段"><a href="#2-5-3-故障转移阶段" class="headerlink" title="2.5.3 故障转移阶段"></a>2.5.3 故障转移阶段</h4><h5 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_51_20210327.png"></p><ul><li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li><li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li></ul><h5 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_52_20210327.png"></p><ul><li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li><li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li></ul><h5 id="挑选新master"><a href="#挑选新master" class="headerlink" title="挑选新master"></a>挑选新master</h5><ul><li>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：<ul><li>服务器列表中挑选备选master<ul><li>在线的</li><li>响应慢的</li><li>与原master断开时间久的</li><li>优先原则<ul><li>优先级</li><li>offset</li><li>runid</li></ul></li></ul></li><li>发送指令（ sentinel ）<ul><li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li><li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li></ul></li></ul></li></ul><h4 id="2-5-4-各阶段的总结"><a href="#2-5-4-各阶段的总结" class="headerlink" title="2.5.4 各阶段的总结"></a>2.5.4 各阶段的总结</h4><ul><li>监控<ul><li>同步信息</li></ul></li><li>通知<ul><li>保持联通</li></ul></li><li>故障转移<ul><li>发现问题</li><li>竞选负责人</li><li>优选新master</li><li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li></ul></li></ul><h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h2><h3 id="3-1-集群简介"><a href="#3-1-集群简介" class="headerlink" title="3.1 集群简介"></a>3.1 集群简介</h3><h4 id="3-1-1-集群架构"><a href="#3-1-1-集群架构" class="headerlink" title="3.1.1 集群架构"></a>3.1.1 集群架构</h4><ul><li>集群就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果</li></ul><h4 id="3-1-2-集群作用"><a href="#3-1-2-集群作用" class="headerlink" title="3.1.2 集群作用"></a>3.1.2 集群作用</h4><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong></li><li>分散单台服务器的存储压力，实现<strong>可扩展性</strong></li><li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong></li></ul><h3 id="3-2-集群结构设计"><a href="#3-2-集群结构设计" class="headerlink" title="3.2 集群结构设计"></a>3.2 集群结构设计</h3><h4 id="3-2-1-数据存储设计"><a href="#3-2-1-数据存储设计" class="headerlink" title="3.2.1 数据存储设计"></a>3.2.1 数据存储设计</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_53_20210328.png"></p><ul><li><p>通过算法设计，计算出key应该保存的位置</p></li><li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</p></li><li><p>将key按照计算出的结果放到对应的存储空间</p></li><li><p>增强可扩展性：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_54_20210328.png"></p></li></ul><h4 id="3-2-2-集群内部通讯设计"><a href="#3-2-2-集群内部通讯设计" class="headerlink" title="3.2.2 集群内部通讯设计"></a>3.2.2 集群内部通讯设计</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_55_20210328.png"></p><ul><li>各个数据库互相连通，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li></ul><h4 id="3-2-3-集群cluster搭建"><a href="#3-2-3-集群cluster搭建" class="headerlink" title="3.2.3 集群cluster搭建"></a>3.2.3 集群cluster搭建</h4><h5 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h5><ul><li>修改一份redis-6379.conf</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_56_20210328.png"></p><ul><li><p>复制5份，并修改端口名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &quot;s/6379/6380/g&quot; redis-6379.conf &gt; redis-6380.conf<br>sed &quot;s/6379/6381/g&quot; redis-6379.conf &gt; redis-6381.conf<br>sed &quot;s/6379/6382/g&quot; redis-6379.conf &gt; redis-6382.conf<br>sed &quot;s/6379/6383/g&quot; redis-6379.conf &gt; redis-6383.conf<br>sed &quot;s/6379/6384/g&quot; redis-6379.conf &gt; redis-6384.conf<br></code></pre></td></tr></table></figure></li><li><p>分别在6个客户端启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 执行6次</span><br>redis-server 配置文件路径<br></code></pre></td></tr></table></figure></li><li><p>查看服务是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep redis<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_57_20210328.png"></p><p>服务开启正常</p></li><li><p>查找redis-trib.rb的命令(该指令执行基于ruby，gem，需要安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ll | grep redis-<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_58_20210328.png"></p></li><li><p>执行redis-trib命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 该命令只在当前目录下有效,--replicas代表集群结构，1表示每个master连接1个slave</span><br>./redis-trib.rb create --replicas 1 127.0.0.1：6379 127.0.0.1：6380 127.0.0.1：6381 127.0.0.1：6382 127.0.0.1：6383 127.0.0.1：6384<br><span class="hljs-meta">#</span><span class="bash"> 最后输入yes</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_59_20210328.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_60_20210328.png"></p></li><li><p>完成运行后，每个node文件加入了糟分配信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_61_20210328.png"></p></li><li><p>集群搭建完毕</p></li></ul><h5 id="集群设置与获取数据"><a href="#集群设置与获取数据" class="headerlink" title="集群设置与获取数据"></a>集群设置与获取数据</h5><ul><li>设置数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 操作集群</span><br>redis-cli -c<br>set name itheima<br></code></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -c -p 6382<br><span class="hljs-meta">#</span><span class="bash"> 如果不在6382端口，下面会提示发生了重定向</span><br>get name<br></code></pre></td></tr></table></figure><h5 id="主从下线与主从切换"><a href="#主从下线与主从切换" class="headerlink" title="主从下线与主从切换"></a>主从下线与主从切换</h5><ul><li><p>slave下线对功能不产生影响，会标记以下slave</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_62_20210328.png"></p></li><li><p>master下线</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_63_20210328.png"></p><p>之后slave会变为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看集群节点信息</span><br>cluster nodes<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_64_20210328.png"><br>master上线后，变为slave，之前的slave变为master<br><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_65_20210328.png"></p></li></ul><h5 id="集群配置总结"><a href="#集群配置总结" class="headerlink" title="集群配置总结"></a>集群配置总结</h5><ul><li><p>设置加入cluster，成为其中节点</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">cluster-enabled <span class="hljs-literal">yes</span> | <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li><li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或者切换为从节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">cluster-<span class="hljs-keyword">node</span><span class="hljs-title">-timeout</span> <span class="hljs-tag">&lt;millseconds&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>master连接的slave最小数量</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cluster-migration-<span class="hljs-keyword">barrier </span>&lt;<span class="hljs-built_in">count</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h5 id="cluster节点操作指令总结"><a href="#cluster节点操作指令总结" class="headerlink" title="cluster节点操作指令总结"></a>cluster节点操作指令总结</h5><ul><li><p>查看集群节点信息</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">cluster <span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li><li><p>进入一个从节点redis，切换其为主节点</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cluster replicate &lt;master-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>发现一个新节点，新增主节点</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">cluster</span> meet <span class="hljs-built_in">ip</span>:port<br></code></pre></td></tr></table></figure></li><li><p>忽略一个没有solt的节点</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cluster forget &lt;<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>手动故障转移</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cluster failover</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-企业级解决方案"><a href="#4-企业级解决方案" class="headerlink" title="4. 企业级解决方案"></a>4. 企业级解决方案</h2><h3 id="4-1-缓存预热"><a href="#4-1-缓存预热" class="headerlink" title="4.1 缓存预热"></a>4.1 缓存预热</h3><h4 id="4-1-1-问题排查"><a href="#4-1-1-问题排查" class="headerlink" title="4.1.1 问题排查"></a>4.1.1 问题排查</h4><ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul><h4 id="4-1-2-解决方案"><a href="#4-1-2-解决方案" class="headerlink" title="4.1.2 解决方案"></a>4.1.2 解决方案</h4><ul><li>前置准备工作：<ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列 <ul><li>例如：storm与kafka配合</li></ul></li></ul></li><li>准备工作：<ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ul></li><li>实施：<ul><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ul></li></ul><h4 id="4-1-3-总结"><a href="#4-1-3-总结" class="headerlink" title="4.1.3 总结"></a>4.1.3 总结</h4><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h3 id="4-2-缓存雪崩"><a href="#4-2-缓存雪崩" class="headerlink" title="4.2 缓存雪崩"></a>4.2 缓存雪崩</h3><h4 id="4-2-1-数据库服务器崩溃（1）"><a href="#4-2-1-数据库服务器崩溃（1）" class="headerlink" title="4.2.1 数据库服务器崩溃（1）"></a>4.2.1 数据库服务器崩溃（1）</h4><ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ol><h4 id="4-2-2-问题排查"><a href="#4-2-2-问题排查" class="headerlink" title="4.2.2 问题排查"></a>4.2.2 问题排查</h4><ol><li>在一个<font color="FF0000"><strong>较短</strong></font>的时间内，缓存中<font color="FF0000">较多</font>的key<font color="FF0000"><strong>集中过期</strong></font></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ol><h4 id="4-2-3-问题分析"><a href="#4-2-3-问题分析" class="headerlink" title="4.2.3 问题分析"></a>4.2.3 问题分析</h4><ul><li>短时间范围内</li><li>大量key集中过期</li></ul><h4 id="4-2-4-解决方案（道）"><a href="#4-2-4-解决方案（道）" class="headerlink" title="4.2.4 解决方案（道）"></a>4.2.4 解决方案（道）</h4><ol><li><p>更多的页面静态化处理</p></li><li><p>构建<strong>多级缓存架构</strong> </p><ul><li>Nginx缓存+redis缓存+ehcache缓存</li></ul></li><li><p>检测Mysql严重耗时业务进行优化 </p><ul><li>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li></ul></li><li><p>灾难预警机制 </p><p>监控redis服务器性能指标</p><ul><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li><p>限流、降级 </p><ul><li>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ul></li></ol><h4 id="4-2-5-解决方案（术）"><a href="#4-2-5-解决方案（术）" class="headerlink" title="4.2.5 解决方案（术）"></a>4.2.5 解决方案（术）</h4><ol><li>LRU与LFU切换</li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量</li></ul></li><li><strong>超热</strong>数据使用永久key</li><li>定期维护（自动+人工） <ul><li>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li></ul></li><li>加锁 <strong>慎用！</strong></li></ol><h4 id="4-2-6-总结"><a href="#4-2-6-总结" class="headerlink" title="4.2.6 总结"></a>4.2.6 总结</h4><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_66_20210328.png"></p><h3 id="4-3-缓存击穿"><a href="#4-3-缓存击穿" class="headerlink" title="4.3 缓存击穿"></a>4.3 缓存击穿</h3><h4 id="4-3-1-数据库服务器崩溃（2）"><a href="#4-3-1-数据库服务器崩溃（2）" class="headerlink" title="4.3.1 数据库服务器崩溃（2）"></a>4.3.1 数据库服务器崩溃（2）</h4><ol><li>系统平稳运行过程中</li><li>数据库连接量<strong>瞬间激增</strong></li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li><strong>数据库崩溃</strong></li></ol><h4 id="4-3-2-问题排查"><a href="#4-3-2-问题排查" class="headerlink" title="4.3.2 问题排查"></a>4.3.2 问题排查</h4><ol><li>Redis中<font color="FF0000"><strong>某个key过期，该key访问量巨大</strong></font></li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ol><h4 id="4-3-3-问题分析"><a href="#4-3-3-问题分析" class="headerlink" title="4.3.3 问题分析"></a>4.3.3 问题分析</h4><ul><li>单个key高热数据</li><li>key过期</li></ul><h4 id="4-3-4-解决方案（术）"><a href="#4-3-4-解决方案（术）" class="headerlink" title="4.3.4 解决方案（术）"></a>4.3.4 解决方案（术）</h4><ol><li><p>预先设定</p><p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong></p><p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整</p><ul><li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li></ul></li><li><p>后台刷新数据</p><ul><li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li></ul></li><li><p>二级缓存</p><ul><li>设置不同的失效时间，保障不会被<font color="FF0000">同时</font>淘汰就行</li></ul></li><li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong></p></li></ol><h4 id="4-3-5-总结"><a href="#4-3-5-总结" class="headerlink" title="4.3.5 总结"></a>4.3.5 总结</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p><h3 id="4-4-缓存穿透"><a href="#4-4-缓存穿透" class="headerlink" title="4.4 缓存穿透"></a>4.4 缓存穿透</h3><h4 id="4-4-1-数据库服务器崩溃（3）"><a href="#4-4-1-数据库服务器崩溃（3）" class="headerlink" title="4.4.1 数据库服务器崩溃（3）"></a>4.4.1 数据库服务器崩溃（3）</h4><ol><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li><strong>数据库崩溃</strong></li></ol><h4 id="4-4-2-问题排查"><a href="#4-4-2-问题排查" class="headerlink" title="4.4.2 问题排查"></a>4.4.2 问题排查</h4><ol><li>Redis中大面积出限未命中</li><li>出现<font color="FF0000"><strong>非正常URL访问</strong></font></li></ol><h4 id="4-4-3-问题分析"><a href="#4-4-3-问题分析" class="headerlink" title="4.4.3 问题分析"></a>4.4.3 问题分析</h4><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对于数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>出限黑客攻击服务器</li></ul><h4 id="4-4-4-解决方案（术）"><a href="#4-4-4-解决方案（术）" class="headerlink" title="4.4.4 解决方案（术）"></a>4.4.4 解决方案（术）</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_67_20210328.png"></p><h4 id="4-4-5-总结"><a href="#4-4-5-总结" class="headerlink" title="4.4.5 总结"></a>4.4.5 总结</h4><p>缓存基础访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低值，当出现此类情况以毒攻毒，并即使报警。应对策略应该在临时预案防范方面多做文章。</p><p>（目标就是拦在服务器外面，用bitmaps就是拦到redis和服务器中间，用加密key就是拦到应用服务器外面）</p><p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p><h3 id="4-5-性能指标监控"><a href="#4-5-性能指标监控" class="headerlink" title="4.5 性能指标监控"></a>4.5 性能指标监控</h3><h4 id="4-5-1-监控指标"><a href="#4-5-1-监控指标" class="headerlink" title="4.5.1 监控指标"></a>4.5.1 监控指标</h4><ul><li><p>性能指标：Performance</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_68_20210328.png"></p></li><li><p>内存指标： Memory</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_69_20210328.png"></p></li><li><p>基本活动指标：Basic acticity</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_70_20210328.png"></p></li><li><p>持久性指标：Persistence</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_71_20210328.png"></p></li><li><p>错误指标：Error</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_72_20210328.png"></p></li></ul><h4 id="4-5-2-监控方式"><a href="#4-5-2-监控方式" class="headerlink" title="4.5.2 监控方式"></a>4.5.2 监控方式</h4><ul><li>工具<ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul></li><li>命令<ul><li>benchmark</li><li>redis cli<ul><li>monitor</li><li>showlog</li></ul></li></ul></li></ul><h5 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_73_20210328.png"></p></li></ul><h5 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">monitor<br></code></pre></td></tr></table></figure><p>打印服务器调试信息</p></li></ul><h5 id="showlog"><a href="#showlog" class="headerlink" title="showlog"></a>showlog</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">slowlog [operator]<br></code></pre></td></tr></table></figure><ul><li>get：获取慢查询日志</li><li>len：获取慢查询日志条目数</li><li>reset：充值慢查询日志</li></ul></li><li><p>相关配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">slowlog-log-slower-than 1000 # 设置慢查询的时间下限，单位ms<br>slowlog-max-len 100          # 设置慢查询命令对应的日志显示长度，单位命令数<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis高级</title>
    <link href="/2021/03/27/Redis%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/03/27/Redis%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h1><p>基于<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>的视频的学习笔记</p><h2 id="1-Linux环节安装"><a href="#1-Linux环节安装" class="headerlink" title="1. Linux环节安装"></a>1. Linux环节安装</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_12_20210326.png"></p><h3 id="1-2-启动方式"><a href="#1-2-启动方式" class="headerlink" title="1.2 启动方式"></a>1.2 启动方式</h3><ul><li>普通默认端口启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 默认端口开启</span><br>redis-serve<br><span class="hljs-meta">#</span><span class="bash"> 默认端口连接</span><br>redis-cli<br></code></pre></td></tr></table></figure><ul><li>指定端口启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 换端口启动</span><br>redis-server --port 6380<br><span class="hljs-meta">#</span><span class="bash"> 连接客户端指定端口连接</span><br>redis-cli -p 6380<br></code></pre></td></tr></table></figure><ul><li>指定配置文件启动 redis-6379.conf</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br><span class="hljs-attribute">daemonize</span> yes<br><span class="hljs-attribute">logfile</span> <span class="hljs-string">&quot;6379.log&quot;</span><br><span class="hljs-attribute">dir</span> /redis-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/data<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动</span><br>redis-server redis-6379.conf<br>redis-server conf/redis-6379.conf<br><span class="hljs-meta">#</span><span class="bash"> 连接</span><br>redis-cli<br></code></pre></td></tr></table></figure><h2 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><blockquote><p>什么是持久化：</p></blockquote><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制</p><blockquote><p>为什么要持久化：</p></blockquote><p>防止数据的意外丢失，确保数据安全</p><blockquote><p>持久化过程保存什么</p></blockquote><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong></li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_13_20210326.png"></p><h3 id="2-2-RDB"><a href="#2-2-RDB" class="headerlink" title="2.2 RDB"></a>2.2 RDB</h3><h4 id="2-2-1-RDB启动方式1–save指令"><a href="#2-2-1-RDB启动方式1–save指令" class="headerlink" title="2.2.1 RDB启动方式1–save指令"></a>2.2.1 RDB启动方式1–save指令</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><h5 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h5><ul><li>dbfilename dump.rdb<ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb</li><li>经验：通常设置为<font color="0000FF"><strong>dump-</strong></font><font color="FF0000"><strong>端口号</strong></font><font color="0000FF"><strong>.rdb</strong></font></li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径</li><li>经验：通常设置成存储空间较大的目录中，目录名称<font color="FF0000"><strong>data</strong></font></li></ul></li><li>rdbcompression yes<ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li></ul><p>配置后，conf文件内容为：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_14_20210326.png"></p><h5 id="save指令工作原理"><a href="#save指令工作原理" class="headerlink" title="save指令工作原理"></a>save指令工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_15_20210326.png"></p><h4 id="2-2-2-RDB启动方式2–bgsave指令"><a href="#2-2-2-RDB启动方式2–bgsave指令" class="headerlink" title="2.2.2 RDB启动方式2–bgsave指令"></a>2.2.2 RDB启动方式2–bgsave指令</h4><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgsave<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong></p></li></ul><h5 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h5><ul><li><p>dbfilename dump.rdb（同save）</p></li><li><p>dir（同save）</p></li><li><p>rdbcompression yes（同save）</p></li><li><p>rdbchecksum yes（同save）</p></li><li><p>stop-writes-on-bgsave-error yes</p><ul><li>说明：后台存储过程中如果出现错误现象，是否停止保存现象</li><li>经验：通常默认为开启状态</li></ul></li></ul><h5 id="bgsave指令工作原理"><a href="#bgsave指令工作原理" class="headerlink" title="bgsave指令工作原理"></a>bgsave指令工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_16_20210326.png"></p><h4 id="2-2-3-RDB启动方式3–save配置"><a href="#2-2-3-RDB启动方式3–save配置" class="headerlink" title="2.2.3 RDB启动方式3–save配置"></a>2.2.3 RDB启动方式3–save配置</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li><p>配置到.conf文件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes<br></code></pre></td></tr></table></figure><p>配置后：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_17_20210326.png"></p></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p></li><li><p>参数</p><ul><li>second：监控时间范围</li><li>changes：监控key的变化量</li></ul></li></ul><h5 id="save配置工作原理"><a href="#save配置工作原理" class="headerlink" title="save配置工作原理"></a>save配置工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_18_20210326.png"></p><p>注意：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系</li><li>save配置启动后执行的是<strong>bgsave操作</strong></li></ul><h4 id="2-2-4-三种启动方式对比"><a href="#2-2-4-三种启动方式对比" class="headerlink" title="2.2.4 三种启动方式对比"></a>2.2.4 三种启动方式对比</h4><table><thead><tr><th>方式</th><th>save指令</th><th>bgsave指令</th></tr></thead><tbody><tr><td>读写</td><td>同步</td><td>异步</td></tr><tr><td>阻塞客户端指令</td><td>是</td><td>否</td></tr><tr><td>额外内存消耗</td><td>否</td><td>是</td></tr><tr><td>启动新线程</td><td>否</td><td>是</td></tr></tbody></table><h4 id="2-2-5-RDB特殊启动形式（了解）"><a href="#2-2-5-RDB特殊启动形式（了解）" class="headerlink" title="2.2.5 RDB特殊启动形式（了解）"></a>2.2.5 RDB特殊启动形式（了解）</h4><ul><li><p>全量复制</p><p>在主从复制中详细讲解</p></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debug reload<br></code></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown save<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-6-RDB优缺点"><a href="#2-2-6-RDB优缺点" class="headerlink" title="2.2.6 RDB优缺点"></a>2.2.6 RDB优缺点</h4><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li></ul></li></ul><h3 id="2-3-AOF"><a href="#2-3-AOF" class="headerlink" title="2.3 AOF"></a>2.3 AOF</h3><h4 id="2-3-1-AOF概念"><a href="#2-3-1-AOF概念" class="headerlink" title="2.3.1 AOF概念"></a>2.3.1 AOF概念</h4><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li></ul><h4 id="2-3-2-AOF写数据过程"><a href="#2-3-2-AOF写数据过程" class="headerlink" title="2.3.2 AOF写数据过程"></a>2.3.2 AOF写数据过程</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_20_20210326.png"></p><h4 id="2-3-3-AOF写数据三种策略-appendfsync"><a href="#2-3-3-AOF写数据三种策略-appendfsync" class="headerlink" title="2.3.3 AOF写数据三种策略(appendfsync)"></a>2.3.3 AOF写数据三种策略(appendfsync)</h4><ul><li>always（每次）<ul><li>每次写入操作均同步到AOF文件中，<font color="0000FF"><strong>数据零误差</strong></font>，<font color="FF0000"><strong>性能较低</strong></font>，<strong>不建议使用</strong></li></ul></li><li>everysec（每秒）<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据<font color="0000FF"><strong>准确性较高</strong></font>，<font color="0000FF"><strong>性能较高</strong></font> ，<strong>建议使用</strong>，也是默认配置</li><li>在系统突然宕机的情况下丢失1秒内的数据</li></ul></li><li>no（系统控制）<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<font color="FF0000"><strong>不可控</strong></font></li></ul></li></ul><h4 id="2-3-4-AOF功能开启"><a href="#2-3-4-AOF功能开启" class="headerlink" title="2.3.4 AOF功能开启"></a>2.3.4 AOF功能开启</h4><ul><li><p>配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ul><li> 作用</li></ul><p>  是否开启AOF持久化功能，<strong>默认为不开启状态</strong></p></li><li><p>配置</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span><br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF写数据策略</p></li></ul></li></ul><p>配置后，conf配置文件如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_19_20210326.png"></p><h4 id="2-3-5-AOF相关配置"><a href="#2-3-5-AOF相关配置" class="headerlink" title="2.3.5 AOF相关配置"></a>2.3.5 AOF相关配置</h4><ul><li><p>配置</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">appendfilename filename</span><br></code></pre></td></tr></table></figure><ul><li> 作用</li></ul><p>  AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p></li><li><p>配置</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p></li></ul></li></ul><h4 id="2-3-6-AOF重写"><a href="#2-3-6-AOF重写" class="headerlink" title="2.3.6 AOF重写"></a>2.3.6 AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li></ul></li><li>对同一数据的多条写命令合并为一条命令<ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li><p>手动重写</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span><br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.触发条件设置</span><br><span class="hljs-meta">#</span><span class="bash"> 触发重写的最小大小</span><br>auto-aof-rewrite-min-size size <br><span class="hljs-meta">#</span><span class="bash"> 触发重写须达到的最小百分比</span> <br>auto-aof-rewrite-percentage percentage<br><br><span class="hljs-meta">#</span><span class="bash"> 2.触发比对参数（ 运行指令info Persistence获取具体信息 ）</span><br><span class="hljs-meta">#</span><span class="bash"> 当前.aof的文件大小</span><br>aof_current_size <br><span class="hljs-meta">#</span><span class="bash"> 基础文件大小</span><br>aof_base_size<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_22_20210326.png"></p></li></ul><h5 id="重写工作原理"><a href="#重写工作原理" class="headerlink" title="重写工作原理"></a>重写工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_21_20210326.png"></p><h5 id="重写工作流程"><a href="#重写工作流程" class="headerlink" title="重写工作流程"></a>重写工作流程</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_23_20210326.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_24_20210326.png"></p><h3 id="2-4-RDB与AOF的区别"><a href="#2-4-RDB与AOF的区别" class="headerlink" title="2.4 RDB与AOF的区别"></a>2.4 RDB与AOF的区别</h3><table><thead><tr><th>持久化方式</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级：压缩）</td><td>大（指令级：重写）</td></tr><tr><td>存储速度</td><td>慢</td><td>快</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>会丢失数据</td><td>依据策略决定</td></tr><tr><td>资源消耗</td><td>高/重量级</td><td>低/轻量级</td></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr></tbody></table><h3 id="2-5-RDB与AOF的选择"><a href="#2-5-RDB与AOF的选择" class="headerlink" title="2.5 RDB与AOF的选择"></a>2.5 RDB与AOF的选择</h3><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li><li><strong>灾难恢复选用RDB</strong></li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li></ul></li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2><h3 id="3-1-事务简介"><a href="#3-1-事务简介" class="headerlink" title="3.1 事务简介"></a>3.1 事务简介</h3><blockquote><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p></blockquote><h3 id="3-2-事务基本操作"><a href="#3-2-事务基本操作" class="headerlink" title="3.2 事务基本操作"></a>3.2 事务基本操作</h3><ul><li><p>开启事务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span><br></code></pre></td></tr></table></figure><ul><li>作用：作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li><p>取消事务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span><br></code></pre></td></tr></table></figure><ul><li>作用终止当前事务的定义，发生在multi之后，exec之前</li></ul></li><li><p>执行事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span><br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用</li></ul></li></ul><h3 id="3-3-事务工作流程"><a href="#3-3-事务工作流程" class="headerlink" title="3.3 事务工作流程"></a>3.3 事务工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_25_20210326.png"></p><h3 id="3-4-事务注意事项"><a href="#3-4-事务注意事项" class="headerlink" title="3.4 事务注意事项"></a>3.4 事务注意事项</h3><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p><ul><li>语法错误<ul><li>指命令书写格式有误 例如执行了一条不存在的指令</li></ul></li><li>处理结果<ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li></ul><p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong></p><ul><li>运行错误<ul><li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作</li></ul></li><li>处理结果<ul><li>能够正确运行的命令会执行，运行错误的命令不会被执行</li></ul></li></ul><p><font color="FF0000"><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。</font></p><h3 id="3-5-锁"><a href="#3-5-锁" class="headerlink" title="3.5 锁"></a>3.5 锁</h3><h4 id="3-5-1-基于特定条件的事务执行–锁"><a href="#3-5-1-基于特定条件的事务执行–锁" class="headerlink" title="3.5.1 基于特定条件的事务执行–锁"></a>3.5.1 基于特定条件的事务执行–锁</h4><p>监视锁类似CAS的思想，如果监视对象在事务执行前被修改了，那么就不执行了</p><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">watch</span> key<span class="hljs-number">1</span>, key<span class="hljs-number">2</span>....<br></code></pre></td></tr></table></figure></li><li><p>取消对<strong>所有</strong>key的监视</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-2基于特定条件的事务执行–分布式锁"><a href="#3-5-2基于特定条件的事务执行–分布式锁" class="headerlink" title="3.5.2基于特定条件的事务执行–分布式锁"></a>3.5.2基于特定条件的事务执行–分布式锁</h4><p>分布式锁类似悲观锁的思想，但是只是一个标记</p><ul><li><p>使用 setnx 设置一个公共锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 上锁</span><br>setnx lock-key value<br><span class="hljs-meta">#</span><span class="bash"> 释放锁</span><br>del lock-key<br></code></pre></td></tr></table></figure><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁</li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性</p><h4 id="3-5-3-分布式锁改良"><a href="#3-5-3-分布式锁改良" class="headerlink" title="3.5.3 分布式锁改良"></a>3.5.3 分布式锁改良</h4><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">expire <span class="hljs-keyword">lock</span>-key seconds<br>pexpire <span class="hljs-keyword">lock</span>-key millisecondsCopy<br></code></pre></td></tr></table></figure></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul><h2 id="4-删除策略"><a href="#4-删除策略" class="headerlink" title="4. 删除策略"></a>4. 删除策略</h2><h3 id="4-1-数据删除策略"><a href="#4-1-数据删除策略" class="headerlink" title="4.1 数据删除策略"></a>4.1 数据删除策略</h3><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_26_20210327.png"></p><h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p><h3 id="4-2-三种删除策略"><a href="#4-2-三种删除策略" class="headerlink" title="4.2 三种删除策略"></a>4.2 三种删除策略</h3><h4 id="4-2-1-定时删除"><a href="#4-2-1-定时删除" class="headerlink" title="4.2.1 定时删除"></a>4.2.1 定时删除</h4><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</li><li>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</li></ul><h4 id="4-2-2-惰性删除"><a href="#4-2-2-惰性删除" class="headerlink" title="4.2.2 惰性删除"></a>4.2.2 惰性删除</h4><ul><li>数据到达过期时间，不做处理。等下次访问该数据时<ul><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ul></li><li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除</li><li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能 （<strong>拿空间换时间</strong>）</li></ul><h4 id="4-2-3-定期删除（折中方案）"><a href="#4-2-3-定期删除（折中方案）" class="headerlink" title="4.2.3 定期删除（折中方案）"></a>4.2.3 定期删除（折中方案）</h4><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_27_20210327.png"></p><h4 id="4-2-4-删除策略对比"><a href="#4-2-4-删除策略对比" class="headerlink" title="4.2.4 删除策略对比"></a>4.2.4 删除策略对比</h4><table><thead><tr><th>删除策略</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>定时删除</td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频率高</td><td>拿时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>拿空间换时间</td></tr><tr><td>定期删除</td><td>内存定期随机清理</td><td>每秒花费固定的CPU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><p>redis内部一般使用惰性删除和定期删除</p><h3 id="4-3-逐出算法（淘汰算法）"><a href="#4-3-逐出算法（淘汰算法）" class="headerlink" title="4.3 逐出算法（淘汰算法）"></a>4.3 逐出算法（淘汰算法）</h3><p>**当新数据进入redis时，如果内存不足怎么办？ **</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()<strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为</strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h4 id="4-3-1-影响数据逐出的相关配置"><a href="#4-3-1-影响数据逐出的相关配置" class="headerlink" title="4.3.1 影响数据逐出的相关配置"></a>4.3.1 影响数据逐出的相关配置</h4><ul><li><p>最大可使用内存</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span><br></code></pre></td></tr></table></figure><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p>每次选取待删除数据的个数</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span><br></code></pre></td></tr></table></figure><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p>删除策略</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span><br></code></pre></td></tr></table></figure><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p></li><li><p>删除策略包括以下8种不同设置：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_28_20210327.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 配置方式</span><br>maxmemory-policy volatile-lru<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-3-2-数据逐出策略配置依据"><a href="#4-3-2-数据逐出策略配置依据" class="headerlink" title="4.3.2 数据逐出策略配置依据"></a>4.3.2 数据逐出策略配置依据</h4><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_29_20210327.png"></p><h2 id="5-服务器基础配置"><a href="#5-服务器基础配置" class="headerlink" title="5. 服务器基础配置"></a>5. 服务器基础配置</h2><h3 id="5-1-服务器端设定"><a href="#5-1-服务器端设定" class="headerlink" title="5.1 服务器端设定"></a>5.1 服务器端设定</h3><p>设置到conf文件中</p><ul><li>设置服务器以守护进程的方式运行</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span> | <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ul><li>绑定主机地址</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><ul><li>设置服务器端口号</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><ul><li>设置数据库数量</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">database</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_30_20210327.png"></p><h3 id="5-2-日志配置"><a href="#5-2-日志配置" class="headerlink" title="5.2 日志配置"></a>5.2 日志配置</h3><ul><li>设置服务器以指定日志记录级别</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">loglevel <span class="hljs-keyword">debug</span>|<span class="hljs-keyword">verbose</span>|<span class="hljs-keyword">notice</span>|<span class="hljs-built_in">warning</span><br></code></pre></td></tr></table></figure><ul><li>日志记录文件名</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">logfile 端口号.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频率</p><h3 id="5-3-客户端配置"><a href="#5-3-客户端配置" class="headerlink" title="5.3 客户端配置"></a>5.3 客户端配置</h3><ul><li>设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis会关闭新的连接</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">maxclients</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为0</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">timeout</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h3 id="5-4-多服务器快捷配置"><a href="#5-4-多服务器快捷配置" class="headerlink" title="5.4 多服务器快捷配置"></a>5.4 多服务器快捷配置</h3><ul><li>导入并加载指定配置文件信息，用于快速船舰redis公共配置较多的redis实例配置文件，便于维护</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-regexp">/path/</span>server-端口号.conf<br></code></pre></td></tr></table></figure><h2 id="6-高级数据类型"><a href="#6-高级数据类型" class="headerlink" title="6. 高级数据类型"></a>6. 高级数据类型</h2><h3 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h3><h4 id="6-1-1-基础操作"><a href="#6-1-1-基础操作" class="headerlink" title="6.1.1 基础操作"></a>6.1.1 基础操作</h4><ul><li><p>获取指定key对应偏移量上的bit值</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">setbit key <span class="hljs-built_in">offset</span> value<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-1-2-扩展操作"><a href="#6-1-2-扩展操作" class="headerlink" title="6.1.2 扩展操作"></a>6.1.2 扩展操作</h4><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key<span class="hljs-number">1</span><span class="hljs-meta"> [key2...]</span><br></code></pre></td></tr></table></figure><ul><li>and：交</li><li>or：并</li><li>not：非</li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h3><h4 id="6-2-1-基数"><a href="#6-2-1-基数" class="headerlink" title="6.2.1 基数"></a>6.2.1 基数</h4><ul><li>基数是数据集<strong>去重后元素个数</strong></li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_31_20210327.png"></p><h4 id="6-2-2-基本操作"><a href="#6-2-2-基本操作" class="headerlink" title="6.2.2 基本操作"></a>6.2.2 基本操作</h4><ul><li><p>添加数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfadd</span> key element<span class="hljs-number">1</span>, element<span class="hljs-number">2</span>...<br></code></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfcount</span> key<span class="hljs-number">1</span> key<span class="hljs-number">2</span>....<br></code></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="6-2-3-相关说明"><a href="#6-2-3-相关说明" class="headerlink" title="6.2.3 相关说明"></a>6.2.3 相关说明</h4><ul><li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong></li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong></li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少</li></ul><h3 id="6-3-GEO"><a href="#6-3-GEO" class="headerlink" title="6.3 GEO"></a>6.3 GEO</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加坐标点</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">geoadd key longitude latitude member <span class="hljs-comment">[longitude latitude member ...]</span> <br>georadius key longitude latitude radius m|km|ft|mi <span class="hljs-comment">[withcoord]</span> <span class="hljs-comment">[withdist]</span> <span class="hljs-comment">[withhash]</span> <span class="hljs-comment">[count count]</span><br></code></pre></td></tr></table></figure></li><li><p>获取坐标点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geopos <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...] <br>georadiusbymember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-built_in">radius</span> m|km|ft|mi [withcoord] [withdist] [withhash] [count count]<br></code></pre></td></tr></table></figure></li><li><p>计算坐标点距离</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] <br>geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2021/03/26/Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/26/Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p>学习Javaweb时，学习过Redis的基本使用，学习<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>进阶内容顺带复习一下基础，整理本学习笔记</p><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h2><h3 id="1-1-NoSQL简介"><a href="#1-1-NoSQL简介" class="headerlink" title="1.1 NoSQL简介"></a>1.1 NoSQL简介</h3><p>NoSQL：即Not-OnlySQL（泛指非关系性数据库），作为关系型数据库的补充</p><p>作用：应对基于海量数据和海量用户的数据处理。</p><p>特征：</p><ul><li>可扩容，可伸展</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><p>常见的NoSQL数据库：</p><ul><li><font color="FF0000"><strong>Redis</strong></font></li><li>memcache</li><li>HBase</li><li>MongoDB</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_2_20210325.png"></p><h3 id="1-2-Redis简介"><a href="#1-2-Redis简介" class="headerlink" title="1.2 Redis简介"></a>1.2 Redis简介</h3><blockquote><p>概念：Redis（REmote DIctionary Server）是用C语言开发的一个开源的高性能键值对（key-value）数据库。</p></blockquote><p>特征：</p><ul><li>数据之间没有必然的联系</li><li>内部采用了单线程机制进行工作</li><li>高性能</li><li>多数据类型支持<ul><li>String</li><li>list</li><li>hash</li><li>set</li><li>sorted_set</li></ul></li><li>持久化支持，可以进行数据灾难恢复</li></ul><p>应用：</p><ul><li>热点数据加速查询（热点资讯，热点商品）</li><li>任务队列（秒杀）</li><li>即使信息查询（排行榜）</li><li>时效性习性控制（验证码）</li><li>分布式数据共享（分布式集群中的session分离）</li><li>消息队列</li><li>分布式锁</li></ul><h3 id="1-3-Redis常用指令"><a href="#1-3-Redis常用指令" class="headerlink" title="1.3 Redis常用指令"></a>1.3 Redis常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动容器</span><br>docker run -d -p 6379:6379 -it  --name=&quot;myredis&quot;  redis<br><span class="hljs-meta">#</span><span class="bash"> 输入密码：</span><br>auth 密码<br><span class="hljs-meta">#</span><span class="bash"> 进入redis容器</span><br>docker exec -it myredis  redis-cli<br><span class="hljs-meta">#</span><span class="bash"> 退出</span><br>quit<br>exit<br><span class="hljs-meta">#</span><span class="bash"> 清屏</span><br>clear<br><span class="hljs-meta">#</span><span class="bash"> 获取帮助, 可以使用Tab键来切换</span><br>help 命令名称<br>help @组名<br><span class="hljs-meta">#</span><span class="bash"> 设置/获取数据</span><br>set name xlh<br>get name<br></code></pre></td></tr></table></figure><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>redis数据存储格式</p><ul><li>redis自身是一个map，其中所有的数据都是采用的<font color="FF0000">key：value</font>的形式存储[^1]</li><li>数据类型指的是value部分的类型，key部分都是String</li></ul><h3 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h3><h4 id="2-1-1-基本操作"><a href="#2-1-1-基本操作" class="headerlink" title="2.1.1 基本操作"></a>2.1.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置String</span><br>set key value<br>mset key1 value1 key2 value2...<br><br><span class="hljs-meta">#</span><span class="bash"> 得到String</span><br>get key <br>mget key1 key2...<br><span class="hljs-meta">#</span><span class="bash"> 获取字符串长度</span><br>strlen key<br><br><span class="hljs-meta">#</span><span class="bash"> 删除String</span><br>del key<br><br><span class="hljs-meta">#</span><span class="bash"> 向字符串的后面追加字符，如果有就补在后面，如果没有就新建</span><br>append key value<br></code></pre></td></tr></table></figure><h4 id="2-1-2-单-多指令对比"><a href="#2-1-2-单-多指令对比" class="headerlink" title="2.1.2 单/多指令对比"></a>2.1.2 单/多指令对比</h4><ul><li>单指令对比多指令（对于多指令，如果执行事间过长对于单线程操作时不适用的，注意及时切割）</li></ul><h4 id="2-1-3-拓展操作"><a href="#2-1-3-拓展操作" class="headerlink" title="2.1.3 拓展操作"></a>2.1.3 拓展操作</h4><ul><li><p>String作为数值的操作</p><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。</li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意：<font color="FF0000">按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。</font> 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p><strong>tips：</strong></p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></li><li>此方案适用于所有数据库，且支持数据库集群</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 增长指令，只有当value为数字时才能增长</span><br>incr key  <br>incrby key increment  <br>incrbyfloat key increment <br><br><span class="hljs-meta">#</span><span class="bash"> 减少指令，有当value为数字时才能减少</span><br>decr key  <br>decrby key increment<br></code></pre></td></tr></table></figure><ul><li><strong>指定生命周期</strong><ul><li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置数据的生命周期，单位 秒</span><br>setex key seconds value<br><span class="hljs-meta">#</span><span class="bash"> 设置数据的生命周期，单位 毫秒</span><br>psetex key milliseconds value<br></code></pre></td></tr></table></figure><h4 id="2-1-4-String类型数据操作的注意事项"><a href="#2-1-4-String类型数据操作的注意事项" class="headerlink" title="2.1.4 String类型数据操作的注意事项"></a>2.1.4 String类型数据操作的注意事项</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_3_20210325.png"></p><ul><li><p>key的设置约定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_4_20210326.png"></p></li></ul><h3 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_5_20210326.png"></p><ul><li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>需要的存储结构：一个存储空间保存多个键值对数据</li><li>hash类型：底层使用哈希表结构实现数据存储</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_6_20210325.png"></p><h4 id="2-2-1-基本操作"><a href="#2-2-1-基本操作" class="headerlink" title="2.2.1 基本操作"></a>2.2.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 插入（如果已存在同名的field，会被覆盖）</span><br>hset key field value<br>hmset key field1 value1 field2 value2...<br><br><span class="hljs-meta">#</span><span class="bash"> 取出</span><br>hget key field<br>hgetall key<br><br><span class="hljs-meta">#</span><span class="bash"> 删除</span><br>hdel key field1 field2...<br><br><span class="hljs-meta">#</span><span class="bash"> 获取field数量</span><br>hlen key<br><br><span class="hljs-meta">#</span><span class="bash"> 查看是否存在</span><br>hexists key field<br></code></pre></td></tr></table></figure><h4 id="2-2-2-拓展操作"><a href="#2-2-2-拓展操作" class="headerlink" title="2.2.2 拓展操作"></a>2.2.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取哈希表中所有的字段名或字段值</span> <br>hkeys key<br>hvals key<br><br><span class="hljs-meta">#</span><span class="bash"> 设置指定字段的数值数据增加指定范围的值</span> <br>hincrby key field increment <br>hdecrby key field increment<br><br><span class="hljs-meta">#</span><span class="bash"> 插入（如果已存在同名的field，不会被覆盖）</span><br>hsetnx key field value<br></code></pre></td></tr></table></figure><h4 id="2-2-3-hash类型数据操作的注意事项"><a href="#2-2-3-hash类型数据操作的注意事项" class="headerlink" title="2.2.3 hash类型数据操作的注意事项"></a>2.2.3 hash类型数据操作的注意事项</h4><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong></li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li></ul><h3 id="2-3-List"><a href="#2-3-List" class="headerlink" title="2.3 List"></a>2.3 List</h3><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型：保存多个数据，底层使用双向链表存储结构实现</li><li><strong>元素有序，且可重</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_8_20210326.png"></p><h4 id="2-3-1-基本操作"><a href="#2-3-1-基本操作" class="headerlink" title="2.3.1 基本操作"></a>2.3.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加修改数据,lpush为从左边添加，rpush为从右边添加</span><br>lpush key value1 value2 value3...<br>rpush key value1 value2 value3...<br><br><span class="hljs-meta">#</span><span class="bash"> 查看数据, 从左边开始向右查看. 如果不知道list有多少个元素，end的值可以为-1,代表倒数第一个元素</span><br><span class="hljs-meta">#</span><span class="bash"> lpush先进的元素放在最后,rpush先进的元素放在最前面</span><br>lrange key start end<br><span class="hljs-meta">#</span><span class="bash"> 取出对应索引的元素</span><br>lindex key index<br><span class="hljs-meta">#</span><span class="bash"> 得到长度</span><br>llen key<br><br><span class="hljs-meta">#</span><span class="bash"> 获取并移除元素（从list左边或者右边移除）</span><br>lpop key<br>rpop key<br></code></pre></td></tr></table></figure><h4 id="2-3-2-拓展操作"><a href="#2-3-2-拓展操作" class="headerlink" title="2.3.2 拓展操作"></a>2.3.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><br>blpop key1 key2... timeout<br>brpop key1 key2... timeout<br><br><span class="hljs-meta">#</span><span class="bash"> 移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span><br>lrem key count value<br></code></pre></td></tr></table></figure><h4 id="2-3-3-list类型数据操作注意事项"><a href="#2-3-3-list类型数据操作注意事项" class="headerlink" title="2.3.3 list类型数据操作注意事项"></a>2.3.3 list类型数据操作注意事项</h4><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul><h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><ul><li>新的存储需求：存储大量数据，在查询方面提供更高的效率</li><li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存键，不存值（nil），并且值时不允许重复的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_7_20210325.png"></p><h4 id="2-4-1-基本操作"><a href="#2-4-1-基本操作" class="headerlink" title="2.4.1 基本操作"></a>2.4.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加元素</span><br>sadd key member1 member2...<br><br><span class="hljs-meta">#</span><span class="bash"> 查看元素</span><br>smembers key<br><br><span class="hljs-meta">#</span><span class="bash"> 移除元素</span><br>srem key member<br><br><span class="hljs-meta">#</span><span class="bash"> 查看元素个数</span><br>scard key<br><br><span class="hljs-meta">#</span><span class="bash"> 查看某个元素是否存在</span><br>sismember key member<br></code></pre></td></tr></table></figure><h4 id="2-4-2-拓展操作"><a href="#2-4-2-拓展操作" class="headerlink" title="2.4.2 拓展操作"></a>2.4.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从<span class="hljs-built_in">set</span>中任意选出count个元素</span><br>srandmember key count<br><br><span class="hljs-meta">#</span><span class="bash"> 从<span class="hljs-built_in">set</span>中任意选出count个元素并移除</span><br>spop key count<br><br><span class="hljs-meta">#</span><span class="bash"> 求两个集合的交集、并集、差集</span><br>sinter key1 key2...<br>sunion key1 key2...<br>sdiff key1 key2...<br><br><span class="hljs-meta">#</span><span class="bash"> 求两个<span class="hljs-built_in">set</span>的交集、并集、差集，并放入另一个<span class="hljs-built_in">set</span>中</span><br>sinterstore destination key1 key2...<br>sunionstore destination key1 key2...<br>sdiffstore destination key1 key2...<br><br><span class="hljs-meta">#</span><span class="bash"> 求指定元素从原集合放入目标集合中</span><br>smove source destination key<br></code></pre></td></tr></table></figure><h4 id="2-4-3-Set类型数据操作的注意事项"><a href="#2-4-3-Set类型数据操作的注意事项" class="headerlink" title="2.4.3 Set类型数据操作的注意事项"></a>2.4.3 Set类型数据操作的注意事项</h4><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启动hash中存储值的空间</li></ul><h3 id="2-5-Sorted-set"><a href="#2-5-Sorted-set" class="headerlink" title="2.5 Sorted_set"></a>2.5 Sorted_set</h3><ul><li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式</li><li>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li><li><strong>不重但有序（score）</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_9_20210326.png"></p><h4 id="2-5-1-基本操作"><a href="#2-5-1-基本操作" class="headerlink" title="2.5.1 基本操作"></a>2.5.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 插入元素, 需要指定score(用于排序)</span><br>zadd key score1 member1 score2 member2<br><br><span class="hljs-meta">#</span><span class="bash"> 查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrange key start end [withscore]<br><span class="hljs-meta">#</span><span class="bash"> 查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrevrange key start end [withscore]<br><br><span class="hljs-meta">#</span><span class="bash"> 移除元素</span><br>zrem key member1 member2...<br><br><span class="hljs-meta">#</span><span class="bash"> 按条件获取数据, 其中offset为索引开始位置，count为获取的数目</span><br>zrangebyscore key min max [withscore] [limit offset count]<br>zrevrangebyscore key max min [withscore] [limit offset count]<br><br><span class="hljs-meta">#</span><span class="bash"> 按条件移除元素</span><br>zremrangebyrank key start end<br>zremrangebyscore key min max<br><span class="hljs-meta">#</span><span class="bash"> 按照从大到小的顺序移除count个值</span><br>zpopmax key [count]<br><span class="hljs-meta">#</span><span class="bash"> 按照从小到大的顺序移除count个值</span><br>zpopmin key [count]<br><br><span class="hljs-meta">#</span><span class="bash"> 获得元素个数</span><br>zcard key<br><br><span class="hljs-meta">#</span><span class="bash"> 获得元素在范围内的个数</span><br>zcount min max<br><br><span class="hljs-meta">#</span><span class="bash"> 求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目</span><br>zinterstore destination numkeys key1 key2...<br>zunionstore destination numkeys key1 key2...<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong></li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong></li></ul><h4 id="2-5-2-拓展操作"><a href="#2-5-2-拓展操作" class="headerlink" title="2.5.2 拓展操作"></a>2.5.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看某个元素的索引(排名)</span><br>zrank key member<br>zrevrank key member<br><br><span class="hljs-meta">#</span><span class="bash"> 查看某个元素索引的值</span><br>zscore key member<br><span class="hljs-meta">#</span><span class="bash"> 增加某个元素索引的值</span><br>zincrby key increment member<br></code></pre></td></tr></table></figure><h4 id="2-5-3-sorted-set类型数据操作的注意事项"><a href="#2-5-3-sorted-set类型数据操作的注意事项" class="headerlink" title="2.5.3 sorted_set类型数据操作的注意事项"></a>2.5.3 sorted_set类型数据操作的注意事项</h4><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li></ul><h2 id="3-通用指令"><a href="#3-通用指令" class="headerlink" title="3. 通用指令"></a>3. 通用指令</h2><h3 id="3-1-key-特征"><a href="#3-1-key-特征" class="headerlink" title="3.1 key 特征"></a>3.1 key 特征</h3><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据</li></ul><h3 id="3-2-key通用操作"><a href="#3-2-key通用操作" class="headerlink" title="3.2 key通用操作"></a>3.2 key通用操作</h3><h4 id="3-2-1-基本操作"><a href="#3-2-1-基本操作" class="headerlink" title="3.2.1 基本操作"></a>3.2.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看key是否存在</span><br>exists key<br><br><span class="hljs-meta">#</span><span class="bash"> 删除key</span><br>del key<br><br><span class="hljs-meta">#</span><span class="bash"> 查看key的类型</span><br>type key<br></code></pre></td></tr></table></figure><h4 id="3-2-2-拓展操作"><a href="#3-2-2-拓展操作" class="headerlink" title="3.2.2 拓展操作"></a>3.2.2 拓展操作</h4><ul><li>时效性操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置生命周期</span><br>expire key seconds<br>pexpire key milliseconds<br><span class="hljs-meta">#</span><span class="bash"> Linux下使用时间戳设置有效事件</span><br>expireat key timestamp<br>pexpireat key milliseconds-timestamp<br><br><span class="hljs-meta">#</span><span class="bash"> 查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br>ttl key<br>pttl key<br><br><span class="hljs-meta">#</span><span class="bash"> 将有时限的数据设置为永久有效</span><br>persist key<br></code></pre></td></tr></table></figure><ul><li>查询操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 根据key查询符合条件的数据</span><br>keys pattern<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_10_20210326.png"></p><ul><li>其他操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span><br>rename key newKey<br>renamenx key newKey<br><br><span class="hljs-meta">#</span><span class="bash"> 查看所有关于key的操作, 可以使用Tab快速切换</span><br>help @generic<br></code></pre></td></tr></table></figure><h3 id="3-3-数据库的通用指令"><a href="#3-3-数据库的通用指令" class="headerlink" title="3.3 数据库的通用指令"></a>3.3 数据库的通用指令</h3><p>key重复的问题</p><ul><li>key时程序员定义的</li><li>redis使用中数据量不断增加，key也会不断增多</li><li>数据部分种类，类别混在在一起容易重复或冲突</li></ul><p>解决：数据库</p><ul><li>Redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul><h4 id="3-3-1-基本操作"><a href="#3-3-1-基本操作" class="headerlink" title="3.3.1 基本操作"></a>3.3.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换数据库 0~15</span><br>select index<br><br><span class="hljs-meta">#</span><span class="bash"> 其他操作</span><br>quit<br>ping<br>echo massage<br></code></pre></td></tr></table></figure><h4 id="3-3-2-拓展操作"><a href="#3-3-2-拓展操作" class="headerlink" title="3.3.2 拓展操作"></a>3.3.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 移动数据, 必须保证目的数据库中没有该数据</span><br>mov key db<br><br><span class="hljs-meta">#</span><span class="bash"> 查看该库中数据总量</span><br>dbsize<br></code></pre></td></tr></table></figure><h2 id="4-Jedis"><a href="#4-Jedis" class="headerlink" title="4. Jedis"></a>4. Jedis</h2><ul><li>Java语言连接redis的服务<ul><li>Jedis</li><li>SpringData Redis</li><li>Lettuce</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_11_20210326.png"></p><ul><li><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</li></ul><h3 id="4-1-Java操作redis的步骤"><a href="#4-1-Java操作redis的步骤" class="headerlink" title="4.1 Java操作redis的步骤"></a>4.1 Java操作redis的步骤</h3><ul><li>连接Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数为Redis所在的ip地址和端口号</span><br>Jedis jedis = <span class="hljs-keyword">new</span> Jedis(String host, <span class="hljs-keyword">int</span> port)<br></code></pre></td></tr></table></figure><ul><li>操作Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 操作redis的指令和redis本身的指令几乎一致</span><br>jedis.set(String key, String value);<br></code></pre></td></tr></table></figure><ul><li>断开连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.close();<br></code></pre></td></tr></table></figure><ul><li>常规演示Test</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jedis.test;<br><br><span class="hljs-keyword">import</span> cn.itcast.jedis.util.JedisPoolUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jedis的测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 快速入门</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//2. 操作</span><br>        jedis.set(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * string 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">//存储</span><br>        jedis.set(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        <span class="hljs-comment">//获取</span><br>        String username = jedis.get(<span class="hljs-string">&quot;username&quot;</span>);<br>        System.out.println(username);<br>        <span class="hljs-comment">//可以使用setex()方法存储可以指定过期时间的 key value</span><br>        jedis.setex(<span class="hljs-string">&quot;activecode&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;hehe&quot;</span>);<span class="hljs-comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span><br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// 存储hash</span><br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;23&quot;</span>);<br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;gender&quot;</span>,<span class="hljs-string">&quot;female&quot;</span>);<br>        <span class="hljs-comment">// 获取hash</span><br>        String name = jedis.hget(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>        <span class="hljs-comment">// 获取hash的所有map中的数据</span><br>        Map&lt;String, String&gt; user = jedis.hgetAll(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">// keyset</span><br>        Set&lt;String&gt; keySet = user.keySet();<br>        <span class="hljs-keyword">for</span> (String key : keySet) &#123;<br>            <span class="hljs-comment">//获取value</span><br>            String value = user.get(key);<br>            System.out.println(key + <span class="hljs-string">&quot;:&quot;</span> + value);<br>        &#125;<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * list 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// list 存储</span><br>        jedis.lpush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-comment">//从左边存</span><br>        jedis.rpush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-comment">//从右边存</span><br>        <span class="hljs-comment">// list 范围获取</span><br>        List&lt;String&gt; mylist = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(mylist);<br>        <span class="hljs-comment">// list 弹出</span><br>        String element1 = jedis.lpop(<span class="hljs-string">&quot;mylist&quot;</span>);<span class="hljs-comment">//c</span><br>        System.out.println(element1);<br>        <br>        String element2 = jedis.rpop(<span class="hljs-string">&quot;mylist&quot;</span>);<span class="hljs-comment">//c</span><br>        System.out.println(element2);<br>        <span class="hljs-comment">// list 范围获取</span><br>        List&lt;String&gt; mylist2 = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(mylist2);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// set 存储</span><br>        jedis.sadd(<span class="hljs-string">&quot;myset&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;php&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>);<br>        <span class="hljs-comment">// set 获取</span><br>        Set&lt;String&gt; myset = jedis.smembers(<span class="hljs-string">&quot;myset&quot;</span>);<br>        System.out.println(myset);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * sortedset 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// sortedset 存储</span><br>        jedis.zadd(<span class="hljs-string">&quot;mysortedset&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;亚瑟&quot;</span>);<br>        jedis.zadd(<span class="hljs-string">&quot;mysortedset&quot;</span>,<span class="hljs-number">30</span>,<span class="hljs-string">&quot;后裔&quot;</span>);<br>        jedis.zadd(<span class="hljs-string">&quot;mysortedset&quot;</span>,<span class="hljs-number">55</span>,<span class="hljs-string">&quot;孙悟空&quot;</span>);<br>        <span class="hljs-comment">// sortedset 获取</span><br>        Set&lt;String&gt; mysortedset = jedis.zrange(<span class="hljs-string">&quot;mysortedset&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(mysortedset);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * jedis连接池使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//0.创建一个配置对象</span><br>        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        config.setMaxTotal(<span class="hljs-number">50</span>);<br>        config.setMaxIdle(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//1.创建Jedis连接池对象</span><br>        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//2.获取连接</span><br>        Jedis jedis = jedisPool.getResource();<br>        <span class="hljs-comment">//3. 使用</span><br>        jedis.set(<span class="hljs-string">&quot;hehe&quot;</span>,<span class="hljs-string">&quot;heihei&quot;</span>);<br>        <span class="hljs-comment">//4. 关闭 归还到连接池中</span><br>        jedis.close();;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * jedis连接池工具类使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//通过连接池工具类获取</span><br>        Jedis jedis = JedisPoolUtils.getJedis();<br>        <span class="hljs-comment">//3. 使用</span><br>        jedis.set(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>        <span class="hljs-comment">//4. 关闭 归还到连接池中</span><br>        jedis.close();;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Jedis工具类抽取"><a href="#4-2-Jedis工具类抽取" class="headerlink" title="4.2 Jedis工具类抽取"></a>4.2 Jedis工具类抽取</h3><ul><li>redis.properties(配置文件)</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">host</span>=<span class="hljs-string">127.0.0.1</span><br><span class="hljs-attr">port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">maxTotal</span>=<span class="hljs-string">50</span><br><span class="hljs-attr">maxIdle</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure><ul><li>JedisPoolUtils工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> JedisPool工具类</span><br><span class="hljs-comment">    加载配置文件，配置连接池的参数</span><br><span class="hljs-comment">    提供获取连接的方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisPoolUtils</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jedis.properties&quot;</span>);<br>        <span class="hljs-comment">//创建Properties对象</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">//关联文件</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            pro.load(is);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//获取数据，设置到JedisPoolConfig中</span><br>        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        <br>config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="hljs-string">&quot;maxTotal&quot;</span>)));<br>        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="hljs-string">&quot;maxIdle&quot;</span>)));<br><br>        <span class="hljs-comment">//初始化JedisPool</span><br>        jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,pro.getProperty(<span class="hljs-string">&quot;host&quot;</span>),Integer.parseInt(pro.getProperty(<span class="hljs-string">&quot;port&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Jedis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯天美开发实习一面</title>
    <link href="/2021/03/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%EF%BC%9A%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E4%B8%80%E9%9D%A2/"/>
    <url>/2021/03/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%EF%BC%9A%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="腾讯天美实习一面"><a href="#腾讯天美实习一面" class="headerlink" title="腾讯天美实习一面"></a>腾讯天美实习一面</h1><p>自我介绍</p><p>项目介绍</p><p>你会C++么，会一些脚本语言么？</p><h2 id="1-多线程和多进程的区别？"><a href="#1-多线程和多进程的区别？" class="headerlink" title="1.多线程和多进程的区别？"></a>1.多线程和多进程的区别？</h2><p>“进程是资源分配的最小单位，线程是CPU调度的最小单位”，具体看 <a href="http://blog.csdn.net/bing_bing/article/details/8093552">http://blog.csdn.net/bing_bing/article/details/8093552</a></p><table><thead><tr><th>维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据是分开的:共享复杂，需要用IPC;同步简单</td><td>多线程共享进程数据：共享简单；同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多、切换复杂、CPU利用率低</td><td>占用内存少，切换简单，CPU利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度快</td><td>线程占优</td></tr><tr><td>编程调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会相互影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布</td><td>进程占优</td></tr></tbody></table><p>线程和进程间的比较</p><table><thead><tr><th>子进程继承父进程的属性：</th><th>子线程继承主线程的属性：</th></tr></thead><tbody><tr><td>实际用户ID，实际组ID，有效用户ID，有效组ID；附加组ID；<br/>进程组ID；<br/>会话ID；<br/>控制终端；<br/>设置用户ID标志和设置组ID标志；<br/>当前工作目录；<br/>根目录；<br/>文件模式创建屏蔽字（umask）；<br/>信号屏蔽和安排；<br/>针对任一打开文件描述符的在执行时关闭（close-on-exec）标志；<br/>环境；<br/>连接的共享存储段；<br/>存储映射；<br/>资源限制；</td><td>进程中的所有信息对该进程的所有线程都是共享的；<br/>可执行的程序文本;<br/>程序的全局内存；<br/>堆内存；<br/>栈；<br/>文件描述符；<br/>信号的处理是进程中所有线程共享的（注意：如果信号的默认处理是终止该进程那么即是把信号传给某个线程也一样会将进程杀掉）；</td></tr><tr><td>父子进程之间的区别：</td><td>子线程特有的：</td></tr><tr><td>fork的返回值(=0子进程)；<br/>进程ID不同；<br/>两个进程具有不同的父进程ID；<br/>子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime均被设置为0;<br/>不继承父进程设置的文件锁；<br/>子进程的未处理闹钟被清除；<br/>子进程的未处理信号集设置为空集；</td><td>线程ID;<br/>一组寄存器值；<br/>栈；<br/>调度优先级和策略；<br/>信号屏蔽字；<br/>errno变量；<br/>线程私有数据；</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_1.png"></p><h2 id="2-linux了解么，select、poll、epoll的区别？"><a href="#2-linux了解么，select、poll、epoll的区别？" class="headerlink" title="2.linux了解么，select、poll、epoll的区别？"></a>2.linux了解么，select、poll、epoll的区别？</h2><p><a href="https://zhuanlan.zhihu.com/p/272891398?utm_source=wechat_timeline">https://zhuanlan.zhihu.com/p/272891398?utm_source=wechat_timeline</a></p><h2 id="3-进程间如何通信的？"><a href="#3-进程间如何通信的？" class="headerlink" title="3.进程间如何通信的？"></a>3.进程间如何通信的？</h2><ul><li>管道</li><li>有名管道</li><li>消息队列</li><li>信号</li><li>信号量</li><li>共享内存</li><li>套接字socket</li></ul><h2 id="4-你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？"><a href="#4-你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？" class="headerlink" title="4.你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？"></a>4.你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？</h2><p><font color="FF0000">饿汉是线程安全的，懒汉是线程不安全的所以需要双重检查。双重检查保证了懒汉的线程安全，但是性能会有所损耗。</font></p><h2 id="5-索引是什么？"><a href="#5-索引是什么？" class="headerlink" title="5.索引是什么？"></a>5.索引是什么？</h2><p>排好序的数据结构（InnoDB是B+Tree）</p><h2 id="6-对于事务的了解？怎么实现的-？（回答了事务的特性，实现原理）"><a href="#6-对于事务的了解？怎么实现的-？（回答了事务的特性，实现原理）" class="headerlink" title="6.对于事务的了解？怎么实现的 ？（回答了事务的特性，实现原理）"></a>6.对于事务的了解？怎么实现的 ？（回答了事务的特性，实现原理）</h2><p>ACID（原子性、一致性、隔离性、持久性）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_2.png"></p><h2 id="7-MySQL有缓存么？"><a href="#7-MySQL有缓存么？" class="headerlink" title="7.MySQL有缓存么？"></a>7.MySQL有缓存么？</h2><p>（个人看法：其实数据库查询缓存一般都用redis，mysql8.0后都被移除了，再加上我看javaguide说mysql缓冲不太实用，我就没仔细看，我回答的说这个不是不常用么，回想起来感觉有点尴尬。）</p><p>详细解析见：<a href="https://blog.csdn.net/weixin_34275734/article/details/89624537">https://blog.csdn.net/weixin_34275734/article/details/89624537</a></p><h2 id="8-缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？"><a href="#8-缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？" class="headerlink" title="8.缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？"></a>8.缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？</h2><p>查证了以下好像是一样的FIFO，LRU，LFU</p><h2 id="9-B-Tree、红黑树、hash表的使用场景区别-？"><a href="#9-B-Tree、红黑树、hash表的使用场景区别-？" class="headerlink" title="9.B+Tree、红黑树、hash表的使用场景区别 ？"></a>9.B+Tree、红黑树、hash表的使用场景区别 ？</h2><p>B+Tree和红黑树的对比：</p><ol><li><a href="https://blog.csdn.net/zcf9916/article/details/84915506">https://blog.csdn.net/zcf9916/article/details/84915506</a></li><li><a href="https://blog.csdn.net/ljfirst/article/details/112506408">https://blog.csdn.net/ljfirst/article/details/112506408</a></li></ol><p>hash表：</p><p>区间查找可行性为0</p><p>如果数据量非常庞大，链表过长依然导致查找效率过低，且IO效率低下</p><h2 id="10-有哪些排序算法，复杂度怎么样？（原理和时间复杂度）"><a href="#10-有哪些排序算法，复杂度怎么样？（原理和时间复杂度）" class="headerlink" title="10.有哪些排序算法，复杂度怎么样？（原理和时间复杂度）"></a>10.有哪些排序算法，复杂度怎么样？（原理和时间复杂度）</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_3.png"></p><h2 id="11-你如果学习C-大概需要多少时间？"><a href="#11-你如果学习C-大概需要多少时间？" class="headerlink" title="11.你如果学习C++大概需要多少时间？"></a>11.你如果学习C++大概需要多少时间？</h2><p>额..</p><h2 id="最后一个环节：对面试官提问"><a href="#最后一个环节：对面试官提问" class="headerlink" title="最后一个环节：对面试官提问"></a>最后一个环节：对面试官提问</h2><p>你们部门有Java开发的岗位么</p><p>回答：没有，全部都是C++开发</p>]]></content>
    
    
    <categories>
      
      <category>Interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络总结</title>
    <link href="/2021/03/23/%E8%AE%A1%E7%BD%91/"/>
    <url>/2021/03/23/%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络总结"><a href="#计算机网络总结" class="headerlink" title="计算机网络总结"></a>计算机网络总结</h1><p>本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="JavaGuide面试突袭v4.0，计算机网络">[2]</span></a></sup>以及少量的补充</p><h2 id="1-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#1-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="1. OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>1. OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png"></p><h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><blockquote><p><strong>应用层</strong>：直接为用户的应用进程提供网络服务。</p></blockquote><p><strong>应用层协议</strong>： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候像应用层协议就可以规定这些数据的格式要满足什么形式。</p><p>在互联网中应用层协议很多，如</p><ul><li>域名系统<strong>DNS</strong></li></ul><blockquote><p>域名系统DNS：</p><p>是因特网的一项核心服务，他作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，不用去记住能够背极其直接读取的IP数串。</p></blockquote><ul><li>支持万维网应用的 <strong>HTTP</strong>协议</li></ul><blockquote><p>HTTP协议: </p><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p></blockquote><ul><li>支持电子邮件的 <strong>SMTP</strong>协议</li><li>文件传输 <strong>FTP</strong>等等</li></ul><p>我们把应用层交互的数据单元称为报文。</p><h4 id="1-1-2-表示层"><a href="#1-1-2-表示层" class="headerlink" title="1.1.2 表示层"></a>1.1.2 表示层</h4><blockquote><p><strong>表示层</strong>：在满足用户需求的基础上，尽可能的节省传输费用而设置的，表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。</p></blockquote><p>表示层的<strong>数据转换</strong>包括:</p><ul><li><p>数据加密</p></li><li><p>数据压缩</p></li><li><p>数据格式转换等。</p></li></ul><p>比如传输压缩文件，jpeg或者加密文件等格式。</p><h4 id="1-1-3-会话层"><a href="#1-1-3-会话层" class="headerlink" title="1.1.3 会话层"></a>1.1.3 会话层</h4><blockquote><p>会话层：<strong>管理</strong>主机之间的<strong>会话进程</strong>，即负责建立、管理、终止进程之间的会话。</p></blockquote><h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><blockquote><p><strong>运输层</strong>：为应用进程之间提供端到端的逻辑通讯。</p></blockquote><h4 id="1-2-1-运输层协议⭐"><a href="#1-2-1-运输层协议⭐" class="headerlink" title="1.2.1 运输层协议⭐"></a>1.2.1 运输层协议⭐</h4><p><font color="FF0000"><strong>运输层协议</strong></font>:  IP协议是<strong>主机之间</strong>的通信，TCP和UDP是进程之间的通信。</p><ul><li><p>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）</p><p>提供面向连接的，可靠的数据传输服务</p><ul><li>客户端和服务器之间要保持一个会话直到传输结束</li><li>分段传输建立会话可靠传输流量控制（发送窗口大小根据接收窗口大小确定）</li><li>流量控制、拥塞控制，全双工</li><li>每一条TCP连接有两个端点（套接字：IP+端口号）</li></ul></li><li><p>用户数据协议 <strong>UDP</strong>（User Datagram Protocol）</p><p>提供无连接的，尽最大努力的数据传输服务</p><ul><li>不保证数据传输的可靠性</li><li>不分段</li><li> 支持一对一，一对多，多对一通信</li></ul></li><li><p>TCP和UDP对比<a href="3.TCP/UDP 协议的区别⭐">见问题三</a></p></li></ul><h4 id="1-2-2-本层加端口号"><a href="#1-2-2-本层加端口号" class="headerlink" title="1.2.2 本层加端口号"></a>1.2.2 本层加端口号</h4><p>常见端口：</p><ul><li><p>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制；</p></li><li><p>Telnet（远程登录协议）：23；</p></li><li><p>DNS（域名解析服务）：53；</p></li><li><p>TFTP（简单文件传输协议）：69；</p></li><li><p>HTTP（超文本传输协议）：80</p></li></ul><h4 id="1-2-3-传输层进行差错检测"><a href="#1-2-3-传输层进行差错检测" class="headerlink" title="1.2.3 传输层进行差错检测"></a>1.2.3 传输层进行差错检测</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png"></p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><blockquote><p><strong>网络层</strong>（网际层/IP层）：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。(<strong>路径选择、路由及逻辑寻址</strong>)</p></blockquote><ul><li><p><strong>协议</strong>：ARP IP ICMP IGMP(ARP为IP提供服务，IP为ICMP和IGMP提供服务）</p><ul><li>由于网络层使用 <font color="FF0000"><strong>IP 协议</strong></font>，因此分组也叫 IP 数据报 ，简称<strong>数据报</strong></li><li>无论是哪一层的数据单元都可以笼统的用”分组“表示，主要不要混淆”用户数据包UDP“和网络层的”IP数据报“</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png"></p></li><li><p><strong>特点</strong>：网络层不管发的顺序也不管丢数据不（对方传输层负责），根据目标地址选择合适路径转发。</p></li><li><p><strong>本层加源IP地址与目标IP地址，构成IP数据报。</strong> <strong>IP协议非常简单，仅仅提供不可靠、无连接的传送服务</strong>。 IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p></li><li><p><font color="FF0000"><strong>路由器工作在网络层</strong></font>，在不同网段转发数据。</p></li></ul><h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><blockquote><p>数据链路层：数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 </p></blockquote><ul><li><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <strong>IP 数据报组装成帧</strong>，进行传送。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。</p></li><li><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 </p></li><li><p>封装成帧（帧头、帧尾、物理地址、校验值） 透明传输（字节填充法，传输数据出现控制字符前面插入一个转义字符） 差错校验（循环冗余检验CRC）</p></li></ul><blockquote><p><strong>数据链路层协议</strong>(了解)：</p></blockquote><ul><li><p>PPP（点到点信道） （拨号电话线接入因特网就是PPP）</p></li><li><p>CSMA/CD(带冲突检测的载波监听多路访问协议）（使用广播信道）（局域网）  </p></li><li><p>多路访问：多个设备可以同时访问介质（多个设备在同一信道发送信号协议），一个设备发送的帧也可以被多个设备接收。  </p></li><li><p>载波监听：每一个设备发送数据前，对信道侦听，空闲才可以发送，如果有其他设备正在发暂时不发避免碰撞。</p></li><li><p>碰撞检测：设备边发数据边检测信道上电压大小，一旦出现碰撞，立即停止发送，等待一段时间后再发。 这个协议只能<strong>半双工</strong>通信。</p></li></ul><blockquote><p><strong>以太网</strong>（ 全球使用最广泛的局域网技术）拓扑结构为总线型</p></blockquote><p>以太网的标准<a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91">拓扑</a>结构为<a href="https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91">总线型拓扑</a>，但目前的快速以太网为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a href="https://baike.baidu.com/item/%E6%98%9F%E5%9E%8B">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a href="https://baike.baidu.com/item/CSMA%2FCD">CSMA/CD</a>（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png"></p><blockquote><p>网桥交换机：网桥设备（可以连接集线器）</p></blockquote><p>网桥既有过滤帧的功能。当网桥收到一个帧的时候，并不是像所有接口发此帧，而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口。</p><ul><li><p>网桥口越来越多了就变成了交换机（直接连计算机）</p></li><li><p>交换机前身为网桥</p></li><li><p>交换机口可以存储转发，基于MAC地址转发，通过学习构建MAC地址表</p></li></ul><p><strong>本层加MAC地址</strong></p><h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><blockquote><p>物理层：实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p></blockquote><ul><li><p>在物理层上传送比特流</p></li><li><p>频分复用，时分复用</p></li></ul><blockquote><p>集线器：多接口转发器，工作在物理层</p></blockquote><h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>发送端：</p><ul><li><p>应用程序准备传输的文件</p></li><li><p>传输层  将文件分段 并编号</p></li><li><p>网络层  添加目标IP地址源IP地址</p></li><li><p>数据链路层  两种情况</p><p>使用自己的子网掩码 判断自己在那个网段</p><p>使用自己的子网掩码 判断目标地址在哪个网段</p><ul><li>如果是同一个网段 arp协议广播解析目标IP地址的MAC</li><li>如果不是同一个网段 则mac写网关地址</li></ul></li></ul><hr><p>一些帮助理解的解释：</p><ul><li><p>ARP发送的广播包，目标MAC是全1（48位），交换机会给所有出口转发。得到MAC地址后会缓存，过一段时间不和目标地址通信了，这个缓存会删除掉。</p></li><li><p>交换机根据mac地址转发数据</p></li><li><p>每个计算机配有网关（知道自己所在子网的路由网口地址）</p></li><li><p>点到点信道，物理层地址固定为FF（因为只能这个传给对方，不用看地址）</p></li><li><p>IP地址决定了数据的起点与终点，MAC地址决定了本点和下一跳给谁</p></li><li><p>集线器：</p><p>只负责把比特流传出去，并对信号进行加强，属于物理层设备（与网线差不多，只认比特流）</p></li><li><p>交换机（一个网段内转给其他计算机还是路由器）：</p><p>收完比特流，存储，看目标mac地址，选择出口，工作在第二层数据链路层设备，存储转发（只能看懂mac地址看不懂IP地址）</p></li><li><p>路由器：</p><p>有网卡（接口）接收比特流，可以看懂mac，判断是不是给自己，然后会把mac地址去掉，剩下IP数据报，根据数据报的目标地址按照路由表选择出口（路由器看不懂具体传的数据），出口写上新的MAC地址，为三层设备网络设备</p><p>路由器–网关–交换机三层结构：</p><p>知道IP地址，想知道具体是哪个物理PC机</p><ul><li>首先要通过IP地址的网段查找到是哪个网关的</li><li>然后在网关ARP表中查找mac地址和交换机位置</li><li>然后通过MAC表查找到物理PC机。</li><li>即IP地址-网关-MAC地址-交换机-port-PC机</li></ul><blockquote><p><strong>mac表</strong>：记录交换机接口（端口）和终端MAC的对应关系，即说明交换机哪个端口和终端的哪个MAC地址对应，指的是物理层面的连接关系，存在于交换机当中。</p><p><strong>ARP缓存表</strong>：记录主机的IP地址和MAC地址的对应关系，对于同一台PC机，IP地址是可变的，但是MAC地址是物理网卡的地址，是网卡特有的信息，是不可变的。这个缓存表一般不存在交换机里面，而是在交换机上一层的仪器中，即网关中。这个表里面只能知道IP地址和MAC的对应关系，以及在哪个交换机上连接着，并不能知道在交换机的哪个端口，需要和mac表相结合才能知道。</p><p><strong>路由表</strong>：记录路由器掌握的所有目的地网段，以及到达这些目的的最佳路径</p></blockquote></li><li><p>工作在哪一层指的最高能看懂那一层的内容</p></li><li><p>对方物理层收到比特流后，数据链路层看目标mac地址是给自己的，然后到网络层去掉mac地址剩下IP数据报，然后数据报把IP地址去掉（IP地址）给传输层，传输层排序检查丢包后给应用层</p></li></ul><hr><p>病毒是一个代码，也会分段传，路由器只能看到每一段所以中不了病毒，交换机以及集线器也不会</p><h3 id="1-7-TCP-IP协议有了解吗？"><a href="#1-7-TCP-IP协议有了解吗？" class="headerlink" title="1.7 TCP/IP协议有了解吗？"></a>1.7 TCP/IP协议有了解吗？</h3><p>TCP/IP 协议不是TCP 和IP 这两个协议的合称，而是指因特网整个TCP/IP 协议族，是一系列网络协议的总称。</p><p>TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为</p><ul><li><strong>应用层</strong></li><li><strong>传输层</strong></li><li><strong>网络层</strong></li><li><strong>链路层</strong></li></ul><h2 id="2-TCP-三次握手和四次挥手⭐"><a href="#2-TCP-三次握手和四次挥手⭐" class="headerlink" title="2. TCP 三次握手和四次挥手⭐"></a>2. TCP 三次握手和四次挥手⭐</h2><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p><h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h3><ul><li><p>第一次握手：主机A 发送syn＝1,随机产生seq=x(如1234567) 的数据包到服务器，主机B由SYN=1 知道，A 要求建立联机；</p></li><li><p>第二次握手： 主机B 收到请求后要确认联机信息， 向A 发送ack=( 主机A 的seq+1),syn=1,ack=1,随机产生seq=y(如7654321） 的包</p></li><li><p>第三次握手：主机A 收到后检查ack是否正确，即第一次发送的seq +1,以及位码ACK是否为1，若正确，主机A 会再发送ack =(主机B 的seq+1),ACK=1，主机B 收到后确认</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png"></p><p><strong>序列号</strong>：TCP缓存中字节流分数据段发，序号是这个数据段的第一个字节是整个文件的第几个字节（ 如果传输的数据字节为0，即只有首部，那序列号还增加吗？当syn 或 fin被置1，虽然报文里长度为0（应用层的数据叫报文），计算ack时我们可以认为其长度为1。其他情况（如只有ack）不增加）</p><p><strong>SYN 同步序列编号</strong>(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的<strong>握手信号</strong>。</p><p><strong>确认号ack</strong>：根据收到的数据包的最后一个字节，给信号说下一个该发哪个字节了，这个确认号就是下一个该发得字节号</p><p><strong>ACK</strong>：0确认号无效，1确认号有效</p><blockquote><p>状态变化:</p><ul><li><p>客户端: Close-&gt;SYN_SENT-&gt;ESTABLISHED</p></li><li><p>服务端: Close-&gt;Listen-&gt;SYN_RCVD-&gt;EATABLISHED</p></li></ul></blockquote><h3 id="2-2-为什么要三次握手？"><a href="#2-2-为什么要三次握手？" class="headerlink" title="2.2 为什么要三次握手？"></a>2.2 为什么要三次握手？</h3><p>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收是正常的。 <strong>核心思想</strong>：<font color="FF0000"><strong>让双方都证实对方能发收</strong></font>。</p><ul><li><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h3 id="2-3-两次握手可以么？"><a href="#2-3-两次握手可以么？" class="headerlink" title="2.3 两次握手可以么？"></a>2.3 两次握手可以么？</h3><p>不可以</p><blockquote><p>假如只有前面两次握手，那么服务器在接收到第一次握手信号，发出第二次握手信号后就会开始工作。</p></blockquote><ol><li>服务器角度：可能客户端发送的第一次握手请求传输过程中阻塞，客户端会再次发送一个请求，这个时候服务器先后接收到两次请求，并持续等两个客户端请求发送数据，其实只有一个，服务端却有两个响应，极端情况可能N个，会造成资源浪费。</li><li>客户端角度：假如发送建立连接的请求阻塞，过了一段时间发现没回复，然后再发一个（这次很快到达），然后给确认也很快， 就开始发数据。过了一会第一个阻塞的建立连接的请求也到了，再给一个确认给A，结果A不认了，刚已经收到确认了，就不理了，然后B就得等着传数据（没收到数据过一段就释放了），会造成资源浪费，所以需要第三个数据包的确认</li></ol><h3 id="2-4-第2次握手传回了ACK，为什么还要传回SYN？"><a href="#2-4-第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="2.4 第2次握手传回了ACK，为什么还要传回SYN？"></a>2.4 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。</p><p>而回传SYN则是为了建立并确认从服务端到客户端的通信，还要客户端确认我的发送是否正常（SYN=1了ack才为seq+1）。</p><h3 id="2-5-四次挥手"><a href="#2-5-四次挥手" class="headerlink" title="2.5 四次挥手"></a>2.5 四次挥手</h3><ul><li><p>第一次：主机A 请求断开连接 发送FIN=1 seq=u后，进入终止等待状态1， </p></li><li><p>第二次： 服务端对客户端的请求应答：ACK=1,ack=u+1,seq=v，然后服务器B 就进入关闭等待状态，此时TCP 服务器进程就通知高层应用进程，因而从A 到B 的连接就释放了。此时是“半关闭”状态。即A 不可以发送给B，但是B 可以发送给A。</p></li><li><p>第三次：此时，若B 没有数据报要发送给A 了，其应用进程就通知TCP 释放连接， 服务端请求断开连接：FIN=1，ACK=1,seq=w,ack=u+1，并等待确认。</p></li><li><p>第四次： 客户端对服务端的请求应答： ACK=1，seq=u+1，ack=w+1，A 进入时间等待，注意，此时TCP 连接还没有释放掉，然后经过时间等待计时器设置的2MSL 后，A 才进入到关闭状态。</p></li></ul><p>（FIN：finish）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png"></p><blockquote><p>状态变化：</p><p>客户端：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE</p><p>服务端：ESTABLISHED-&gt;CLOSE_WAIT-&gt; LAST_ACK-&gt;CLOSE</p></blockquote><h3 id="2-7-为什么要四次挥手？"><a href="#2-7-为什么要四次挥手？" class="headerlink" title="2.7 为什么要四次挥手？"></a>2.7 为什么要四次挥手？</h3><p>我们可以看出服务端响应断开连接的请求时，其<font color="FF0000"><strong>ACK和FIN包并不是一起发送给客户端的</strong></font>，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><h3 id="2-8-四次挥手主动方为什么需要等待2MSL"><a href="#2-8-四次挥手主动方为什么需要等待2MSL" class="headerlink" title="2.8 四次挥手主动方为什么需要等待2MSL?"></a>2.8 四次挥手主动方为什么需要等待2MSL?</h3><p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p><blockquote><p>MSL（Maximum Segment Lifetime）： </p><p>表示最大报文生存周期，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。（ 去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)=2MSL）</p></blockquote><p>Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了， 主动关闭方需要等待2MSL是为了，<font color="FF0000"><strong>防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号</strong></font>。（若重发的又没到，客户端就关闭了，server最后就会异常关闭连接，把链接错误问题报告给高层）</p><h3 id="2-9-已经建立连接，但客户端故障怎么办？"><a href="#2-9-已经建立连接，但客户端故障怎么办？" class="headerlink" title="2.9 已经建立连接，但客户端故障怎么办？"></a>2.9 已经建立连接，但客户端故障怎么办？</h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。</p><p>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是<strong>设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔<strong>75</strong>秒发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="3-TCP-UDP-协议的区别⭐"><a href="#3-TCP-UDP-协议的区别⭐" class="headerlink" title="3.TCP/UDP 协议的区别⭐"></a>3.TCP/UDP 协议的区别⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png"></p><ul><li>TCP协议进行数据通信之前需要<strong>三次握手建立连接</strong>，UDP协议不需要建立连接即可发送数据。</li><li>TCP有<strong>确认</strong>机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。<strong>传输可靠性</strong>区别</li><li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</li><li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</li></ul><blockquote><p>UDP（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播、屏幕广播、DNS、多播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p></blockquote><h3 id="3-1-一个网络数据包包括哪些有了解吗？"><a href="#3-1-一个网络数据包包括哪些有了解吗？" class="headerlink" title="3.1 一个网络数据包包括哪些有了解吗？"></a>3.1 一个网络数据包包括哪些有了解吗？</h3><p>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部（链路层）；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png"></p><h3 id="3-2-每一层的数据叫什么名字？"><a href="#3-2-每一层的数据叫什么名字？" class="headerlink" title="3.2 每一层的数据叫什么名字？"></a>3.2 每一层的数据叫什么名字？</h3><p>我们把应用层交互的数据单元称为报文</p><p>传输层：TCP叫报文段，UDP叫用户数据报</p><p>网络层：把运输层的报文段或者用户数据报封装成分组或者包，也叫IP数据报（数据报）</p><p>链路层：帧</p><p>物理层：比特流</p><h3 id="3-3-TCP协议中的数据包分片与重组功能有了解吗？"><a href="#3-3-TCP协议中的数据包分片与重组功能有了解吗？" class="headerlink" title="3.3 TCP协议中的数据包分片与重组功能有了解吗？"></a>3.3 TCP协议中的数据包分片与重组功能有了解吗？</h3><p>当TCP传输的数据包比较大时，在发送方会进行分片，在接收方进行数据包的重组。</p><ul><li><p>发送方：</p><p>将数据包分为多个<strong>TCP头部+数据包</strong>的组合，TCP头部中存着不同的<strong>数据序号</strong>；之后将多个组合交由IP模块，<strong>统一添加IP头部和MAC头部</strong>，IP头部的<strong>ID号</strong>设为统一的。</p></li><li><p>接收方：</p><p>IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在<strong>IP头部</strong>的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中<strong>具有相同ID的包</strong>全部到达。此外，IP头部还有一个<strong>分片偏移量</strong>的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。</p></li></ul><blockquote><p>链路层MTU(Maximum Transmission Unit)：每一种物理网络都会规定链路层数据帧的最大长度。IP协议在传输数据包时，若IP数据报加上数据帧头部后长度大于MTU，则将数据报文分为若干分片进行传输，并在目标系统中进行重组。</p></blockquote><blockquote><p>MSS：是TCP数据包每次能够传输的最大报文分段。</p></blockquote><h3 id="3-4-TCP粘包"><a href="#3-4-TCP粘包" class="headerlink" title="3.4 TCP粘包"></a>3.4 TCP粘包</h3><p>TCP粘包是指一种发送方发送的数据包在接收方的缓冲区中粘成了一包，也就是出现了数据包首尾相接的现象。</p><ul><li><p>产生原因：主要是发送方使用了Nagle算法，或者接收方的处理速度小于数据包的接收速度，导致接收缓冲区中消息堆积。</p></li><li><p>解决方法：可以通过关闭Nagle算法或者规定每个数据包的具体格式和长度，在接收方的应用层来进行判断</p></li></ul><p>还有UDP是不会产生粘包现象的，因为数据包之间具有明确的消息保护边界。</p><h2 id="4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）"><a href="#4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）" class="headerlink" title="4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）"></a>4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）</h2><ul><li><p><strong>确认</strong>：</p><p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储哪些已发送但是未收到确认的报文段，以便重传。</p><p>TCP默认使用<strong>累计确认</strong>，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对<strong>按序</strong>到达的最后一个分组发送确认（中间没到的可能丢了也可能阻塞还没到），这就表示到这个分组为止的所有分组都已经正确收到了。（但是不会立即发送这个确认号的数据包，因为其有可能只是阻塞了还能到，会等到这个报文段设置的重传时间到了还没收到确认就重传）</p></li><li><p><strong>重传：</strong>两种事件会导致TCP对报文段的重传：超时和冗余ACK。</p><ul><li>超时：TCP每发送一个报文段，就对这个报文段设置一次计时器，计时器设置的重传时间到期但还未收到确认，就重传。  </li><li>冗余ACK：超时触发重传的周期往往太长。TCP规定每当比期望序号更大的失序报文段到达时，就发送一个冗余ACK（再次确认某个报文段的ACK，之前已经收到过），TCP规定当发送方接收到对同一报文段的3个冗余ACK时，可以认为这个报文段已经丢失，立即执行重传，也称<strong>快速重传</strong>。</li></ul></li><li><p><strong>序列号</strong>：TCP 给 每个字节的数据都进行了编号，即序列号。 </p><p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答， 也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发（对丢包的会重传）。接收方根据编号会丢弃重复编号的数据（如超时重传中若是因为应答信号丢失，则会再传重复的数据），把有序数据传送给应用层。</p></li><li><p><strong>校验和</strong>： 目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></li></ul><blockquote><p>校验和的计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p><p>发送方：在发送数据之前计算检验和，并进行校验和的填充。 </p><p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png"></p><blockquote><p>如果接收方比对校验和与发送方不一致，数据一定传输有误。</p><p>如果接收方比对校验和与发送方一致，数据不一定传输成功。</p></blockquote><p>此外，TCP协议还通过</p><ul><li><p>流量控制</p></li><li><p>拥塞控制</p></li><li><p>ARQ协议</p></li></ul><p>保证传输的可靠性。</p><h3 id="4-1-TCP-流量控制"><a href="#4-1-TCP-流量控制" class="headerlink" title="4.1 TCP 流量控制"></a>4.1 TCP 流量控制</h3><p>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。 </p><p>TCP 利用滑动窗口实现流量控制，在三次握手阶段，双方互相将自己的<strong>数据接收缓冲池大小</strong>告诉对方。 <strong>接收方有即时窗口</strong>（滑动窗口）， 窗口大小的内容 实际上是接收端接收数据缓冲区的剩余大小，而且接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。 发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度， 如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p><p>那么<strong>发送方</strong>就可以维护一个称为<strong>接收窗口</strong>的变量实现流量控制。</p><h3 id="4-2-TCP-拥塞控制"><a href="#4-2-TCP-拥塞控制" class="headerlink" title="4.2 TCP 拥塞控制"></a>4.2 TCP 拥塞控制</h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><p>发送方维持一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><blockquote><p>发送窗口的上限为接收窗口和拥塞窗口中较小的一个。</p></blockquote><p><strong>拥塞控制与流量控制的区别：</strong></p><ul><li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li></ul><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></p><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1（最大一个报文段的长度），每经过一个传播轮次（即往返时间），cwnd加倍，指数型增长，一直到规定的慢开始门限，然后改用拥塞避免算法。</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1，按照线性增长。（即加法增大）。当出现一次超时（网络拥塞时）。令慢开始门限为当前cwnd的一半，cwnd重置为1，执行慢开始算法（即乘法减小）</p></li><li><p><strong>快重传与快恢复FRR：</strong></p><ul><li>快重传：使用冗余ACK来检测丢包的发生。冗余ACK也用于网络拥塞的检测（丢包当然意味着网络可能出现了拥塞）。</li><li>快恢复：收到三个冗余ACK，执行乘法减小，把慢开始门限减为当前cwnd的一半，但是cwnd不置为1，置为新的慢开始门限值（即减半），然后执行加法增大。由于跳过了cwnd从1开始的慢开始过程所以称为快恢复。</li></ul></li></ul><p><strong>小结</strong>：当发送方检测到超时的时候，采用慢开始+拥塞避免，当发送方接收到冗余ACK时，采用快重传+快恢复</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png"></p><h3 id="4-3-ARQ协议"><a href="#4-3-ARQ协议" class="headerlink" title="4.3 ARQ协议"></a>4.3 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层和传输层</strong>的错误纠正协议之一。使用了<strong>确认和超时</strong>的两个机制。</p><p>ARQ包括：</p><ul><li>停止等待ARQ协议</li><li>连续ARQ协议。</li></ul><blockquote><p>停止等待ARQ协议</p></blockquote><ul><li><p>停止等待协议：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p></li><li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p></li><li><p>优缺点：</p><ul><li>优点： 简单</li><li>缺点： 信道利用率低，等待时间长</li></ul></li><li><p>几种具体情况：</p><ul><li><p>无差错情况:</p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p></li><li><p>出现差错情况（超时重传）:</p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p></li><li><p>确认丢失和确认迟到</p><ul><li>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li><li>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul></li></ul></li></ul><blockquote><p>连续 ARQ 协议</p></blockquote><p>可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认（过一段时间确认一次，发送方其实是按照顺序发送的，可能由于网络原因，包到达的顺序不一致），而发送方每接收到一个确认，窗口就向前滑动一定距离。</p><ul><li>优缺点：<ul><li>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul></li></ul><h2 id="5-在浏览器中输入url地址-—-gt-显示主页的过程"><a href="#5-在浏览器中输入url地址-—-gt-显示主页的过程" class="headerlink" title="5. 在浏览器中输入url地址 —&gt; 显示主页的过程"></a>5. 在浏览器中输入url地址 —&gt; 显示主页的过程</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png"></p><blockquote><p>上图有一个错误，请注意，是OSPF不是OPSF。 </p><p>OSPF（Open Shortest Path Fitst）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li><p><strong>DNS解析</strong></p><blockquote><p>域名解释：<a href="http://www.baidu.com/">www.baidu.com</a>.</p></blockquote><ul><li>以最右边英文.开始，称为域名的根：注意最后一个com的后面有点这个就是根，实际用的时候最后加不加点都行</li><li>.下面这个名称就为顶级域名，代表服务器/网站的性质：<ul><li>com（商业性质） </li><li>edu（教育性质） </li><li>net（提供信息）</li><li>cn（中国） </li><li>org（组织） </li><li>gov（政府部门）</li></ul></li><li>二级域名：自己申请，比如baidu   完全限定域名：FQDN，比如<a href="http://www.baidu.com/">www.baidu.com</a>（后面的<a href="http://baidu.com/">baidu.com</a>已经全球唯一）</li><li>三级域名：<a href="http://kkk.baidu.com/">kkk.baidu.com</a>的kkk就是第三级，也可以四级五级。一般网站习惯用www，也有<a href="http://mail.baidu.com/">mail.baidu.com</a>,也可以<a href="http://wwww.baidu.com/">wwww.baidu.com</a>代表一个域名下的不同服务器，只要对应的IP配正确就可以  谷歌公司的DNS服务器0.0.0.0 电信公司的DNS服务器222.222.222.222）</li></ul><blockquote><p>客户端浏览器通过DNS解析到域名的IP地址。</p></blockquote><p>域名解析的过程：</p><ul><li><p>迭代查询：</p><p>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器向根域名服务器发送请求, 根DNS服务器，不负责具体的域名解析，但是他知道负责解析顶级域名的服务器IP（知道哪个DNS服务器负责哪一块的域名解析），会返回这个IP。本地域名服务器收到这个IP后，联系负责解析该顶级域名的服务器，这个顶级域名的服务器如果自己无法解析就找管理这个二级域名解析的服务器IP地址给本地域名服务器，然后本地域名服务器就去联系这个服务器直到解析成功为止，并把这个IP缓存到本地，供下次查询使用。</p></li><li><p>转发查询：（递归）</p><p>DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。</p><p>若有多个合适的服务器，DNS服务器可以返回一个跟用户最接近的点的IP地址给用户。（DNS负载均衡）</p></li></ul></li><li><p><strong>建立TCP连接</strong></p><p>在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，对于客户端与服务器的TCP链接，必然要说的就是三次握手。</p></li><li><p><strong>浏览器向WEB服务器发起Http请求</strong></p><p>建立TCP连接之后，发起HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（HTTP80端口）</p><ul><li><strong>传输层</strong> 把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。 </li><li><strong>网络层：</strong>添加源IP和目标IP。 </li><li><strong>链路层：</strong>客户端的链路层，发送ARP请求查找下一跳MAC，跨网段是网关的MAC</li><li>HTTP请求报文由三部分组成：<ul><li>请求行（ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD）</li><li>请求头（ HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息）</li><li>请求正文（ 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中）。</li></ul></li></ul></li><li><p><strong>服务器端处理请求并返回HTTP报文</strong></p><ul><li><p>服务器端收到请求后的由web服务器（如 Tomcat）处理请求。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p></li><li><p>HTTP响应报文也是由三部分组成: </p><ul><li>状态码（<a href="7. 常见HTTP状态码">如下述问题</a>）</li><li>响应报头</li><li>响应报文（ 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分）。</li></ul></li></ul></li><li><p><strong>浏览器解析渲染页面</strong></p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p></li></ol><ol start="6"><li><p><strong>关闭TCP链接</strong></p><p>四次挥手</p></li></ol><h2 id="6-Get和Post区别"><a href="#6-Get和Post区别" class="headerlink" title="6. Get和Post区别"></a>6. Get和Post区别</h2><ul><li><p>Get一般是从服务器上请求数据，Post一般是向服务器传送数据。</p></li><li><p>GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。 POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制。</p></li><li><p>GET请求刷新浏览器或回退时没有影响，POST回退时会重新提交数据请求。</p></li><li><p>GET 请求可被浏览器主动缓存， POST 请求不会除非手动设置  GET 请求保留在浏览器历史记录中， 可被收藏为书签； POST 请求不会保留在浏览器历史记录中，  POST 不能被收藏为书签</p></li><li><p>GET 只接受ASCII字符，  POST支持多种编码方式</p></li><li><p>GET产生一个TCP数据包， 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST产生两个TCP数据包， 浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）（ 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次）。</p></li></ul><blockquote><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议， HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</p></blockquote><h2 id="7-常见HTTP状态码"><a href="#7-常见HTTP状态码" class="headerlink" title="7. 常见HTTP状态码"></a>7. 常见HTTP状态码</h2><p>1xx：表示通知信息，例如表示收到或者是正在处理（临时响应）</p><p>2xx：表示成功，例如表示接受或知道了</p><p>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动</p><p>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成</p><p>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p><h2 id="8-HTTP协议和各种协议的关系"><a href="#8-HTTP协议和各种协议的关系" class="headerlink" title="8. HTTP协议和各种协议的关系"></a>8. HTTP协议和各种协议的关系</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png"></p><h2 id="9-HTTP长连接-短连接"><a href="#9-HTTP长连接-短连接" class="headerlink" title="9. HTTP长连接,短连接"></a>9. HTTP长连接,短连接</h2><p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/gotodsp/p/6366163.html">[3]</span></a></sup></p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><blockquote><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p></blockquote><p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损。 </p><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p><ul><li><p>使用场景：</p><ul><li><strong>短链接</strong>：像WEB网站的http服务一般都用短链接</li></ul><p>原因：长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><ul><li><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li></ul></li></ul><h2 id="10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）"><a href="#10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）" class="headerlink" title="10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）"></a>10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）</h2><p>HTTP 是一种不保存状态，即无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。 </p><p>我们可以使用cookie和session来保持会话状态，</p><ul><li><p>会话：一次会话中包含多次请求和响应</p></li><li><p>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</p></li></ul><blockquote><p>cookie和session功能就是在一次会话的范围内的多次请求间，共享数据。</p></blockquote><ul><li><p>客户端会话技术：Cookie，将数据保存到客户端浏览器（cookie一般用于存出少量的不太敏感的数据或是在不登录的情况下，完成服务器对客户端的身份识别）；</p></li><li><p>服务器端会话技术：Session，将数据保存在服务器端的对象中，Session的实现是依赖于Cookie的。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。这样做有一个缺点就是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。</p></li></ul><p>实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</p><blockquote><p>Cookie 被禁用怎么办?</p></blockquote><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p><p>参考回答：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png"></p><h2 id="11-Cookie的作用是什么-和Session有什么区别？"><a href="#11-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="11. Cookie的作用是什么?和Session有什么区别？"></a>11. Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Session没有数据大小限制，Cookie有。</p><p>相对 Cookie 来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="12-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#12-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="12. HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>12. HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><ol><li>在HTTP/1.0中，默认使用的是短连接，HTTP 1.1起，默认使用长连接。 </li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h2 id="13-URI和URL的区别是什么"><a href="#13-URI和URL的区别是什么" class="headerlink" title="13. URI和URL的区别是什么?"></a>13. URI和URL的区别是什么?</h2><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URI就是在某一规则下能把一个资源独一无二地标识出来。如：身份证</li><li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL就是用定位的方式实现的URI。 可认为由4部分组成：协议、主机、端口、路径   http:localhost:8080/index.jsp ( 对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息)  如：具体住址</li></ul><p>​    URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="14-HTTP-和-HTTPS-的区别？"><a href="#14-HTTP-和-HTTPS-的区别？" class="headerlink" title="14. HTTP 和 HTTPS 的区别？"></a>14. HTTP 和 HTTPS 的区别？</h2><ol><li>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li><li>安全性和资源消耗： <ul><li>HTTP协议运行在TCP之上，所有传输的内容都是明文。  </li><li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。（ HTTPS协议在HTTP的基础上加入了SSL（安全套接字层）协议，SSL逐渐演变为了TLS协议，但是业界习惯仍然称其为SSL协议。）所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li></ul></li></ol><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>JavaGuide面试突袭v4.0，计算机网络<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">https://www.cnblogs.com/gotodsp/p/6366163.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
      <tag>Network</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
      <tag>TCP</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BIO_AIO_NIO区别</title>
    <link href="/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="BIO-AIO-NIO区别"><a href="#BIO-AIO-NIO区别" class="headerlink" title="BIO_AIO_NIO区别"></a>BIO_AIO_NIO区别</h1><blockquote><p>简单对比：</p><ul><li>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题的关键其实就是理解同步/异步、阻塞/非阻塞的含义。</p><p>最初我看了很多blog以及一些所谓的面试考题讲解视频，以为理解了同步/异步、阻塞/非阻塞的含义，但其实越想越经不起推敲</p><p>比如下面的一些理解（我认为是不对的）：</p><blockquote><p><del>同步和异步（针对请求），阻塞和非阻塞（针对客户端）</del></p><p><del>在网络请求中，客户端会发出一个请求到服务端</del></p><ol><li><del>客户端发了请求后，就一直等着服务端的返回相应。 客户端：阻塞。 请求：同步</del></li><li><del>客户端发了请求后，就去干别的事情了，时不时来检查服务端是否给出了响应。 客户端：非阻塞。 请求： 同步。</del></li><li><del>换成异步请求后，客户端发出请求后，就坐在椅子上，等着服务端的返回相应。 客户端：阻塞。 请求：异步。</del></li><li><del>客户端发出请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。 客户端：阻塞。 请求：异步。</del></li></ol></blockquote><p>像这样举通俗的例子来说明这几个概念，通常都经不起推敲，原因在于，例子中缺少了一个“操作系统”级别的调度者。</p><ul><li><p>阻塞非阻塞是跟进程/线程严密相关的，而进程/线程又是依赖于操作系统存在的，所以自然不能脱离操作系统来讨论阻塞非阻塞。</p></li><li><p>同步/异步也是跟任务流相关的，所以举例子必须考虑到并发的任务流，不然，肯定很难举出恰当的例子的。</p></li></ul><p>本文的讨论：</p><ul><li><p>限定Linux环境下的network IO作为背景来讨论同步/异步、阻塞/非阻塞的理解。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=" UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/historyasamirror/article/details/5778378">[2]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/112810033">[4]</span></a></sup></p></li><li><p>讨论Java中对应的编程模型</p></li><li><p>对比BIO/NIO的区别<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/83597838">[3]</span></a></sup></p></li></ul><h2 id="1-Linux下的五种I-O模型"><a href="#1-Linux下的五种I-O模型" class="headerlink" title="1.  Linux下的五种I/O模型"></a>1.  Linux下的五种I/O模型</h2><p>Stevens在文章中一共比较了五种IO Model：</p><ul><li>blocking IO</li><li>nonblocking IO</li><li>IO multiplexing</li><li>signal driven IO</li><li>asynchronous IO</li></ul><p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p><blockquote><p>IO发生时涉及的对象和步骤:</p><ul><li>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象:<ul><li>一个是调用这个IO的process (or thread)</li><li>另一个就是系统内核(kernel)</li></ul></li><li>当一个read操作发生时，它会经历两个阶段：<br>   1 等待数据准备 (Waiting for the data to be ready)<br>   2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li><li>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</li></ul></blockquote><h3 id="1-1-阻塞I-O（blocking-I-O）"><a href="#1-1-阻塞I-O（blocking-I-O）" class="headerlink" title="1.1 阻塞I/O（blocking I/O）"></a>1.1 阻塞I/O（blocking I/O）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png"></p><ul><li><p>第一阶段：准备数据</p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。</p></li><li><p>第二阶段：数据拷贝</p><p>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p></li></ul><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。以下是java实现的服务器bio代码（需要掌握），注意阻塞方法阻塞的第一个阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BIO阻塞代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTcpSocket</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建一个ServerSocket连接</span><br>            <span class="hljs-keyword">final</span> ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>            <span class="hljs-comment">// 2.绑定端口号</span><br>            serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 3.当前线程放弃cpu资源等待获取数据</span><br>            System.out.println(<span class="hljs-string">&quot;等待获取数据...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept(); <span class="hljs-comment">// 阻塞方法</span><br>                executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            System.out.println(<span class="hljs-string">&quot;获取到数据...&quot;</span>);<br>                            <span class="hljs-comment">// 4.读取数据</span><br>                            <span class="hljs-keyword">int</span> read = socket.getInputStream().read(bytes); <span class="hljs-comment">// 会阻塞</span><br>                            String result = <span class="hljs-keyword">new</span> String(bytes);<br>                            System.out.println(result);<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                        &#125;<br>                    &#125;<br>                &#125;);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用程序</strong>想要读取数据就会调用<code>recvfrom</code>,而<code>recvfrom</code>会通知OS来执行，OS就会判断<strong>数据报是否准备好</strong>(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会<strong>将数据从内核空间拷贝到用户空间</strong>(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后<code>socket.read()</code>就会解除阻塞，并得到read的结果。</p><h3 id="1-2-非阻塞（Non-Blocking-IO）"><a href="#1-2-非阻塞（Non-Blocking-IO）" class="headerlink" title="1.2 非阻塞（Non-Blocking IO）"></a>1.2 非阻塞（Non-Blocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png"></p><ul><li><p>第一阶段：准备数据</p><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p></li><li><p>第二阶段：数据拷贝</p><p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p></li></ul><p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。一定要注意这个地方，<strong>Non-Blocking还是会阻塞的</strong>。</p><p>以下是java实现的服务器bio代码（需要掌握），注意数据准备阶段是非阻塞方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NIO非阻塞式代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerNioTcpSocket</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建一个ServerSocketChannel连接</span><br>            <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">// 2.绑定端口号</span><br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 设置为非阻塞式</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 非阻塞式</span><br>            SocketChannel socketChannel = serverSocketChannel.accept(); <br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> j = socketChannel.read(byteBuffer);  <span class="hljs-comment">// 此处不会阻塞</span><br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">byte</span>[] bytes = Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());<br>                    System.out.println(<span class="hljs-string">&quot;获取到数据&quot;</span> + <span class="hljs-keyword">new</span> String(bytes));<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;程序执行完毕..&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NIO中提供了集中Channel：<code>ServerSocketChannel；SocketChannel；FileChannel；</code> <code>DatagramChannel</code>只有<code>FileChannel</code>无法设置成非阻塞模式，其他Channel都可以设置为非阻塞模式。</p><p>当设置为非阻塞后，我们的<code>socket.read()</code>方法就会立即得到一个返回结果(成功 or 失败)，我们可以根据返回结果执行不同的逻辑，比如在失败时，我们可以做一些其他的事情。但事实上这种方式也是低效的，因为我们不得不使用轮询方法区一直问OS：“我的数据好了没啊”。第一个代码是该线程不断的轮询，第二个代码是使用selector实现轮询等待有效请求。</p><p>NIO 不会在<code>recvfrom</code>也就是<code>socket.read()</code>时候阻塞，但是还是会在<strong>将数据从内核空间拷贝到用户空间</strong>阻塞。</p><h3 id="1-3-I-O复用-IO-multiplexing"><a href="#1-3-I-O复用-IO-multiplexing" class="headerlink" title="1.3 I/O复用 IO multiplexing"></a>1.3 I/O复用 IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。</p><p>有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p><p>它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png"></p><p>这里用java的NIO示意select</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>); <br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待事件发生...&quot;</span>);<br>            <span class="hljs-comment">// 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br>            <span class="hljs-keyword">int</span> select = selector.select(); <br><br>            System.out.println(<span class="hljs-string">&quot;事件发生了...&quot;</span>);<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectionKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                <span class="hljs-comment">// 删除本次已处理的key， 防止下次select重复处理</span><br>                it.remove();<br>                handle(key);<br>            &#125;      <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了...&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">// 处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 通过Selector监听Channel时对读事件感兴趣</span><br>            sc.register(selector, SelectionKey.OP_READ); <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了...&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据:&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br>            ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes());<br>            sc.write(bufferToWrite);<br>            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable) &#123;<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            System.out.println(<span class="hljs-string">&quot;write事件...&quot;</span>);<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br>            <span class="hljs-comment">// 在有数据往外写的时候在注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">// sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><blockquote><p>多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p></blockquote><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h3 id="1-4-异步I-O-Asynchronous-IO"><a href="#1-4-异步I-O-Asynchronous-IO" class="headerlink" title="1.4 异步I/O(Asynchronous IO)"></a>1.4 异步I/O(Asynchronous IO)</h3><p>linux下的asynchronous IO其实用得很少(所以这里就不贴AIO的java代码了，一般不要求掌握）。先看一下它的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。</p><p>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。</p><h3 id="1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解"><a href="#1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解" class="headerlink" title="1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解"></a>1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解</h3><p>其实是POSIX的定义是这样子的：</p><ul><li><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p></li><li><p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></li></ul><p>核心区别是：synchronous IO做”IO operation”的时候会将process阻塞</p><ol><li><p>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p></li><li><p>而asynchronous IO,当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p></li></ol><blockquote><p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png"></p><p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h3 id="1-6-select，poll，epoll区别"><a href="#1-6-select，poll，epoll区别" class="headerlink" title="1.6 select，poll，epoll区别"></a>1.6 select，poll，epoll区别</h3><p>知乎这篇文章把底层讲得很清楚（一共三篇）：<a href="https://zhuanlan.zhihu.com/p/64746509">https://zhuanlan.zhihu.com/p/64746509</a></p><p>他们是NIO中多路复用的三种实用机制（底层是三个C++的API），是由Linux操作系统提供的。</p><p>Unix，Linux操作系统的一些基本知识：</p><ul><li><p>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间</p></li><li><p>文件描述符File Descriptor（FD）：是一个抽象概念，形式上是一个整数，实际上是一个索引值。指向内核中为每一个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD。</p></li></ul><blockquote><p>select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。（fd_set是一个数组结构，拷贝大小受限制 x64最大2048）</p><p>poll机制：和select机制差不多的。将fd_set结构进行了优化，FD集合大小突破了操作系统限制。（pollfd结构来代替fd_set，通过链表实现的）</p><p>Epoll机制：Event Poll不在扫描所有的FD，只将用户关心的FD的事件存放到内核的一个事件表当中。可以减少用户空间与内核空间之间需要拷贝的数据。</p></blockquote><table><thead><tr><th></th><th>操作方式</th><th>底层实现</th><th>最大连接数</th><th>IO效率</th></tr></thead><tbody><tr><td>select（1984）</td><td>遍历</td><td>数组</td><td>受限于内核</td><td>一般</td></tr><tr><td>poll（1997）</td><td>遍历</td><td>链表</td><td>无上限</td><td>一般</td></tr><tr><td>epoll（2002）</td><td>事件回调</td><td>红黑树</td><td>无上限</td><td>高</td></tr></tbody></table><p>Java NIO当中是使用哪一种机制？</p><p>基于内核版本，可以查看DefaultSelectorProvider源码：</p><ul><li><p>windows下，WindowsSelectorProvider。</p></li><li><p>Linux下，内核2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。</p></li></ul><h2 id="2-Java的IO编程模型"><a href="#2-Java的IO编程模型" class="headerlink" title="2. Java的IO编程模型"></a>2. Java的IO编程模型</h2><blockquote><p>BIO 同步阻塞IO。 可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。</p><p>编程模型最简单。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复习黑马文件上传的服务端BIO代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动..... &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept(); <span class="hljs-comment">// 阻塞方法</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">            Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() ‐&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() +<br>                    <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != ‐<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果不活跃的连接逐渐增多，线程池里的线程慢慢的也都开始阻塞等待IO，线程池里真正在运行的线程数会越来越少，当线程池处理不过来时，会放置到线程池配置的BlockingQueue中，队列塞满后，慢慢的线程池中线程的数目会逐渐达到线程池配置的maximumPoolSize，如果再处理不过来，执行拒绝策略。也就是说，<code>最终会导致请求无法及时处理。</code></p><p>这样带来的问题是，假设有线程池corePoolSize设置为100，只要有100个不活跃的连接正在阻塞读写IO，就会把前corePoolSize线程都阻塞住，后续的请求就无法及时处理。</p><blockquote><p>NIO 同步非阻塞IO。 可靠性比较好，吞吐量也比较高，适用于连接比较多且连接比较短（轻操作）。例如聊天室。JDK1.4开始支持。（应用最广）</p><p>编程模型最复杂。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png"></p><p>NIO非阻塞体现:</p><ul><li>accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</li><li>首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</li></ul><p>(我的一些看法，java的NIO就是Linux中IO复用和NIO两个模型的结合)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>); <br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待事件发生...&quot;</span>);<br>            <span class="hljs-comment">// 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br>            <span class="hljs-keyword">int</span> select = selector.select(); <br><br>            System.out.println(<span class="hljs-string">&quot;事件发生了...&quot;</span>);<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectionKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                <span class="hljs-comment">// 删除本次已处理的key， 防止下次select重复处理</span><br>                it.remove();<br>                handle(key);<br>            &#125;      <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了...&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">// 处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 通过Selector监听Channel时对读事件感兴趣</span><br>            sc.register(selector, SelectionKey.OP_READ); <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了...&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据:&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br>            ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes());<br>            sc.write(bufferToWrite);<br>            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable) &#123;<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            System.out.println(<span class="hljs-string">&quot;write事件...&quot;</span>);<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br>            <span class="hljs-comment">// 在有数据往外写的时候在注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">// sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AIO 异步非阻塞IO。解决了服务端需要一直守着线程的问题，可靠性是最好的，吞吐量也是非常高的，适用于连接比较多且比较长（重操作）。 例如相册服务器。 JDK7开始支持。</p><p>编程模型比较简单，但需要操作系统来支持异步服务。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码(了解)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open().bind(<span class="hljs-keyword">new</span> InewSocketAddress(<span class="hljs-number">9000</span>));<br>        <br>        serverChannel.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHander&lt;AsynchronousServerSocketChannel, Object&gt;())&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(AsynchronousServerSocketChannel socketChannel, Object attachment)</span></span>&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-comment">// 再次接受客户端连接，如果不写这一行代码后面的客户端连接不上服务器端</span><br>                    serverChannel.accept(attachment, <span class="hljs-keyword">this</span>);<br>                    System.out.println(socketChannel.getRemoteAddress());<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    socketChannel.read(buffer, buffer, <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer buffer)</span></span>&#123;<br>                            buffer.flip();<br>                            System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, result));<br>                            socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes()));<br>                        &#125;<br>                        <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;exc.printStackTrace();&#125;<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;exc.printStackTrace();&#125;<br>        &#125;);<br>        <br>        Thread.sleep(Integer.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-BIO-NIO区别"><a href="#3-BIO-NIO区别" class="headerlink" title="3. BIO/NIO区别"></a>3. BIO/NIO区别</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png"></p><h2 id="4-BIO、NIO、AIO适用场景"><a href="#4-BIO、NIO、AIO适用场景" class="headerlink" title="4. BIO、NIO、AIO适用场景"></a>4. BIO、NIO、AIO适用场景</h2><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><h2 id="5-Java-NIO的3个核心组件"><a href="#5-Java-NIO的3个核心组件" class="headerlink" title="5. Java NIO的3个核心组件"></a>5. Java NIO的3个核心组件</h2><blockquote><p>NIO重点:</p><p>Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><blockquote><p>简单解释：</p></blockquote><ul><li><p>每一个channel对应一个buffer缓冲区。</p></li><li><p>channel会注册到selector。</p></li><li><p>selector会根据channel上发生的读写事件，将请求交由某一个空闲线程处理。</p></li><li><p>selector对应一个或者多个线程。</p></li><li><p>buffer和channel都是可读可写的。</p></li></ul><h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p><p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p><ul><li>ByteBuffer：字节缓冲区</li><li>CharBuffer:字符缓冲区</li><li>ShortBuffer：短整型缓冲区</li><li>IntBuffer：整型缓冲区</li><li>LongBuffer:长整型缓冲区</li><li>FloatBuffer：浮点型缓冲区</li><li>DoubleBuffer：双精度浮点型缓冲区</li></ul><h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p><p>Channel有四种实现：</p><ul><li>FileChannel:是从文件中读取数据。</li><li>DatagramChannel:从UDP网络中读取或者写入数据。</li><li>SocketChannel:从TCP网络中读取或者写入数据。</li><li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li></ul><h3 id="5-3-多路复用器Selector"><a href="#5-3-多路复用器Selector" class="headerlink" title="5.3 多路复用器Selector"></a>5.3 多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p><p><strong>关键对象</strong></p><ul><li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li><li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li></ul><p><strong>监听注册</strong></p><p>监听注册在Selector</p><blockquote><p>socketChannel.register(selector, SelectionKey.OP_READ);</p></blockquote><p><strong>监听的事件有</strong></p><ul><li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li><li>OP_READ: 读取就绪，socketChannel使用</li><li>OP_WRITE: 写入就绪，socketChannel使用</li><li>OP_CONNECT: 连接就绪，socketChannel使用</li></ul><h3 id="5-4-NIO的一些应用和框架"><a href="#5-4-NIO的一些应用和框架" class="headerlink" title="5.4 NIO的一些应用和框架"></a>5.4 NIO的一些应用和框架</h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p><p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/83597838">https://zhuanlan.zhihu.com/p/83597838</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/112810033">https://zhuanlan.zhihu.com/p/112810033</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Network</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL并发时经典的死锁及解决方法</title>
    <link href="/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL并发时经典的死锁及解决方法"><a href="#MySQL并发时经典的死锁及解决方法" class="headerlink" title="MySQL并发时经典的死锁及解决方法"></a>MySQL并发时经典的死锁及解决方法</h1><h2 id="1-MySQL都有锁分类"><a href="#1-MySQL都有锁分类" class="headerlink" title="1. MySQL都有锁分类"></a>1. MySQL都有锁分类</h2><blockquote><p>MySQL有三种锁的级别：页级、表级、行级。</p></blockquote><ul><li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></li><li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p></li><li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></li></ul><blockquote><p>算法</p></blockquote><ul><li><p>Next-KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap   </p></li><li><p>Gap锁，不锁记录，仅仅记录前面的Gap</p></li><li><p>Recordlock锁（锁数据，不锁Gap）</p></li></ul><p>总结：所以其实 Next-KeyLocks = Gap锁 + Recordlock锁</p><h2 id="2-什么情况下会造成死锁"><a href="#2-什么情况下会造成死锁" class="headerlink" title="2. 什么情况下会造成死锁"></a>2. 什么情况下会造成死锁</h2><blockquote><p>所谓死锁<DeadLock>: </p><p>是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p></blockquote><p>死锁的关键在于：<strong>两个(或以上)的Session加锁的顺序不一致</strong>。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p><h2 id="3-一些常见的死锁案例"><a href="#3-一些常见的死锁案例" class="headerlink" title="3.  一些常见的死锁案例"></a>3.  一些常见的死锁案例</h2><h3 id="3-1-案例一"><a href="#3-1-案例一" class="headerlink" title="3.1 案例一"></a>3.1 案例一</h3><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>抽象出来就是一个session通过for循环会有几条如下的语句：</p><p>Select * from xxx where id=’随机id’ for update</p><p>基本来说，程序开启后不一会就死锁。</p><p>这可以是说最经典的死锁情形了。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p><strong>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Select * from xxx where id in (xx,xx,xx) for update<br></code></pre></td></tr></table></figure><p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs mysql">例如（以下会话id为主键）：<br><br>Session1:<br><br>mysql&gt; select * from t3 where id in (8,9) for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>|  8 | WA     | f    | 2016-03-02 11:36:30 |<br><br>|  9 | JX     | f    | 2016-03-01 11:36:30 |<br><br>+----+--------+------+---------------------+<br><br>2 rows in set (0.04 sec)<br><br> <br><br> <br><br>Session2:<br><br>select * from t3 where id in (10,8,5) for update;<br><br>锁等待中……<br><br>其实这个时候id&#x3D;10这条记录没有被锁住的，但id&#x3D;5的记录已经被锁住了，锁的等待在id&#x3D;8的这里。<br><br> <br><br>不信请看<br><br>Session3:<br><br>mysql&gt; select * from t3 where id&#x3D;5 for update;<br><br>锁等待中<br><br> <br><br>Session4:<br><br>mysql&gt; select * from t3 where id&#x3D;10 for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>| 10 | JB     | g    | 2016-03-10 11:45:05 |<br><br>+----+--------+------+---------------------+<br><br>1 row in set (0.00 sec)<br><br> <br><br>在其它session中id&#x3D;5是加不了锁的，但是id&#x3D;10是可以加上锁的。<br></code></pre></td></tr></table></figure><h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">以id为主键为例，目前还没有id&#x3D;22的行<br><br>Session1:<br><br>select * from t3 where id&#x3D;22 for update;<br><br>Empty set (0.00 sec)<br><br> <br><br>session2:<br><br>select * from t3 where id&#x3D;23  for update;<br><br>Empty set (0.00 sec)<br><br> <br><br>Session1:<br><br>insert into t3 values(22,&#39;ac&#39;,&#39;a&#39;,now());<br><br>锁等待中……<br><br> <br><br>Session2:<br><br>insert into t3 values(23,&#39;bc&#39;,&#39;b&#39;,now());<br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br></code></pre></td></tr></table></figure><p>当对<font color="FF0000">存在的行</font>进行锁的时候(主键)，mysql就只有行锁。</p><p>当对<font color="FF0000">未存在的行</font>进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有Gap锁）</p><blockquote><p>锁住的范围为：</p><p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p></blockquote><p>如：如果表中目前有已有的id为（11 ， 12）</p><p>那么就锁住（12，无穷大）</p><p>如果表中目前已有的id为（11 ， 30）</p><p>那么就锁住（11，30）</p><p><strong>对于这种死锁的解决办法是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t3(xx,xx) on duplicate key update xx&#x3D;&#39;XX&#39;;<br></code></pre></td></tr></table></figure><p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p><h3 id="3-3-案例三"><a href="#3-3-案例三" class="headerlink" title="3.3 案例三"></a>3.3 案例三</h3><p>直接上情景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t3 where id&#x3D;9 for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>|  9 | JX     | f    | 2016-03-01 11:36:30 |<br><br>+----+--------+------+---------------------+<br><br>1 row in set (0.00 sec)<br><br> <br><br>Session2:<br><br>mysql&gt; select * from t3 where id&lt;20 for update;<br><br>锁等待中<br><br> <br><br>Session1:<br><br>mysql&gt; insert into t3 values(7,&#39;ae&#39;,&#39;a&#39;,now());<br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br></code></pre></td></tr></table></figure><p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p><p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p><p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/zejin2008/p/5262751.html%E8%BD%AC%E8%BD%BD%E8%AF%A5%E6%96%87">https://www.cnblogs.com/zejin2008/p/5262751.html转载该文</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 断点调试技巧</title>
    <link href="/2021/03/15/IDEA%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <url>/2021/03/15/IDEA%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA-断点调试技巧"><a href="#IDEA-断点调试技巧" class="headerlink" title="IDEA 断点调试技巧"></a>IDEA 断点调试技巧</h1><p>简单记录一下IDEA最常用到的debug方式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV1ur4y1P7SV?">[1]</span></a></sup></p><h1 id="1-行断点"><a href="#1-行断点" class="headerlink" title="1. 行断点"></a>1. 行断点</h1><p>普通在左侧打的断点就是行断点</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><h1 id="2-详细断点-源断点"><a href="#2-详细断点-源断点" class="headerlink" title="2. 详细断点 | 源断点"></a>2. 详细断点 | 源断点</h1><p>按住<code>shift</code>键加上鼠标点击代码左侧出现下图</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li><p>如果我们只勾选Enabled，再点击右下角done，则调试效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li>我们可以看到该断点并没有挂起，只是打出断点所触发的位置（具体的类及所在方法）</li></ul></li><li><p>勾选Suspend（挂起）和All，再点击右done，实际就是打了普通行断点，全部线程都会停止</p></li><li><p>勾选Suspend（挂起）和Thread，再点击done，只有<strong>当前线程才会在该断点停止</strong></p></li><li><p>condition中可以添加一些if else条件判断，但触发条件才会停止（高阶用法）</p></li></ul><h1 id="3-方法断点-接口跳转实现类"><a href="#3-方法断点-接口跳转实现类" class="headerlink" title="3. 方法断点 | 接口跳转实现类"></a>3. 方法断点 | 接口跳转实现类</h1><ul><li><p>方法断点既在方法左侧打的断点，如下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li><p>我们可以发现，该断点在进入方法第一句和方法返回的最后一句都会停止</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B92.png"></p></li></ul></li></ul><ul><li><p>如果是在接口的方法打方法断点，则会跳转到相应的实现类的方法第一句和返回出停止</p><ul><li>因此当我们不知道具体是哪一个实现类时可以直接在接口打方法断点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B93.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B94.png"></p></li></ul><h1 id="4-异常断点-全局捕获"><a href="#4-异常断点-全局捕获" class="headerlink" title="4. 异常断点 | 全局捕获"></a>4. 异常断点 | 全局捕获</h1><p>点击左下的断点图标如图</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9.png"></p><p>则会显示这么一个界面</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B92.png"></p><p>先选中Exception Breakpoints，在点左上加号添加</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B93.png"></p><p>再选中第三项</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B94.png"></p><p>那么可以再弹出窗口搜索你想要全局捕获的异常断点，也可以搜索你自己定义的异常</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B95.png"></p><p>最后添加并点击done确认</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B96.png"></p><p>那么在debug时就能捕获到异常并停下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B97.png"></p><h1 id="5-字段断点-读写监控"><a href="#5-字段断点-读写监控" class="headerlink" title="5. 字段断点 | 读写监控"></a>5. 字段断点 | 读写监控</h1><p>在类的成员变量左侧打断点</p><p>可以监控这个成员整个生命周期值的变化</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_%E5%AD%97%E6%AE%B5%E6%96%AD%E7%82%B9.png"></p><p>下面我们看看debug的效果</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_%E5%AD%97%E6%AE%B5%E6%96%AD%E7%82%B92.png"></p><p>我们可以看到在字段断点在监控的某一个字段某一个属性值一旦发生写的操作，改变了它的值就会触发停顿。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1ur4y1P7SV">https://www.bilibili.com/video/BV1ur4y1P7SV</a>?<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级</title>
    <link href="/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p>基于<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">MySQL高级</a>的学习笔记，由于有些讲得不够全，做了部分补充<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV12b411K7Zu?p=179">[2]</span></a></sup></p><blockquote><p>内容说明：</p><p>MySQL 是目前最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 也是目前最好的 RDBMS 应用软件之一。随着淘宝去IOE(去除IBM小型机、Oracle数据库及EMC存储设备)化的推进，MySQL 数据库在当前的互联网应用中变得越来越重要。</p><p>包括的MySQL 高级知识：索引，如何避免索引失效，索引优化策略，innodb和myisam存储引擎，MySQL锁机制，配置MySQL主从复制，explain、show profile、慢查询日志等日常SQL诊断和性能分析策略。</p></blockquote><h2 id="1-MySQL的架构介绍"><a href="#1-MySQL的架构介绍" class="headerlink" title="1.MySQL的架构介绍"></a>1.MySQL的架构介绍</h2><h3 id="1-1-MySQL简介"><a href="#1-1-MySQL简介" class="headerlink" title="1.1 MySQL简介"></a>1.1 MySQL简介</h3><ul><li><p>概述：关系型数据库管理系统RDBMS</p></li><li><p>高级MySQL：完整的mysql优化需要很深的功底，大公司有专门的DBA</p><ul><li><p>数据库内部结构和原理</p></li><li><p>数据库建模优化</p></li><li><p>数据库索引建立</p></li><li><p>SQL语句优化</p></li><li><p>SQL编程</p></li><li><p>mysql服务器安装配置</p></li><li><p>数据库的性能监控分析与系统优化</p></li><li><p>各种参数常量设定</p></li><li><p>主从复制</p></li><li><p>分布式架构搭建、垂直切割和水平切割</p></li><li><p>数据迁移</p></li><li><p>容灾备份和恢复</p></li><li><p>shell或python等脚本语言开发</p></li><li><p>对开源数据库进行二次开发</p></li></ul></li></ul><h3 id="1-2-MysqlLinux版的安装（mysql5-5）"><a href="#1-2-MysqlLinux版的安装（mysql5-5）" class="headerlink" title="1.2 MysqlLinux版的安装（mysql5.5）"></a>1.2 MysqlLinux版的安装（mysql5.5）</h3><ul><li>下载地址：</li></ul><p>官网下载地址：<a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a>     </p><ul><li><p>拷贝&amp;解压缩</p></li><li><p>检查工作</p><ul><li><p>检查是否安装过mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 执行安装命令前，先执行查询命令</span><br>rpm -qa|grep mysql<br><span class="hljs-meta">#</span><span class="bash"> 如果存在mysql-libs的旧版本包如下：请先执行卸载命令</span><br>rpm -e --nodeps  mysql-libs  <br></code></pre></td></tr></table></figure></li><li><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -R 777 /tmp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在mysql的安装文件目录下执行：</span><br>rpm -ivh MySQL-server-5.5.54-1.linux2.6.x86_64.rpmrpm -ivh MySQL-client-5.5.54-1.linux2.6.x86_64.rpm <br></code></pre></td></tr></table></figure></li></ul><ul><li><p>查看MySQL安装版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqladmin --version<br></code></pre></td></tr></table></figure></li><li><p>mysql服务的启+停</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start<br>ps -ef|grep mysql # 查看服务是否开启<br>service mysql stop<br></code></pre></td></tr></table></figure></li><li><p>首次登陆</p><p>安装完成后会提示出如下的提示：在mysql首次登录前要给 root 账号设置密码 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动服务后，执行命令</span> <br>/usr/bin/mysqladmin -u root  password &#x27;123123&#x27;<br><span class="hljs-meta">#</span><span class="bash"> 登录</span> <br>mysql -uroot -p123123  <br></code></pre></td></tr></table></figure></li><li><p>自启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chkconfig mysql on # 设置开机自启动<br>chkconfig --list | grep mysql<br>ntsysv # 看到[*]mysql这一行，表示开机后会自启动mysql<br></code></pre></td></tr></table></figure></li><li><p>mysql的安装位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef|grep mysql # 在linux下查看安装目录<br></code></pre></td></tr></table></figure><p> 参数路径解释备注</p><ul><li><p>basedir:  /usr/bin 相关命令目录mysqladmin mysqldump等命令</p></li><li><p>datadir: /var/lib/mysql/ mysql数据库文件的存放路径 </p></li><li><p>plugin-dir: /usr/lib64/mysql/pluginmysql插件存放路径</p></li><li><p>log-error: /var/lib/mysql/jack.atguigu.errmysql错误日志路径</p></li><li><p>pid-file: /var/lib/mysql/jack.atguigu.pid进程pid文件</p></li><li><p>socket:/var/lib/mysql/mysql.sock本地连接时用的unix套接字文件</p></li><li><p>/usr/share/mysql 配置文件目录mysql脚本及配置文件</p></li><li><p>/etc/init.d/mysql服务启停相关脚本 </p></li></ul></li><li><p>mysql修改字符集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 查看字符集设置</span><br>show variables like &#x27;character%&#x27;;<br>show variables like &#x27;%char%&#x27;;<br><span class="hljs-meta">#</span><span class="bash"> 默认的是客户端和服务器都用了latin1，所以会乱码</span><br><br><span class="hljs-meta">#</span><span class="bash"> 2. 修改my.cnf</span><br><span class="hljs-meta">#</span><span class="bash"> 在/usr/share/mysql/ 中找到my.cnf的配置文件，拷贝其中的my-huge.cnf 到/etc/, 并命名为my.cnf mysql</span><br><span class="hljs-meta">#</span><span class="bash"> 优先选中/etc/下的配置文件然后修改my.cnf:</span><br>[client]<br>default-character-set=utf8<br>[mysqld]<br>character_set_server=utf8character_set_client=utf8collation-server=utf8_general_ci<br>[mysql]<br>default-character-set=utf8<br><br><span class="hljs-meta">#</span><span class="bash"> 3. 重新启动mysql</span><br><span class="hljs-meta">#</span><span class="bash"> 但是原库的设定不会发生变化，参数修改之对新建的数据库生效</span> <br><br><span class="hljs-meta">#</span><span class="bash"> 4. 已生成的库表字符集如何变更修改数据库的字符集</span><br>alter database mytest character set &#x27;utf8&#x27;;<br><span class="hljs-meta">#</span><span class="bash"> 修改数据表的字符集</span><br>alter table user convert to  character set &#x27;utf8&#x27;; <br>但是原有的数据如果是用非&#x27;utf8&#x27;编码的话，数据本身不会发生改变。     <br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-mysql配置文件"><a href="#1-3-mysql配置文件" class="headerlink" title="1.3 mysql配置文件"></a>1.3 mysql配置文件</h3><p>  （先大致了解，混个眼熟）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p><h3 id="1-4-mysql逻辑框架简介"><a href="#1-4-mysql逻辑框架简介" class="headerlink" title="1.4 mysql逻辑框架简介"></a>1.4 mysql逻辑框架简介</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png"></p><blockquote><p>和其它数据库相比，MySQL有点与众不同，<strong>它的架构可以在多种不同场景中应用并发挥良好作用</strong>。</p><p>主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。</p><p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p></blockquote><ul><li><p>连接层 </p><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p></li><li><p>服务层</p><ol><li>Management Serveices &amp; Utilities： 系统管理和控制工具 </li><li>SQL Interface: SQL接口   接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li><li>Parser: 解析器    SQL命令传递到解析器的时候会被解析器验证和解析。</li><li> Optimizer: 查询优化器。   SQL语句在查询之前会使用查询优化器对查询进行优化。   用一个例子就可以理解： select uid,name from user where gender= 1;   优化器来决定先投影还是先过滤。</li><li>Cache和Buffer： 查询缓存。   如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。   这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等    缓存是负责读，缓冲负责写。</li></ol></li><li><p>引擎层 </p><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB </p></li><li><p>存储层 </p><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p></li></ul><h3 id="1-5-mysql存储引擎"><a href="#1-5-mysql存储引擎" class="headerlink" title="1.5 mysql存储引擎"></a>1.5 mysql存储引擎</h3><h4 id="1-5-1-查看命令"><a href="#1-5-1-查看命令" class="headerlink" title="1.5.1 查看命令"></a>1.5.1 查看命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 看你的mysql现在已提供什么存储引擎</span><br>show engines; <br><span class="hljs-meta">#</span><span class="bash"> 看你的mysql当前默认的存储引擎:</span>  <br>show variables like &#x27;%storage_engine%&#x27;; <br></code></pre></td></tr></table></figure><h4 id="1-5-2-MyISAM和InnoDB"><a href="#1-5-2-MyISAM和InnoDB" class="headerlink" title="1.5.2  MyISAM和InnoDB"></a>1.5.2  <font color=#FF0000><strong>MyISAM和InnoDB</strong></font></h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png"></p><h4 id="1-5-3-各个存储引擎介绍"><a href="#1-5-3-各个存储引擎介绍" class="headerlink" title="1.5.3 各个存储引擎介绍"></a>1.5.3 各个存储引擎介绍</h4><ol><li><strong>InnoDB</strong>存储引擎：InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况 </li><li><strong>MyISAM</strong>存储引擎：MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 </li><li>Archive引擎：Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。 </li><li>Blackhole引擎：Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </li><li>CSV引擎：CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。 </li><li>Memory引擎：如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis) </li><li>Federated引擎：Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。 </li></ol><h4 id="1-5-4-阿里巴巴、淘宝用哪个"><a href="#1-5-4-阿里巴巴、淘宝用哪个" class="headerlink" title="1.5.4 阿里巴巴、淘宝用哪个"></a>1.5.4 阿里巴巴、淘宝用哪个</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png"></p><h2 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2.  索引优化分析"></a>2.  索引优化分析</h2><h3 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png"></p><h3 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png"></p><ul><li><p>SQL解析：机读顺序（先from）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png"></p></li><li><p>Join图（重点，基本功一定要记住）：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BEx.png"></p></li></ul><h3 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h3><h4 id="2-3-1-索引是什么（重点）"><a href="#2-3-1-索引是什么（重点）" class="headerlink" title="2.3.1 索引是什么（重点）"></a>2.3.1 索引是什么（重点）</h4><blockquote><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p></blockquote><ul><li><p><strong>索引的本质</strong>：索引是<font color=#FF0000>数据结构</font></p></li><li><p>索引的目的：在于提高查询效率</p><p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p></li><li><p>简单理解： <font color=#FF0000><strong>索引是排好序的快速查找数据结构</strong></font> </p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png"></p><ul><li>二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。</li><li>B-TREE：(B:balance) 会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)  </li><li>B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。</li><li>B+TREE：Innodb 所使用的索引</li></ul></li><li><p><font color=#FF0000><strong>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引</strong></font>。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p></li></ul><h4 id="2-3-2-索引的优势"><a href="#2-3-2-索引的优势" class="headerlink" title="2.3.2 索引的优势"></a>2.3.2 索引的优势</h4><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><h4 id="2-3-3-索引的劣势"><a href="#2-3-3-索引的劣势" class="headerlink" title="2.3.3 索引的劣势"></a>2.3.3 索引的劣势</h4><ul><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要<strong>占用空间</strong>的</p></li><li><p>虽然索引大大<strong>提高了查询速度</strong>，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</p></li><li><p><font color=#FF0000><strong>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</strong></font></p></li></ul><h4 id="2-3-4-索引的分类"><a href="#2-3-4-索引的分类" class="headerlink" title="2.3.4 索引的分类"></a>2.3.4 索引的分类</h4><h5 id="2-3-4-1-单值索引"><a href="#2-3-4-1-单值索引" class="headerlink" title="2.3.4.1 单值索引"></a>2.3.4.1 单值索引</h5><blockquote><p>即一个索引只包含单个列，一个表可以有多个单列索引</p></blockquote><h5 id="2-3-4-2-唯一索引"><a href="#2-3-4-2-唯一索引" class="headerlink" title="2.3.4.2 唯一索引"></a>2.3.4.2 唯一索引</h5><blockquote><p>索引列的值必须唯一，但允许有空值</p></blockquote><h5 id="2-3-4-3-复合索引"><a href="#2-3-4-3-复合索引" class="headerlink" title="2.3.4.3 复合索引"></a>2.3.4.3 复合索引</h5><blockquote><p>即一个索引包含多个列</p></blockquote><h5 id="2-3-4-4-主键索引"><a href="#2-3-4-4-主键索引" class="headerlink" title="2.3.4.4 主键索引"></a>2.3.4.4 主键索引</h5><blockquote><p>设定为主键后数据库会自动建立索引，innodb为聚簇（聚集）索引</p><p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><h5 id="2-3-4-5-基本语法"><a href="#2-3-4-5-基本语法" class="headerlink" title="2.3.4.5 基本语法"></a>2.3.4.5 基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 创建<br>CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length))<br>ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) <br><br># 2. 删除<br>DROP INDEX [indexName] ON mytable<br><br># 3. 查看<br>SHOW INDEX FROM table_name\G<br><br># 4. 使用ALTER命令<br># 有四种方式来添加数据表的索引：<br>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) # 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。<br>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list) # 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次<br>ALTER TABLE tbl_name ADD INDEX index_name (column_list) # 添加普通索引，索引值可出现多次。<br>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) #该语句指定了索引为 FULLTEXT ，用于全文索引。 <br></code></pre></td></tr></table></figure><h4 id="2-3-5-mysql索引结构⭐"><a href="#2-3-5-mysql索引结构⭐" class="headerlink" title="2.3.5 mysql索引结构⭐"></a>2.3.5 mysql索引结构⭐</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><ul><li><p>B-Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><ul><li>d为大于1的一个正整数，称为B-Tree的度。</li><li>h为一个正整数，称为B-Tree的高度。</li><li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li><li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li><li>所有叶节点具有相同的深度，等于树高h。</li><li>key和指针互相间隔，节点两端是指针。</li><li>一个节点中的key从左到右非递减排列。</li><li>所有节点组成树结构。</li><li>每个指针要么为null，要么指向另外一个节点。</li><li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li><li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li><li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png"></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">BTree_Search(node, key) &#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    foreach(node.key)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(node.key[i] == key) <span class="hljs-keyword">return</span> node.data[i];<br>            <span class="hljs-keyword">if</span>(node.key[i] &gt; key) <span class="hljs-keyword">return</span> BTree_Search(point[i]-&gt;node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> BTree_Search(point[i+<span class="hljs-number">1</span>]-&gt;node);<br>&#125;<br>data = BTree_Search(root, my_key);<br></code></pre></td></tr></table></figure><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p></li><li><p>B+Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li><p>每个节点的指针上限为2d而不是2d+1。</p></li><li><p>内节点不存储data，只存储key；叶子节点不存储指针。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png"></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p></li><li><p>带有顺序访问指针的B+Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png"></p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p></li><li><p>为什么使用B-Tree（B+Tree）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础</p><p>考虑到<strong>主存存取原理</strong>，<strong>磁盘存取原理</strong>，<strong>局部性原理与磁盘预读</strong>详细见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li><p>一般使用磁盘I/O次数评价索引结构的优劣。</p></li><li><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><blockquote><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p></blockquote></li><li><p><font color=#FF0000><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(logdN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）</strong></font></p></li><li><p>综上所述，用B-Tree作为索引结构效率是非常高的</p></li><li><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多</p></li></ul></li></ul><ul><li><p>B+Tree适合外存索引的原因<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup>：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png"></p></li></ul><ul><li>B+Tree的索引id为什么设置为自增有益于索引维护<ul><li>可以避免<strong>页分裂</strong>和<strong>页合并</strong></li></ul></li></ul><ul><li><p>MyISAM索引实现<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png"></p><blockquote><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png"></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><blockquote><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p></blockquote></li></ul><ul><li><p>InnoDB索引实现<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p></li><li><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png"></p><blockquote><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><ul><li><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如下图为定义在Col3上的一个辅助索引</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png"></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p></li></ul></li></ul><blockquote><p>INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。</p></blockquote><ul><li><p><font color="FF0000">聚簇索引和非聚簇索引的区别</font><sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="《数据库原理》">[10]</span></a></sup></p><p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。详细见这篇<a href="https://blog.csdn.net/alexdamiao/article/details/51934917">博客</a></p><ul><li>InnoDB按聚簇索引的形式存储数据</li><li>MyISAM按照非聚簇索引的形式存储数据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_50_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png"></p></li><li><p><a id="回表">回表</a></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_51_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png"></p><h4 id="2-3-6-哪些情况需要创建索引"><a href="#2-3-6-哪些情况需要创建索引" class="headerlink" title="2.3.6 哪些情况需要创建索引"></a>2.3.6 哪些情况需要创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><h4 id="2-3-7-哪些情况不需要创建索引"><a href="#2-3-7-哪些情况不需要创建索引" class="headerlink" title="2.3.7 哪些情况不需要创建索引"></a>2.3.7 哪些情况不需要创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><p>关于<strong>2.3.7.4</strong>的判断公式：<img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><h3 id="2-4-索引性能分析"><a href="#2-4-索引性能分析" class="headerlink" title="2.4 索引性能分析"></a>2.4 索引性能分析</h3><h4 id="2-4-1-MySQL-Query-Optimizer"><a href="#2-4-1-MySQL-Query-Optimizer" class="headerlink" title="2.4.1 MySQL Query Optimizer"></a>2.4.1 MySQL Query Optimizer</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png"></p><h4 id="2-4-2-MySQL常见瓶颈"><a href="#2-4-2-MySQL常见瓶颈" class="headerlink" title="2.4.2 MySQL常见瓶颈"></a>2.4.2 MySQL常见瓶颈</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png"></p><h4 id="2-4-3-Explain"><a href="#2-4-3-Explain" class="headerlink" title="2.4.3 Explain"></a>2.4.3 <font color=#FF0000><strong>Explain</strong></font></h4><h5 id="2-4-3-1-Explain是什么"><a href="#2-4-3-1-Explain是什么" class="headerlink" title="2.4.3.1 Explain是什么"></a>2.4.3.1 Explain是什么</h5><blockquote><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p></blockquote><p>官网介绍: <a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">http://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p><h5 id="2-4-3-2-Explain能干嘛"><a href="#2-4-3-2-Explain能干嘛" class="headerlink" title="2.4.3.2 Explain能干嘛"></a>2.4.3.2 Explain能干嘛</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png"></p><h5 id="2-4-3-3-Explain怎么用"><a href="#2-4-3-3-Explain怎么用" class="headerlink" title="2.4.3.3 Explain怎么用"></a>2.4.3.3 Explain怎么用</h5><blockquote><p>Explain + SQL语句</p></blockquote><ul><li><p>执行计划包含的信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png"></p></li></ul><h5 id="2-4-3-4-Explain执行计划各字段解释"><a href="#2-4-3-4-Explain执行计划各字段解释" class="headerlink" title="2.4.3.4 Explain执行计划各字段解释"></a>2.4.3.4 Explain执行计划各字段解释</h5><ul><li><p>id ⭐：</p><ul><li><p>含义：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的<strong>顺序</strong></p></li><li><p>三种情况：</p><ul><li><p>id相同：执行顺序由上至下</p></li><li><p>id不同：如果是子查询，id的序号会递增，<font color=#FF0000><strong>id值越大优先级越高</strong></font>，越先被执行</p></li><li><p>id相同/不同，同时存在：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png"></p><p>衍生表 = derived2 –&gt; derived + 2 </p><p>（2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）</p></li></ul></li></ul></li></ul><ul><li><p>select_type：</p><ul><li><p>包含：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png"></p></li><li><p>查询的类型：</p><p>主要是用于区别：普通查询、联合查询、子查询等的复杂查询</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png"></p></li></ul></li></ul><ul><li>table：显示这一行的数据是关于哪张表的</li></ul><ul><li><p>type⭐：</p><ul><li><p>包含：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png"></p></li><li><p> type显示的是访问类型，是较为重要的一个指标</p></li><li><p><font color=#FF0000><strong>结果值从最好到最坏依次是</strong></font>：</p><p>(system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL )</p><p><font color=#FF0000><strong>简化版（记住）</strong></font>：<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong> 一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png"></p></li></ul></li></ul><ul><li>possible_keys：<ul><li>显示可能应用在这张表中的索引，一个或多个。</li><li>查询涉及到的字段上若存在索引，则该索引将被列出，<font color=#FF0000><strong>但不一定被查询实际使用</strong></font></li></ul></li></ul><ul><li>key⭐：<ul><li>实际使用的索引。如果为NULL，则没有使用索引、索引失效</li><li><font color=#0000FF><strong>查询中若使用了覆盖索引，则该索引和查询的select字段重叠</strong></font></li></ul></li></ul><ul><li>key_len：<ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。不损失精度性的情况下，长度越短越好 </li><li>key_len字段能够帮你检查是否充分的利用上了索引</li></ul></li></ul><ul><li>ref：<ul><li>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li></ul></li></ul><ul><li>rows⭐：<ul><li>rows列显示MySQL认为它执行查询时必须检查的行数。</li><li>越少越好</li></ul></li></ul><ul><li>Extra⭐：<ul><li><p>包含不适合在其他列中显示但十分重要的额外信息</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png"></p></li><li><p><font color=#0000FF><strong>覆盖索引</strong></font>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p><p>①一个索引 </p><p>②包含了(或覆盖了)[select子句]与查询条件[Where子句]中 </p><p>③所有需要的字段就叫做<font color=#FF0000><strong>覆盖索引</strong></font>。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png"></p><p><strong>理解</strong>：     </p><blockquote><p>select id , name from t_xxx where age=18;   </p><p>有一个组合索引 idx_id_name_age_xxx 包含了(覆盖了) id,name,age三个字段。查询时直接将建立了索引的列读取出来了，而不需要去查找所在行的其他数据, 所以很高效。</p></blockquote><p>(个人认为：在数据量较大，固定字段查询情况多时可以使用这种方法。)</p></li></ul></li></ul><h3 id="2-5-查询优化"><a href="#2-5-查询优化" class="headerlink" title="2.5 查询优化"></a>2.5 查询优化</h3><h4 id="2-5-1-索引优化"><a href="#2-5-1-索引优化" class="headerlink" title="2.5.1 索引优化"></a>2.5.1 索引优化</h4><h5 id="2-5-1-1-索引分析"><a href="#2-5-1-1-索引分析" class="headerlink" title="2.5.1.1 索引分析"></a>2.5.1.1 索引分析</h5><ul><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=209">单表分析案例</a></p></li><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=210">多表分析案例</a></p></li><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=211">三表分析案例</a></p><ul><li>尽可能减少Join语句的NextedLoop的循环总次数：永远用小结果集驱动大结果集</li><li>优先优化NestedLoop的内层循环</li><li><font color=#FF0000><strong>保证Join语句中被驱动表上Join条件的字段已经被索引</strong></font></li><li>当无法保证被驱动表的Join条件字段被索引且内存充足的前提下，不要太吝啬JoinBuffer的设置</li></ul></li></ul><h5 id="2-5-1-2-索引失效"><a href="#2-5-1-2-索引失效" class="headerlink" title="2.5.1.2 索引失效"></a>2.5.1.2 <font color=#FF0000><strong>索引失效</strong></font></h5><ul><li><font color=#FF0000><strong>联合索引在B+Tree上的存储结构及数据查找方式.</strong></font> ⭐，具体参考<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/feichitianxia/article/details/107997795">[3]</span></a></sup>（基于底层去理解索引失效）<ul><li>这里贴一个简单的联合索引的结构图，具体看上面的帖子</li><li><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png"></li></ul></li><li>索引失效案例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"></p><ul><li><p>小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png"></p></li><li><p>（补充）覆盖索引、最左匹配、索引下推的理解⭐</p><ul><li><p><a href="#回表">回表</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where name&#x3D;zhansan;<br></code></pre></td></tr></table></figure><p>第一次查询name的B+Tree，根据那么获取到主键id，然后再根据id去id的B+Tree找到行记录，这个回表过程会导致IO次数变多。</p></li><li><p>覆盖索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id,name from table where name&#x3D;zhansan;<br></code></pre></td></tr></table></figure><p>在进行检索是，直接更具那么去name的B+Tree获取到id，name两列的值，不需要回表，效率高，应该尽可能多的使用索引覆盖来代替回表，所以有时候，在复杂的sql中，可以考虑将不相关的列都设置为索引列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id,name,age from table where name&#x3D;zhangsan;<br></code></pre></td></tr></table></figure><p>这里name，age作为一个联合索引</p></li><li><p>最左匹配：</p><p>有一个表：id，name，age，gender（id是主键，name，age是联合索引）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where name&#x3D;?           # 符合<br>select * from table where name&#x3D;? and age&#x3D;? # 符合<br>select * from table where age&#x3D;? &#x3D; name&#x3D;?   # 优化器会优化,使其符合最左匹配<br>select * from table where age&#x3D;?            # 不符合<br></code></pre></td></tr></table></figure></li><li><p>索引下推：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where name&#x3D;? and age&#x3D;?<br></code></pre></td></tr></table></figure><ul><li>在没有索引下推之前，先根据name去存储引擎中拉取符合结构的数据，返回到server层，在server层中对age的条件进行过滤</li><li>有了索引下推之后，根据name，age两个条件直接从存储引擎中拉去结果，不需要再server层做条件过滤</li><li>mysql5.7版本之后默认开启</li></ul></li></ul></li></ul><h5 id="2-5-1-3-一般性建议"><a href="#2-5-1-3-一般性建议" class="headerlink" title="2.5.1.3 一般性建议"></a>2.5.1.3 一般性建议</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png"></p><h5 id="2-5-1-4-优化口诀"><a href="#2-5-1-4-优化口诀" class="headerlink" title="2.5.1.4 优化口诀"></a>2.5.1.4 优化口诀</h5><p>建议理解，不用背</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png"></p><h4 id="2-5-2-查询优化"><a href="#2-5-2-查询优化" class="headerlink" title="2.5.2 查询优化"></a>2.5.2 查询优化</h4><blockquote><p>对于数据库分析</p><ol><li>观察，至少跑一天，看看生产的慢SQL情况。</li><li>开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li><li>explain+慢SQL分析</li><li>show profile</li><li>运维经理 or DBA来进行SQL数据库服务器的参数调优</li></ol></blockquote><p><strong>总结</strong>：</p><ul><li>慢查询开启并捕获</li><li>explain+慢SQL分析</li><li>show profile查询SQL再MySQL服务器里面的执行细节和生命周期情况</li><li>SQL数据库服务器参数调优</li></ul><p>关于下面2.5.2.1和2.5.2.3的优化原理见我后面写的<a href="http://lihengxu.cn/2021/04/01/MySQL_Join%E4%BC%98%E5%8C%96/">Join优化</a></p><h5 id="2-5-2-1-小表驱动大表"><a href="#2-5-2-1-小表驱动大表" class="headerlink" title="2.5.2.1 小表驱动大表"></a>2.5.2.1 小表驱动大表</h5><ul><li><p>类似嵌套循环Nested Loop</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png"></p></li><li><p>in/exists</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png"></p></li></ul><h5 id="2-5-2-2-order-by关键字优化"><a href="#2-5-2-2-order-by关键字优化" class="headerlink" title="2.5.2.2 order by关键字优化"></a>2.5.2.2 order by关键字优化</h5><blockquote><p>尽量使用Index方式排序,避免使用FileSort方式排序</p></blockquote><ul><li><p>MySQL支持二种方式的排序，FileSort和Index</p><ul><li>Index效率高.它指MySQL扫描索引本身完成排序。</li></ul></li><li><p>FileSort方式效率较低。</p></li></ul><blockquote><p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p></blockquote><ul><li>ORDER BY满足两情况，会使用Index方式排序<ul><li>ORDER BY 语句使用索引最左前列</li><li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li><li>where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</li></ul></li></ul><ul><li><p>小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png"></p></li></ul><blockquote><p>如果不在索引列上，filesort有两种算法：</p><p>mysql就要启动<strong>双路排序</strong>和<strong>单路排序</strong></p></blockquote><ul><li>双路排序<ul><li>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。（两次）</li><li><strong>缺点</strong>：取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li></ul></li></ul><ul><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</li><li>它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li><li>结论及引申出的问题：<ul><li>结论：由于单路是后出的，总体而言好过双路</li><li>问题：在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li></ul></li></ul></li></ul><ul><li><p>优化策略</p><ul><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>去掉select 后面不需要的字段</p></li><li><p>以上策略对应的原因：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png"></p></li></ul></li></ul><h5 id="2-5-2-3-group-by关键字优化"><a href="#2-5-2-3-group-by关键字优化" class="headerlink" title="2.5.2.3 group by关键字优化"></a>2.5.2.3 group by关键字优化</h5><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ul><h5 id="2-5-2-4-关联查询优化"><a href="#2-5-2-4-关联查询优化" class="headerlink" title="2.5.2.4 关联查询优化"></a>2.5.2.4 关联查询优化</h5><ul><li>保证被驱动表的join字段已经被索引</li><li>left join 时，选择小表作为驱动表，大表作为被驱动表</li><li>inner join 时，mysql会自己帮你把小结果集的表选为驱动表</li><li>子查询尽量不要放在被驱动表，有可能使用不到索引</li></ul><h5 id="2-5-2-5-子查询优化"><a href="#2-5-2-5-子查询优化" class="headerlink" title="2.5.2.5 子查询优化"></a>2.5.2.5 子查询优化</h5><ul><li>有索引的情况下 用 inner join 是最好的 其次是 in ，exists最糟糕 </li><li>无索引的情况下用 小表驱动大表 因为join 方式需要distinct ，没有索引distinct消耗性能较大 所以 exists性能最佳 in其次 join性能最差</li><li>无索引的情况下大表驱动小表in 和 exists 的性能应该是接近的 都比较糟糕 exists稍微好一点 超不过5%   但是inner join 由于使用了 join buffer 所以快很多如果left join 则最慢 </li></ul><h5 id="2-5-2-6-分页查询优化"><a href="#2-5-2-6-分页查询优化" class="headerlink" title="2.5.2.6 分页查询优化"></a>2.5.2.6 分页查询优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 优化前<br>EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY deptno  LIMIT 10000,40<br># 优化后<br>EXPLAIN SELECT SQL_NO_CACHE * FROM emp INNER JOIN (SELECT id FROM emp e ORDER BY deptno LIMIT 10000,40) a ON a.id&#x3D;emp.id<br></code></pre></td></tr></table></figure><ul><li><p>先利用覆盖索引把要取的数据行的主键取到，然后再用这个主键列与数据表做关联（查询的数据量小了）</p></li><li><p>实践证明： </p><p>①、order by 后的字段（XXX）有索引 </p><p>②、sql 中有 limit 时，  当 select id 或 XXX字段索引包含字段时 ，显示 using index  当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort </p></li></ul><h5 id="2-5-2-7-去重优化"><a href="#2-5-2-7-去重优化" class="headerlink" title="2.5.2.7 去重优化"></a>2.5.2.7 去重优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 将产生重复数据<br>select kcdz from t_mall_sku where id in( 3,4,5,6,8 )<br><br># 使用 distinct 关键字去重消耗性能优化<br>select distinct kcdz from t_mall_sku where id in( 3,4,5,6,8 )<br><br># 能够利用到索引<br>select  kcdz from t_mall_sku where id in( 3,4,5,6,8 )  group by kcdz <br></code></pre></td></tr></table></figure><ul><li><p>尽量不要使用 distinct 关键字去重</p></li><li><p>group by能去重且利用索引</p></li></ul><h2 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3. 查询截取分析"></a>3. 查询截取分析</h2><h3 id="3-1-慢查询日志"><a href="#3-1-慢查询日志" class="headerlink" title="3.1 慢查询日志"></a>3.1 慢查询日志</h3><h4 id="3-1-1-慢查询日志介绍"><a href="#3-1-1-慢查询日志介绍" class="headerlink" title="3.1.1 慢查询日志介绍"></a>3.1.1 慢查询日志介绍</h4><ul><li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 </p></li><li><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。 </p></li><li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。 </p></li></ul><h4 id="3-1-2-慢查询日志使用"><a href="#3-1-2-慢查询日志使用" class="headerlink" title="3.1.2 慢查询日志使用"></a>3.1.2 慢查询日志使用</h4><blockquote><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p></blockquote><ul><li><p>查看是否开启及如何开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看<br>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;<br># 设置开启，只对当前数据库生效<br>set global slow_query_log&#x3D;1;<br></code></pre></td></tr></table></figure></li><li><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png"></p></li></ul><ul><li><p>查看当前多少秒算慢, 以及修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看<br>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;<br># 设置<br>set global long_query_time&#x3D;1;<br># 需要重新连接或新开一个会话才能看到修改值<br>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;<br><br># 改变当前session变量<br>set session long_query_time&#x3D;1;<br></code></pre></td></tr></table></figure></li><li><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show global status like &#39;%Slow_queries%&#39;;  <br></code></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-日志分析工具mysqldumpslow"><a href="#3-1-3-日志分析工具mysqldumpslow" class="headerlink" title="3.1.3 日志分析工具mysqldumpslow"></a>3.1.3 日志分析工具mysqldumpslow</h4><ul><li><p>工作常用参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more<br></code></pre></td></tr></table></figure></li><li><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png"></p></li></ul><h3 id="3-2-批量数据脚本"><a href="#3-2-批量数据脚本" class="headerlink" title="3.2 批量数据脚本"></a>3.2 批量数据脚本</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png"></p><ul><li><p>创建函数，假如报错：This function has none of DETERMINISTIC……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 由于开启过慢查询日志，因为我们开启了 bin-log, 我们就必须为我们的function指定一个参数。<br>show variables like &#39;log_bin_trust_function_creators&#39;;<br>set global log_bin_trust_function_creators&#x3D;1;<br><br># 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法：<br># windows下: my.ini[mysqld]加上log_bin_trust_function_creators&#x3D;1<br># linux下: &#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators&#x3D;1<br></code></pre></td></tr></table></figure></li><li><p>创建函数,保证每条数据都不同</p><ul><li><p>随机产生字符串</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)<br>BEGIN    ##方法开始 <br>DECLARE chars_str VARCHAR(100) DEFAULT   &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;;  ##声明一个 字符窜长度为 100 的变量 chars_str ,默认值  <br>DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;; DECLARE i INT DEFAULT 0;  ##循环开始<br>WHILE i &lt; n DO   <br>SET return_str &#x3D;CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));##concat 连接函数  ，substring(a,index,length) 从index处开始截取<br>SET i &#x3D; i + 1;<br>END WHILE;<br>RETURN return_str;<br>END $$ <br># 假如要删除<br># drop function rand_string;<br></code></pre></td></tr></table></figure></li><li><p>随机产生部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE FUNCTION rand_num( ) RETURNS INT(5)<br>BEGIN    <br>DECLARE i INT DEFAULT 0;<br>SET i &#x3D; FLOOR(100+RAND()*10);<br>RETURN i;<br>END $$  <br># 假如要删除<br># drop function rand_num;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建存储过程</p><ul><li><p>插入数据的存储过程(往emp表添加随机数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE insert_emp10000(IN START INT(10),IN max_num INT(10))<br>BEGIN  <br>DECLARE i INT DEFAULT 0;   #set autocommit &#x3D;0 把autocommit设置成0  ；提高执行效率 <br>SET autocommit &#x3D; 0;     <br>REPEAT  ##重复 <br>SET i &#x3D; i + 1;   <br>INSERT INTO emp10000 (empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i) ,rand_string(6),&#39;SALESMAN&#39;,0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());   <br>UNTIL i &#x3D; max_num   ##直到  上面也是一个循环<br>END REPEAT;  ##满足条件后结束循环 <br>COMMIT;   ##执行完成后一起提交 <br>END $$ <br># 删除<br># DELIMITER ;<br># drop PROCEDURE insert_emp; <br></code></pre></td></tr></table></figure></li><li><p>插入数据的存储过程(往dept表添加随机数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程，往dept表添加随机数据<br>DELIMITER $$<br>CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))<br>BEGIN  <br>DECLARE i INT DEFAULT 0;<br>SET autocommit &#x3D; 0;     <br>REPEAT   <br>SET i &#x3D; i + 1;   <br>INSERT INTO dept (deptno ,dname,loc ) VALUES (START +i ,rand_string(10),rand_string(8));   <br>UNTIL i &#x3D; max_num   <br>END REPEAT;   <br>COMMIT;   <br>END $$  <br>#删除<br># DELIMITER ; #将 结束标志换回 ;<br># drop PROCEDURE insert_dept;<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>调用存储过程</p><ul><li><p>dept</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER ; #将 结束标志换回 ;<br>CALL insert_dept(100,10); <br></code></pre></td></tr></table></figure></li><li><p>emp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程，往emp表添加50万条数据<br>DELIMITER ;    #将 结束标志换回 ;<br>CALL insert_emp(100001,500000);  <br>CALL insert_emp10000(100001,10000);    <br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3-Show-Profile"><a href="#3-3-Show-Profile" class="headerlink" title="3.3 Show Profile"></a>3.3 Show Profile</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><blockquote><p>是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></blockquote><h4 id="3-3-2-官网介绍"><a href="#3-3-2-官网介绍" class="headerlink" title="3.3.2 官网介绍"></a>3.3.2 官网介绍</h4><p>官网：<a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p><h4 id="3-3-3-默认设置"><a href="#3-3-3-默认设置" class="headerlink" title="3.3.3 默认设置"></a>3.3.3 默认设置</h4><blockquote><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></blockquote><h4 id="3-3-4-分析步骤"><a href="#3-3-4-分析步骤" class="headerlink" title="3.3.4 分析步骤"></a>3.3.4 分析步骤</h4><ul><li><p>看看当前的mysql版本是否支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Show variables like &#39;profiling&#39;; #  默认是关闭，使用前需要开启    <br>set profiling&#x3D;1;  #  开启<br></code></pre></td></tr></table></figure></li><li><p>运行SQL</p></li><li><p>查看结果，show profiles；</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png"></p></li><li><p>诊断SQL，show profile cpu,block io for query  n  (n为上一步前面的问题SQL数字号码);</p><ul><li><p>查询命令的参数</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png"></p></li><li><p>查询结果</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png"></p></li></ul></li></ul><ul><li><p>日常开发需要注意的结论</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png"></p><ul><li><p>创建临时表的性能耗费示例：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png"></p></li></ul></li></ul><h3 id="3-4-全局查询日志"><a href="#3-4-全局查询日志" class="headerlink" title="3.4 全局查询日志"></a>3.4 全局查询日志</h3><h4 id="3-4-1-配置启用"><a href="#3-4-1-配置启用" class="headerlink" title="3.4.1 配置启用"></a>3.4.1 配置启用</h4><p>在mysql的my.cnf中，设置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启</span><br><span class="hljs-attr">general_log</span>=<span class="hljs-number">1</span>  <br><span class="hljs-comment"># 记录日志文件的路径</span><br><span class="hljs-attr">general_log_file</span>=/path/logfile<br><span class="hljs-comment"># 输出格式</span><br><span class="hljs-attr">log_output</span>=FILE<br></code></pre></td></tr></table></figure><h4 id="3-4-2-编码启用"><a href="#3-4-2-编码启用" class="headerlink" title="3.4.2 编码启用"></a>3.4.2 编码启用</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png"></p><blockquote><p><font color=#FF0000><strong>特别的：尽量不要在生产环境开启这个功能</strong></font></p></blockquote><h2 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4. MySQL锁机制"></a>4. MySQL锁机制</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote><h3 id="4-2-锁的分类"><a href="#4-2-锁的分类" class="headerlink" title="4.2 锁的分类"></a>4.2 锁的分类</h3><h4 id="4-2-1-从对数据操作的类型（读-写）分"><a href="#4-2-1-从对数据操作的类型（读-写）分" class="headerlink" title="4.2.1 从对数据操作的类型（读\写）分"></a>4.2.1 从对数据操作的类型（读\写）分</h4><ul><li>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁(排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul><h4 id="4-2-2-从对数据操作的粒度分"><a href="#4-2-2-从对数据操作的粒度分" class="headerlink" title="4.2.2 从对数据操作的粒度分"></a>4.2.2 从对数据操作的粒度分</h4><ul><li>表锁</li><li>行锁</li></ul><h3 id="4-3-三锁"><a href="#4-3-三锁" class="headerlink" title="4.3 三锁"></a>4.3 三锁</h3><h4 id="4-3-1-表锁（偏读）"><a href="#4-3-1-表锁（偏读）" class="headerlink" title="4.3.1 表锁（偏读）"></a>4.3.1 表锁（偏读）</h4><blockquote><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></blockquote><ul><li><p>手动加读写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock tabel 表名 read(write), 表名2 read(write), ...;<br></code></pre></td></tr></table></figure></li><li><p>查看表上加过的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show open tables;<br></code></pre></td></tr></table></figure></li><li><p>释放表锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure></li><li><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png"></p><p>补充：加读锁的session也不能修改加读锁的表。</p><p><font color=#FF0000><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong></font></p></li><li><p>如何分析表锁定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png"></p></li></ul><h4 id="4-3-2-行锁（偏写）"><a href="#4-3-2-行锁（偏写）" class="headerlink" title="4.3.2 行锁（偏写）"></a>4.3.2 行锁（偏写）</h4><blockquote><p>特点：</p><ol><li>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li></ol></blockquote><ul><li><p>行锁支持事务，<a href="http://lihengxu.cn/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/#5-TCL%E8%AF%AD%E8%A8%80">复习初级部分知识⭐</a></p><ul><li><p>重点:事务特性、并发事务导致的问题、事务隔离级别等</p></li><li><p>补充：并发事务导致的问题（更新丢失）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png"></p></li></ul></li></ul><ul><li><p><font color=#FF0000><strong>无索引(或者索引失效)行锁升级为表锁</strong></font></p></li><li><p>间隙锁的危害</p><ul><li><p><strong>间隙锁</strong>: </p><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。 </p></li><li><p><strong>危害</strong>:</p><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p></li></ul></li><li><p><font color=#FF0000><strong>[面试题] 常考如何锁定一行</strong></font></p><p>事务显示加锁<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_33033819/article/details/106445880">[9]</span></a></sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">##在 MySQL 5.7 中<br>共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE<br>排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE<br><br>##在 MySQL 8.0 中<br>共享锁（S）：SELECT * FROM table_name WHERE ... FOR SHARE<br>排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE[NOWAIT|SKIP LOCKED]<br>--NOWAIT:发现有锁等待后会立即返回错误，不用等待锁超时后报错。<br>--SKIP LOCKED:跳过被锁定的行，直接更新其他行，但是这样要注意是否会造成更新结果不符合预期。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p></li></ul><ul><li><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。 </p></li><li><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p></li><li><p>如何分析行锁定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png"></p></li></ul><ul><li>优化建议：<ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁</li><li>涉及相同表的事务，对于调用表的顺序尽量保持一致</li><li>在业务环境允许的情况下,尽可能低级别事务隔离</li></ul></li></ul><h4 id="4-3-2-页锁（了解）"><a href="#4-3-2-页锁（了解）" class="headerlink" title="4.3.2 页锁（了解）"></a>4.3.2 页锁（了解）</h4><blockquote><p>开销和加锁时间界于表锁和行锁之间；</p><p>会出现死锁；</p><p>锁定粒度界于表锁和行锁之间，并发度一般。</p></blockquote><h2 id="5-主从复制⭐"><a href="#5-主从复制⭐" class="headerlink" title="5. 主从复制⭐"></a>5. 主从复制⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png"></p><h3 id="5-1-复制的基本原理"><a href="#5-1-复制的基本原理" class="headerlink" title="5.1 复制的基本原理"></a>5.1 复制的基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></p><h3 id="5-2-复制的基本原则"><a href="#5-2-复制的基本原则" class="headerlink" title="5.2 复制的基本原则"></a>5.2 复制的基本原则</h3><ul><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个salve</li></ul><h3 id="5-3-复制的最大问题"><a href="#5-3-复制的最大问题" class="headerlink" title="5.3 复制的最大问题"></a>5.3 复制的最大问题</h3><blockquote><p>延时</p></blockquote><h3 id="5-4-一主一从常见配置"><a href="#5-4-一主一从常见配置" class="headerlink" title="5.4 一主一从常见配置"></a>5.4 一主一从常见配置</h3><ul><li><p>mysql版本一致且后台以服务运行</p></li><li><p>主从都配置在[mysqld]结点下，都是小写</p></li><li><p>主机修改my.ini配置文件</p><ul><li>[必须]主服务器唯一ID<ul><li>server-id=1</li></ul></li></ul></li><li><p>[必须]启用二进制日志</p><ul><li><p>log-bin=自己本地的路径/data/mysqlbin</p><ul><li>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin</li></ul></li><li><p>[可选]启用错误日志</p><ul><li>log-err=自己本地的路径/data/mysqlerr</li></ul></li><li><p>log-err=D:/devSoft/MySQLServer5.5/data/mys</p></li><li><p>[可选]根目录</p></li><li><p>basedir=”自己本地路径”</p><ul><li>basedir=”D:/devSoft/MySQLServer5.5/“</li></ul></li></ul></li><li><p>[可选]临时目录</p><ul><li><p>tmpdir=”自己本地路径”</p></li><li><p>tmpdir=”D:/devSoft/MySQLServer5.5/“</p></li><li><p>[可选]数据目录</p><ul><li>datadir=”自己本地路径/Data/“</li><li>datadir=”D:/devSoft/MySQLServer5.5/Data/“</li></ul></li></ul></li><li><p>read-only=0 </p><ul><li><p>主机，读写都可以</p></li><li><p>[可选]设置不要复制的数据库</p></li><li><p>binlog-ignore-db=mysql</p></li><li><p>[可选]设置需要复制的数据库</p><ul><li>binlog-do-db=需要复制的主数据库名字</li></ul></li></ul></li><li><p>从机修改my.cnf配置文件</p><ul><li>[必须]从服务器唯一ID</li><li>[可选]启用二进制日志</li></ul></li><li><p>因修改过配置文件，请主机+从机都重启后台mysql服务</p></li><li><p>主机从机都关闭防火墙</p><ul><li>windows手动关闭</li><li>关闭虚拟机linux防火墙    service iptables stop</li></ul></li><li><p>在Windows主机上建立帐户并授权slave</p><ul><li><p>在主机mysql中执行授权命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.授权<br>GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;123456&#39;;<br># 2.执行结束后刷新<br>flush privileges;<br># 3.查询主机状态<br>show master status;<br># 4.记录下File和Position的值<br># 5.执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在Linux从机上配置需要复制的主机</p><ul><li><p>在从机mysql中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机IP&#39;,<br>MASTER_USER&#x3D;&#39;zhangsan&#39;,<br>MASTER_PASSWORD&#x3D;&#39;123456&#39;,<br>MASTER_LOG_FILE&#x3D;&#39;File名字&#39;,MASTER_LOG_POS&#x3D;Position数字;<br></code></pre></td></tr></table></figure></li><li><p>启动从服务器复制功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start slave;<br></code></pre></td></tr></table></figure></li><li><p>查看从机状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show slave status\G<br></code></pre></td></tr></table></figure><p>下面两个参数都是Yes，则说明主从配置成功!</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: Yes</p></li></ul></li></ul><ul><li><p>主机新建库、新建表、insert记录，从机复制</p></li><li><p>如何停止从服务复制功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">stop slave;<br></code></pre></td></tr></table></figure><p>注意停止后，重新授权需要重新查看主机状态，记录下File和Position的值</p></li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">https://www.bilibili.com/video/BV12b411K7Zu?p=179</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/feichitianxia/article/details/107997795">https://blog.csdn.net/feichitianxia/article/details/107997795</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>MySQL5.1参考手册 - <a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://blog.csdn.net/qq_33033819/article/details/106445880">https://blog.csdn.net/qq_33033819/article/details/106445880</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>《数据库原理》<a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2021/03/12/MySQL_JDBC/"/>
    <url>/2021/03/12/MySQL_JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p><strong>JDO</strong>技术（Java Data Object）</p></li><li><p>第三方O/R工具，如Hibernate, Mybatis 等</p></li></ul><p><strong>JDBC</strong>是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p><h3 id="1-1-JDBC介绍"><a href="#1-1-JDBC介绍" class="headerlink" title="1.1 JDBC介绍"></a>1.1 JDBC介绍</h3><blockquote><p> JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p></blockquote><p><strong>作用</strong>：</p><ul><li><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p></li><li><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p></li></ul><p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png"></p><p>而通过JDBC可以如下访问：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png"></p><blockquote><p>总结：</p><p>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p></blockquote><h3 id="1-2-JDBC-API"><a href="#1-2-JDBC-API" class="headerlink" title="1.2 JDBC API"></a>1.2 JDBC API</h3><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png"></p><h3 id="1-3-JDBC程序编写步骤"><a href="#1-3-JDBC程序编写步骤" class="headerlink" title="1.3  JDBC程序编写步骤"></a>1.3  JDBC程序编写步骤</h3><ul><li>注册驱动</li><li>获取连接</li><li>执行增删改查</li><li>释放资源</li></ul><h2 id="2-快速使用JDBC"><a href="#2-快速使用JDBC" class="headerlink" title="2. 快速使用JDBC"></a>2. 快速使用JDBC</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar <a href="http://dev.mysql.com/downloads/">MySQL的驱动下载地址</a></li><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li>右键–&gt;Add As Library</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC快速入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//1. 导入驱动jar包</span><br>        <span class="hljs-comment">//2.注册驱动</span><br>        <span class="hljs-comment">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>        <span class="hljs-comment">//3.获取数据库连接对象</span><br>        <span class="hljs-comment">// Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br>        Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-comment">//4.定义sql语句</span><br>        <span class="hljs-comment">//String sql = &quot;update account set balance = 2000 where id = 1&quot;;</span><br>        String sql = <span class="hljs-string">&quot;update account set balance = 2000&quot;</span>;<br>        <span class="hljs-comment">//5.获取执行sql的对象 Statement</span><br>        Statement stmt = conn.createStatement();<br>        <span class="hljs-comment">//6.执行sql</span><br>        <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<br>        <span class="hljs-comment">//7.处理结果</span><br>        System.out.println(count);<br>        <span class="hljs-comment">//8.释放资源</span><br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-详解各个对象："><a href="#2-3-详解各个对象：" class="headerlink" title="2.3 详解各个对象："></a>2.3 详解各个对象：</h3><h4 id="2-3-1-DriverManager：驱动管理对象"><a href="#2-3-1-DriverManager：驱动管理对象" class="headerlink" title="2.3.1 DriverManager：驱动管理对象"></a>2.3.1 DriverManager：驱动管理对象</h4><ul><li><p>功能</p><ul><li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar</p><p>static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager</p><p>写代码使用：  Class.forName(“com.mysql.jdbc.Driver”); </p><p>通过反射，加载与注册驱动类，<strong>解耦合（不直接依赖）</strong></p><p>通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>  java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>  &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</p></li><li><p>获取数据库连接：</p><ul><li><p>方法：static Connection getConnection(String url, String user, String password)</p></li><li><p>参数：</p><p><strong>JDBC URL</strong> 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由协议，子协议，子名称三部分组成，各部分间用冒号分隔。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png"></p><p>参数url：指定连接的路径</p><ol><li>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li><li>例子：jdbc:mysql://localhost:3306/db3</li><li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li></ol><p>user：用户名<br>password：密码</p></li></ul></li></ul></li></ul><h4 id="2-3-2-Connection：数据库连接对象"><a href="#2-3-2-Connection：数据库连接对象" class="headerlink" title="2.3.2 Connection：数据库连接对象"></a>2.3.2 Connection：数据库连接对象</h4><ul><li><p>功能</p><ul><li>获取执行sql 的对象</li><li>Statement createStatement()</li><li>PreparedStatement prepareStatement(String sql) </li></ul></li><li><p>管理事务：</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul><h4 id="2-3-3-Statement：执行sql的对象"><a href="#2-3-3-Statement：执行sql的对象" class="headerlink" title="2.3.3 Statement：执行sql的对象"></a>2.3.3 Statement：执行sql的对象</h4><ul><li><p>执行sql</p><ul><li>boolean execute(String sql) ：可以执行任意的sql 了解</li><li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li><li>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</li><li>PreparedStatement prepareStatement(String sql) </li></ul></li><li><p>代码: 对account表完成增删改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Statement stmt = <span class="hljs-keyword">null</span>;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 注册驱动</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>            <span class="hljs-comment">//2. 定义sql(增删改)</span><br>            String sql = <span class="hljs-string">&quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;</span>;<br>            <span class="hljs-comment">//String sql  = &quot;update account set balance = 1500 where id = 3&quot;;</span><br>            <span class="hljs-comment">//String sql  = &quot;delete from account where id = 3&quot;;</span><br>            <span class="hljs-comment">//3.获取Connection对象</span><br>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>            <span class="hljs-comment">//4.获取执行sql的对象 Statement</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">//5.执行sql</span><br>            <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<span class="hljs-comment">//影响的行数</span><br>            <span class="hljs-comment">//6.处理结果</span><br>            System.out.println(count);<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;添加成功！&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;添加失败！&quot;</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//stmt.close();</span><br>            <span class="hljs-comment">//7. 释放资源</span><br>            <span class="hljs-comment">//避免空指针异常</span><br>            <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    stmt.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    conn.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul><h4 id="2-3-4-ResultSet：结果集对象-封装查询结果"><a href="#2-3-4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="2.3.4 ResultSet：结果集对象,封装查询结果"></a>2.3.4 ResultSet：结果集对象,封装查询结果</h4><ul><li><p>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p></li><li><p>getXxx(参数):获取数据</p><ul><li> Xxx：代表数据类型   如： int getInt() ,    String getString()</li><li>参数：<ol><li>int：代表列的编号, 从1开始   如: getString(1)</li><li>String：代表列名称, 如: getDouble(“balance”)</li></ol></li></ul></li><li><p>注意：</p><ul><li><p>使用步骤：</p><ul><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li></ul></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(rs.next())&#123;<br><span class="hljs-comment">//获取数据</span><br><span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-number">1</span>);<br>String name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">double</span> balance = rs.getDouble(<span class="hljs-number">3</span>);<br>System.out.println(id + <span class="hljs-string">&quot;---&quot;</span> + name + <span class="hljs-string">&quot;---&quot;</span> + balance);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-5-PreparedStatement：执行sql的对象"><a href="#2-3-5-PreparedStatement：执行sql的对象" class="headerlink" title="2.3.5 PreparedStatement：执行sql的对象"></a>2.3.5 PreparedStatement：执行sql的对象</h4><ul><li><p>SQL注入问题: 在拼接sql时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题 </p><ul><li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li><li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ </li></ul></li><li><p>解决sql注入问题：使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL：参数使用 ? 作为占位符</p></li><li><p>步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用PreparedStatement实现登录方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username ,String password)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(username == <span class="hljs-keyword">null</span> || password == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//连接数据库判断是否登录成功</span><br>    Connection conn = <span class="hljs-keyword">null</span>;<br>    PreparedStatement pstmt =  <span class="hljs-keyword">null</span>;<br>    ResultSet rs = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//1.获取连接</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        conn =  JDBCUtils.getConnection();<br>        <span class="hljs-comment">//2.定义sql</span><br>        String sql = <span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>;<br>        <span class="hljs-comment">//3.获取执行sql的对象</span><br>        pstmt = conn.prepareStatement(sql);<br>        <span class="hljs-comment">//给?赋值</span><br>        pstmt.setString(<span class="hljs-number">1</span>,username);<br>        pstmt.setString(<span class="hljs-number">2</span>,password);<br>        <span class="hljs-comment">//4.执行查询,不需要传递sql</span><br>        rs = pstmt.executeQuery();<br>        <span class="hljs-comment">//5.判断</span><br>        <span class="hljs-comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;else&#123;</span><br><span class="hljs-comment">                return false;</span><br><span class="hljs-comment">            &#125;*/</span><br>        <span class="hljs-keyword">return</span> rs.next();<span class="hljs-comment">//如果有下一行，则返回true</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        JDBCUtils.close(rs,pstmt,conn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p><ul><li>可以防止SQL注入</li><li>效率更高</li></ul></li></ul><h3 id="2-4-PreparedStatement-Statement-对比"><a href="#2-4-PreparedStatement-Statement-对比" class="headerlink" title="2.4 PreparedStatement/Statement 对比"></a>2.4 PreparedStatement/Statement 对比</h3><blockquote><p><strong>Blob类型的数据</strong> (了解)</p><ol><li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li><li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li></ol><p>注意：如果存储的文件过大，数据库的性能会下降</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png"></p><p><strong>两者区别</strong></p><ul><li><p>代码的可读性和可维护性. Statement的sql拼接是个难题。</p></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li><li><p>PreparedStatement 可以处理Blob类型的数据</p></li><li><p>PreparedStatement 能最大可能提高性能</p><ul><li><p>Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高</p></li><li><p>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行</p></li></ul></li></ul><h2 id="3-JDBCUtils-抽取JDBC工具类"><a href="#3-JDBCUtils-抽取JDBC工具类" class="headerlink" title="3. JDBCUtils: 抽取JDBC工具类"></a>3. JDBCUtils: 抽取JDBC工具类</h2><ul><li><p>目的：简化书写</p></li><li><p>分析：</p><ol><li><p>注册驱动也抽取</p></li><li><p>抽取一个方法获取连接对象</p><ul><li><p>需求：不想传递参数（麻烦），还得保证工具类的通用性。</p></li><li><p>解决：配置文件</p><p> jdbc.properties<br> url=<br> user=<br> password=</p></li></ul></li></ol><ul><li>抽取一个方法释放资源</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取资源文件，获取值。</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 创建Properties集合类。</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br><br>            <span class="hljs-comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br>            ClassLoader classLoader = JDBCUtils.class.getClassLoader();<br>            URL res  = classLoader.getResource(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>            String path = res.getPath();<br>           <span class="hljs-comment">// System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br>            <span class="hljs-comment">//2. 加载文件</span><br>           <span class="hljs-comment">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br>            pro.load(<span class="hljs-keyword">new</span> FileReader(path));<br><br>            <span class="hljs-comment">//3. 获取数据，赋值</span><br>            url = pro.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            user = pro.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            password = pro.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>            driver = pro.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            <span class="hljs-comment">//4. 注册驱动</span><br>            Class.forName(driver);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-JDBC控制事务"><a href="#4-JDBC控制事务" class="headerlink" title="4. JDBC控制事务"></a>4. JDBC控制事务</h2><ol><li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p></li><li><p>操作：</p><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li><p>使用Connection对象来管理事务</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务</li></ul></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事务操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement pstmt1 = <span class="hljs-keyword">null</span>;<br>        PreparedStatement pstmt2 = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.获取连接</span><br>            conn = JDBCUtils.getConnection();<br>            <span class="hljs-comment">//开启事务</span><br>            conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">//2.定义sql</span><br>            <span class="hljs-comment">//2.1 张三 - 500</span><br>            String sql1 = <span class="hljs-string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//2.2 李四 + 500</span><br>            String sql2 = <span class="hljs-string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//3.获取执行sql对象</span><br>            pstmt1 = conn.prepareStatement(sql1);<br>            pstmt2 = conn.prepareStatement(sql2);<br>            <span class="hljs-comment">//4. 设置参数</span><br>            pstmt1.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt1.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><br>            pstmt2.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt2.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//5.执行sql</span><br>            pstmt1.executeUpdate();<br>            <span class="hljs-comment">// 手动制造异常</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br><br>            pstmt2.executeUpdate();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//事务回滚</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>) &#123;<br>                    conn.rollback();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.close(pstmt1,conn);<br>            JDBCUtils.close(pstmt2,<span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-批处理"><a href="#5-批处理" class="headerlink" title="5. 批处理"></a>5. 批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><blockquote><p> 注意:</p><ol><li>不是所用版本的mysql都支持</li><li><strong>JDBC</strong>连接MySQL时，如果要使用批处理功能，请再ur中加参数?rewriteBatchedStatements=true</li><li><strong>PreparedStatement</strong>作批处理插入时使用values（使用value没有效果）</li></ol></blockquote><h3 id="5-1-JDBC的批量处理语句包括下面方法："><a href="#5-1-JDBC的批量处理语句包括下面方法：" class="headerlink" title="5.1 JDBC的批量处理语句包括下面方法："></a>5.1 JDBC的批量处理语句包括下面方法：</h3><ul><li><p><strong>addBatch</strong>()：添加需要批量处理的SQL语句或参数</p></li><li><p><strong>executeBatch</strong>()：执行批量处理语句；</p></li><li><p><strong>clearBatch</strong>():清空批处理包的语句</p></li></ul><h3 id="5-2-批量执行SQL语句的两种情况"><a href="#5-2-批量执行SQL语句的两种情况" class="headerlink" title="5.2 批量执行SQL语句的两种情况"></a>5.2 批量执行SQL语句的两种情况</h3><ul><li><p>多条SQL语句的批量处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>Statement st = conn.createStatement();<br>st.addBatch(sql1);<br>st.addBatch(sql2);<br>...<br>st.addBatch(sqln);<br>st.executeBatch();<br>st.clearBatch();<br>...<br></code></pre></td></tr></table></figure></li><li><p><strong>一个SQL语句的批量传参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>PreparedStatement pst = conn.prepareStatement(sql);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">1001</span>; i++)&#123;<br>pst.setInt(<span class="hljs-number">1</span>, i);<br>...<br>pst.addBatch();<br>&#125;<br>pst.executeBatch();<br>st.clearBatch();<br>...<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-Blob类型数据的读写（了解）"><a href="#6-Blob类型数据的读写（了解）" class="headerlink" title="6. Blob类型数据的读写（了解）"></a>6. Blob类型数据的读写（了解）</h2><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li><li><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p></li><li><p> 需要注意的是：如果存储的文件过大，数据库的性能会下降</p></li></ul><p>写入：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png"></p><p>读取：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png"></p><h2 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7. 数据库连接池"></a>7. 数据库连接池</h2><ol><li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p><p> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p></li><li><p>好处：</p><ul><li><p>节约资源</p></li><li><p>用户访问高效</p></li></ul></li><li><p>实现：</p></li></ol><ul><li><p>标准接口：DataSource   javax.sql包下的</p><p>方法：</p><ul><li>获取连接：getConnection()</li><li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li></ul></li><li><p>一般我们不去实现它，有数据库厂商来实现</p><ul><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li></ul></li></ul><ol start="4"><li>C3P0：数据库连接池技术</li></ol><ul><li>步骤：</li></ul><ol><li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p><ul><li>不要忘记导入数据库驱动jar包</li></ul></li><li><p>定义配置文件：</p><ul><li>名称： c3p0.properties 或者 c3p0-config.xml</li><li>路径：直接将文件放在src目录下即可。</li></ul></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接： getConnection</p></li></ol><ul><li>代码：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * c3p0的演示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3P0Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-comment">//1.创建数据库连接池对象</span><br>        DataSource ds  = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>        <span class="hljs-comment">//2. 获取连接对象</span><br>        Connection conn = ds.getConnection();<br>        <span class="hljs-comment">//3. 打印</span><br>        System.out.println(conn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>Druid：数据库连接池实现技术，由阿里巴巴提供的<ol><li>步骤：<ol><li>导入jar包 druid-1.0.9.jar</li><li>定义配置文件：<ul><li>是properties形式的</li><li>可以叫任意名称，可以放在任意目录下</li></ul></li><li>加载配置文件。Properties</li><li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol></li></ol><ul><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Druid演示</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidDemo</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>          <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.定义配置文件</span><br>        <span class="hljs-comment">//3.加载配置文件</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>);<br>        pro.load(is);<br>        <span class="hljs-comment">//4.获取连接池对象</span><br>        DataSource ds = DruidDataSourceFactory.createDataSource(pro);<br>        <span class="hljs-comment">//5.获取连接</span><br>        Connection conn = ds.getConnection();<br>        System.out.println(conn);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>定义工具类<ol><li>定义一个类 JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法</li></ol></li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Druid连接池的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br><br>    <span class="hljs-comment">//1.定义成员变量 DataSource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载配置文件</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br>            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>));<br>            <span class="hljs-comment">//2.获取DataSource</span><br>            ds = DruidDataSourceFactory.createDataSource(pro);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>       close(<span class="hljs-keyword">null</span>,stmt,conn);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<span class="hljs-comment">//归还连接</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接池方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）"><a href="#8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）" class="headerlink" title="8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）"></a>8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）</h2><ul><li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>步骤：</p><ol><li><p>导入jar包</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li>JdbcTemplate template = new JdbcTemplate(ds);</li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li><p>update():执行DML语句。增、删、改语句</p></li><li><p>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p><p>注意：这个方法查询的结果集长度只能是1</p></li><li><p>queryForList():查询结果将结果集封装为list集合</p><p>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p></li><li><p>query():查询结果，将结果封装为JavaBean对象</p></li><li><p>query的参数：RowMapper</p></li></ul></li><li><p>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p></li><li><p>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p><ul><li><p>queryForObject：查询结果，将结果封装为对象</p><p>一般用于聚合函数的查询</p></li></ul></li></ol></li></ul><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jdbctemplate;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JdbcTemplate入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.创建JDBCTemplate对象</span><br>        JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());<br>        <span class="hljs-comment">//3.调用方法</span><br>        String sql = <span class="hljs-string">&quot;update account set balance = 5000 where id = ?&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">3</span>);<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jdbctemplate;<br><br><span class="hljs-keyword">import</span> cn.itcast.domain.Emp;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><br><span class="hljs-keyword">import</span> java.sql.Date;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo2</span> </span>&#123;<br><br>    <span class="hljs-comment">//Junit单元测试，可以让方法独立执行</span><br>    <span class="hljs-comment">//1. 获取JDBCTemplate对象</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//2. 定义sql</span><br>        String sql = <span class="hljs-string">&quot;update emp set salary = 10000 where id = 1001&quot;</span>;<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-keyword">int</span> count = template.update(sql);<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 添加一条记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>, <span class="hljs-string">&quot;郭靖&quot;</span>, <span class="hljs-number">10</span>);<br>        System.out.println(count);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3.删除刚才添加的记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;delete from emp where id = ?&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>);<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="hljs-comment">     * 注意：这个方法查询的结果集长度只能是1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp where id = ? or id = ?&quot;</span>;<br>        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 5. 查询所有记录，将其封装为List</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);<br><br>        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;<br>            System.out.println(stringObjectMap);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Emp&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Emp <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                Emp emp = <span class="hljs-keyword">new</span> Emp();<br>                <span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                String ename = rs.getString(<span class="hljs-string">&quot;ename&quot;</span>);<br>                <span class="hljs-keyword">int</span> job_id = rs.getInt(<span class="hljs-string">&quot;job_id&quot;</span>);<br>                <span class="hljs-keyword">int</span> mgr = rs.getInt(<span class="hljs-string">&quot;mgr&quot;</span>);<br>                Date joindate = rs.getDate(<span class="hljs-string">&quot;joindate&quot;</span>);<br>                <span class="hljs-keyword">double</span> salary = rs.getDouble(<span class="hljs-string">&quot;salary&quot;</span>);<br>                <span class="hljs-keyword">double</span> bonus = rs.getDouble(<span class="hljs-string">&quot;bonus&quot;</span>);<br>                <span class="hljs-keyword">int</span> dept_id = rs.getInt(<span class="hljs-string">&quot;dept_id&quot;</span>);<br><br>                emp.setId(id);<br>                emp.setEname(ename);<br>                emp.setJob_id(job_id);<br>                emp.setMgr(mgr);<br>                emp.setJoindate(joindate);<br>                emp.setSalary(salary);<br>                emp.setBonus(bonus);<br>                emp.setDept_id(dept_id);<br><br>                <span class="hljs-keyword">return</span> emp;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6_2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));<br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 7. 查询总记录数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select count(id) from emp&quot;</span>;<br>        Long total = template.queryForObject(sql, Long.class);<br>        System.out.println(total);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>表与JavaBean的关系</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png"></p></li></ul><h2 id="9-DAO层"><a href="#9-DAO层" class="headerlink" title="9.  DAO层"></a>9.  DAO层</h2><ul><li><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</p></li><li><p>作用：为了实现功能的模块化，更有利于代码的维护和升级</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>MySQL</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO框架 个人博客域名更换</title>
    <link href="/2021/03/11/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/"/>
    <url>/2021/03/11/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO框架-个人博客域名更换"><a href="#HEXO框架-个人博客域名更换" class="headerlink" title="HEXO框架 个人博客域名更换"></a>HEXO框架 个人博客域名更换</h1><p>基于<a href="http://lihengxu.cn/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">HEXO框架 个人博客搭建</a>，完成博客项目部署后，我们可以绑定自己的域名</p><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h2><p>在<a href="https://wanwang.aliyun.com/">阿里云的万网</a>购买了自己域名：lihengxu.cn</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_1_%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7.png"></p><p>购买后可以在<a href="https://dc.console.aliyun.com/">域名控制台</a>看到自己的域名信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_2_%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E6%8E%A7%E5%88%B6%E5%8F%B0.png"></p><h2 id="2-解析域名"><a href="#2-解析域名" class="headerlink" title="2. 解析域名"></a>2. 解析域名</h2><ul><li><p>解析之前先ping 一下博客仓库对应的GitHub二级域名：</p><p>lihengxu.github.io的IP地址：185.199.110.153</p></li><li><p>然后点击解析</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_3_%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D.png"></p><ul><li>添加两个解析记录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_4_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%951.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_5_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%952.png"></p><ul><li>完成添加后的效果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_6_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%953.png"></p><h2 id="3-设置CNAME"><a href="#3-设置CNAME" class="headerlink" title="3. 设置CNAME"></a>3. 设置CNAME</h2><p>在项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_7_CNAME%E6%96%87%E4%BB%B6.png"></p><p>然后填写上域名。比如：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_8_CNAME%E6%96%87%E4%BB%B6.png"></p><h2 id="4-更新并重新部署"><a href="#4-更新并重新部署" class="headerlink" title="4. 更新并重新部署"></a>4. 更新并重新部署</h2><p>一下指令的具体解释见这篇博客：<a href="http://lihengxu.cn/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">HEXO框架 个人博客搭建</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览<br>hexo d # 部署到github<br></code></pre></td></tr></table></figure><blockquote><p>参考资料：<br>[1]  <a href="https://my.oschina.net/leonadmin/blog/4315110">https://my.oschina.net/leonadmin/blog/4315110</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p><strong>基于<a href="https://www.bilibili.com/video/BV12b411K7Zu">尚硅谷MySQL视频</a>的学习笔记</strong></p><h2 id="1-初识MySQL"><a href="#1-初识MySQL" class="headerlink" title="1. 初识MySQL"></a>1. 初识MySQL</h2><h3 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h3><ul><li>数据库的常见概念 ★<br>1、DB：数据库，存储数据的容器<br>2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br>3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</li><li>数据库存储数据的特点<br>1、数据存放到表中，然后表再放到库中<br>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br>3、表中有一个或多个列，<strong>列</strong>又称为“<strong>字段</strong>”，相当于java中“<strong>属性</strong>”<br>4、表中的<strong>每一行数据</strong>，相当于java中“<strong>对象</strong>”</li></ul><ul><li>常见的数据库管理系统<br>mysql、oracle、db2、sqlserver</li></ul><h3 id="1-2-MySQL介绍"><a href="#1-2-MySQL介绍" class="headerlink" title="1.2 MySQL介绍"></a>1.2 MySQL介绍</h3><ul><li><p>MySQL的背景<br>前身属于瑞典的一家公司，MySQL AB<br>08年被sun公司收购<br>09年sun被oracle收购</p></li><li><p>MySQL的优点</p><ul><li>开源、免费、成本低</li><li>性能高、移植性也好</li><li>体积小，便于安装</li></ul></li><li><p>MySQL服务的启动和停止</p><ul><li>方式一：通过命令行<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> 服务名<br><span class="hljs-built_in">net</span> stop 服务名<br></code></pre></td></tr></table></figure></li><li>方式二：计算机——右击——管理——服务</li></ul></li></ul><ul><li><p>MySQL服务的登录和退出</p><ul><li><p>登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码<br></code></pre></td></tr></table></figure></li><li><p>退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit 或 ctrl+C<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>MySQL的常见命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.查看当前所有的数据库<br>show databases;<br># 2.打开指定的库<br>use 库名<br># 3.查看当前库的所有表<br>show tables;<br># 4.查看其它库的所有表<br>show tables from 库名;<br># 5.创建表<br>create table 表名(<br>列名 列类型,<br>列名 列类型，<br>...<br>);<br># 6.查看表结构<br>desc 表名;<br># 7.查看服务器的版本<br># 方式一：登录到mysql服务端<br>select version();<br># 方式二：没有登录到mysql服务端<br>mysql --version<br># 或<br>mysql --V<br></code></pre></td></tr></table></figure></li><li><p>MySQL的语法规范</p><ol><li><p>不区分大小写,但建议关键字大写，表名、列名小写</p></li><li><p>每条命令最好用分号结尾</p></li><li><p>每条命令根据需要，可以进行缩进 或换行</p></li><li><p>注释</p><ul><li><p>单行注释：#注释文字</p></li><li><p>单行注释：– 注释文字</p></li><li><p>多行注释：/* 注释文字  */</p></li></ul></li></ol></li><li><p>SQL的语言分类</p><ul><li>DQL（Data Query Language）：数据查询语言<pre><code>    select </code></pre></li><li>DML(Data Manipulate Language):数据操作语言<pre><code>    insert 、update、delete</code></pre></li><li>DDL（Data Define Languge）：数据定义语言<pre><code>    create、drop、alter</code></pre></li><li>TCL（Transaction Control Language）：事务控制语言<pre><code>    commit、rollback</code></pre></li></ul></li></ul><h2 id="2-DQL语言"><a href="#2-DQL语言" class="headerlink" title="2. DQL语言"></a>2. DQL语言</h2><h3 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、查询单个字段<br>select 字段名 from 表名;<br><br># 2、查询多个字段<br>select 字段名，字段名 from 表名;<br><br># 3、查询所有字段<br>select * from 表名;<br><br># 4、查询常量<br># 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要<br>select 常量值;<br><br># 5、查询函数<br>select 函数名(实参列表);<br><br># 6、查询表达式<br>select 100&#x2F;1234;<br><br># 7、起别名<br># ① as<br># ② 空格<br><br># 8、去重<br>select distinct 字段名 from 表名;<br><br># 9、+<br># 作用：做加法运算<br>select 数值+数值;  # 直接运算<br>select 字符+数值;  # 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算<br>select null+值;  # 结果都为null<br><br># 10、【补充】concat函数<br># 功能：拼接字符<br>select concat(字符1，字符2，字符3,...);<br><br># 11、【补充】ifnull函数<br># 功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值<br>select ifnull(commission_pct,0) from employees;<br><br># 12、【补充】isnull函数<br># 功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0<br></code></pre></td></tr></table></figure><h3 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.条件查询的基本结构<br>select 查询列表 from 表名 where 筛选条件<br><br># 2.简单条件运算符<br>&gt; &lt; &#x3D; &lt;&gt; !&#x3D; &gt;&#x3D; &lt;&#x3D;  <br>&lt;&#x3D;&gt;安全等于 # 可以判断null值<br><br># 3. 逻辑运算符<br>&amp;&amp; and<br>|| or<br>!  not<br><br># 4、模糊查询<br>between and # 左右边界不能颠倒顺序<br>between 120 and 100 # 等价于 &gt;&#x3D; 120 &amp;&amp; &lt;&#x3D; 100 <br><br>in (&#39;&#39;, &#39;&#39;) # in列表值类型必须统一,且不支持通配符<br>is null &#x2F;is not null  # 用于判断null值, &#x3D; 不能判断null<br>like  # 一般搭配通配符使用，可以判断字符型或数值型 <br><br># 5.通配符：<br>%：任意多个字符<br>_：任意单个字符<br>通配符转义 \ 或者 &#39;_$_&#39; ESCAPE &#39;$&#39;<br><br><br>普通类型的数值  null值   可读性<br>is null×   √      √<br>&lt;&#x3D;&gt;    √   √      ×<br></code></pre></td></tr></table></figure><p><font color=#FF0000><strong>经典面试题</strong></font> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from employees;<br>select * from employees where name like &#39;%%&#39; and id like &#39;%%&#39;;<br>两个查询语句的执行结果是否相同？<br>解：不一样，若name或者id有null值则查不出来<br></code></pre></td></tr></table></figure><h3 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 排序查询的基本结构<br>select 查询列表<br>from 表<br>where 筛选条件<br>order by 排序列表 [asc&#125;desc]<br><br># 2. 特点<br>&#x2F;*<br>1、asc ：升序，如果不写默认升序<br>   desc：降序<br>2、排序列表 支持 单个字段、多个字段、函数、表达式、别名<br>3、order by的位置一般放在查询语句的最后（除limit语句之外）<br>*&#x2F;<br></code></pre></td></tr></table></figure><h3 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h3><ul><li>功能：类似于java中的方法</li><li>好处：提高重用性和隐藏实现细节</li><li>调用：select 函数名(实参列表);</li></ul><p>单行函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、字符函数<br># concat:连接<br># substr:截取子串，索引从1开始<br># upper:变大写<br># lower：变小写<br># replace：替换<br># length：获取字节长度<br># trim:去前后空格<br># lpad：左填充<br># rpad：右填充<br># instr:获取子串第一次出现的索引<br><br>SELECT LENGTH(&#39;john&#39;);<br>SELECT CONCAT(last_name,&#39;_&#39;,first_name) 姓名 FROM employees;<br>SELECT UPPER(&#39;john&#39;);<br>SELECT LOWER(&#39;joHn&#39;);<br>SELECT <br>CONCAT(UPPER(last_name),LOWER(first_name))  姓名 <br>FROM employees;<br>SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,7)  out_put;<br>SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;<br>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2)))  out_put<br>FROM employees;<br>SELECT INSTR(&#39;杨不殷六侠悔爱上了殷六侠&#39;,&#39;殷八侠&#39;) AS out_put;<br>SELECT LENGTH(TRIM(&#39;    张翠山    &#39;)) AS out_put;<br>SELECT TRIM(&#39;aa&#39; FROM &#39;aaaaaa张aaaa翠山aaaaa&#39;) AS out_put;<br>SELECT LPAD(&#39;殷素素&#39;,2,&#39;*&#39;) AS out_put;<br>SELECT RPAD(&#39;殷素素&#39;,12,&#39;ab&#39;) AS out_put;<br>SELECT REPLACE(&#39;周芷若周芷若张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;<br><br># 2、数学函数<br># ceil:向上取整<br># round：四舍五入<br># mod:取模<br># floor：向下取整<br># truncate:截断<br># rand:获取随机数，返回0-1之间的小数<br>SELECT ROUND(-1.55);<br>SELECT ROUND(1.567,2);<br>SELECT CEIL(-1.02);<br>SELECT FLOOR(-9.99);<br>SELECT TRUNCATE(1.69999,1);<br>#mod取余<br>&#x2F;*<br>mod(a,b) ：  a-a&#x2F;b*b<br>mod(-10,-3):-10- (-10)&#x2F;(-3)*（-3）&#x3D;-1<br>*&#x2F;<br>SELECT MOD(10,-3);<br>SELECT 10%3;<br><br># 3、日期函数<br># now：返回当前日期+时间<br># year:返回年<br># month：返回月<br># day:返回日<br># date_format:将日期转换成字符<br># curdate:返回当前日期<br># str_to_date:将字符转换成日期<br># curtime：返回当前时间<br># hour:小时<br># minute:分钟<br># second：秒<br># datediff:返回两个日期相差的天数<br># monthname:以英文形式返回月<br>SELECT NOW();<br>SELECT CURDATE();<br>SELECT CURTIME();<br>SELECT YEAR(NOW()) 年;<br>SELECT YEAR(&#39;1998-1-1&#39;) 年;<br>SELECT  YEAR(hiredate) 年 FROM employees;<br>SELECT MONTH(NOW()) 月;<br>SELECT MONTHNAME(NOW()) 月;<br>SELECT STR_TO_DATE(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) AS out_put;<br>#查询入职日期为1992--4-3的员工信息<br>SELECT * FROM employees WHERE hiredate &#x3D; &#39;1992-4-3&#39;;<br>SELECT * FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);<br>SELECT DATE_FORMAT(NOW(),&#39;%y年%m月%d日&#39;) AS out_put;<br>#查询有奖金的员工名和入职日期(xx月&#x2F;xx日 xx年)<br>SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月&#x2F;%d日 %y年&#39;) 入职日期<br>FROM employees<br>WHERE commission_pct IS NOT NULL;<br><br># 4、其他函数<br># version 当前数据库服务器的版本<br># database 当前打开的数据库<br># user当前用户<br># password(&#39;字符&#39;)：返回该字符的密码形式<br># md5(&#39;字符&#39;):返回该字符的md5加密形式<br>SELECT VERSION();<br>SELECT DATABASE();<br>SELECT USER();<br><br>#5、流程控制函数<br>&#x2F;*<br>①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2<br>②case情况1<br>case 变量或表达式或字段<br>when 常量1 then 值1<br>when 常量2 then 值2<br>...<br>else 值n<br>end<br><br>③case情况2<br>case <br>when 条件1 then 值1<br>when 条件2 then 值2<br>...<br>else 值n<br>end<br>*&#x2F;<br>SELECT IF(10&lt;5,&#39;大&#39;,&#39;小&#39;);<br><br>SELECT salary 原始工资,department_id,<br>CASE department_id<br>WHEN 30 THEN salary*1.1<br>WHEN 40 THEN salary*1.2<br>WHEN 50 THEN salary*1.3<br>ELSE salary<br>END AS 新工资<br>FROM employees;<br><br>SELECT salary,<br>CASE <br>WHEN salary&gt;20000 THEN &#39;A&#39;<br>WHEN salary&gt;15000 THEN &#39;B&#39;<br>WHEN salary&gt;10000 THEN &#39;C&#39;<br>ELSE &#39;D&#39;<br>END AS 工资级别<br>FROM employees;<br></code></pre></td></tr></table></figure><p>分组函数(统计函数\聚合函数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.分类<br>max 最大值<br>min 最小值<br>sum 和<br>avg 平均值<br>count 计算个数<br><br># 2.简单 的使用<br>SELECT SUM(salary) FROM employees;<br>SELECT AVG(salary) FROM employees;<br>SELECT MIN(salary) FROM employees;<br>SELECT MAX(salary) FROM employees;<br>SELECT COUNT(salary) FROM employees;<br><br><br>SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;<br><br>SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;<br><br># 3、参数支持哪些类型<br># sum和avg一般用于处理数值型<br># max、min、count可以处理任何数据类型<br>SELECT SUM(last_name) ,AVG(last_name) FROM employees;<br>SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;<br>SELECT MAX(last_name),MIN(last_name) FROM employees;<br>SELECT MAX(hiredate),MIN(hiredate) FROM employees;<br>SELECT COUNT(commission_pct) FROM employees;<br>SELECT COUNT(last_name) FROM employees;<br><br># 4、是否忽略null(以上分组函数都忽略)<br>SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)&#x2F;35,SUM(commission_pct)&#x2F;107 FROM employees;<br><br>SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;<br><br>SELECT COUNT(commission_pct) FROM employees;<br>SELECT commission_pct FROM employees;<br><br># 5、和distinct搭配<br>SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;<br>SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;<br><br># 6、count函数的详细介绍<br>count(字段)：统计该字段非空值的个数<br>count(*):统计结果集的行数<br>SELECT COUNT(salary) FROM employees;<br>SELECT COUNT(*) FROM employees;<br>SELECT COUNT(1) FROM employees;<br><br>效率：<br>MYISAM存储引擎下，COUNT(*)的效率高<br>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些<br><br>#6、和分组函数一同查询的字段有限制,要求是group by后出现的字段<br>SELECT AVG(salary),employee_id  FROM employees; # 这个查询没有意义<br></code></pre></td></tr></table></figure><h3 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.分组查询的基本结构<br>select 分组函数，分组后的字段<br>from 表<br>[where 筛选条件]<br>group by 分组的字段<br>[having 分组后的筛选]<br>[order by 排序列表]<br><br># 2.筛选对比<br>使用关键字筛选的表位置<br>分组前筛选where原始表 group by的前面<br>分组后筛选having分组后的结果   group by 的后面<br><br># 3. 常见问题<br>1：分组函数做筛选能不能放在where后面<br>答：不能<br><br>2：where——group by——having<br>答：一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率<br><br>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用<br><br># 4. 一些示例<br>#案例1：查询每个工种的员工平均工资<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;<br>#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资<br>SELECT job_id,MAX(salary)<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING MAX(salary)&gt;12000;<br>#案例3：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序<br>SELECT job_id,MAX(salary) m<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING m&gt;6000<br>ORDER BY m ;<br>#案例4：查询每个工种每个部门的最低工资,并按最低工资降序<br>SELECT MIN(salary),job_id,department_id<br>FROM employees<br>GROUP BY department_id,job_id<br>ORDER BY MIN(salary) DESC;<br></code></pre></td></tr></table></figure><h3 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.连接查询的含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询<br>    笛卡尔乘积现象：表1 有m行，表2有n行，结果&#x3D;m*n行<br>    发生原因：没有有效的连接条件<br>    如何避免：添加有效的连接条件<br><br># 2.分类：<br># 按年代分类：<br>sql92标准:仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br><br># 按功能分类：<br>内连接：<br>等值连接<br>非等值连接<br>自连接<br>外连接：<br>左外连接<br>右外连接<br>全外连接<br><br>交叉连接<br><br># 3. SQL92语法<br># 等值连接<br>select 查询列表<br>from 表1 别名,表2 别名<br>where 表1.key&#x3D;表2.key<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br>① 一般为表起别名<br>② 多表的顺序可以调换<br>③ n表连接至少需要n-1个连接条件<br>④ 等值连接的结果是多表的交集部分<br><br><br># 非等值连接<br>select 查询列表<br>from 表1 别名,表2 别名<br>where 非等值的连接条件<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br># 自连接<br>select 查询列表<br>from 表 别名1,表 别名2<br>where 等值的连接条件<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br><br># 4.SQL99语法<br>    # 内连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    【inner】 join 表2 别名 on 连接条件<br>    where 筛选条件<br>    group by 分组列表<br>    having 分组后的筛选<br>    order by 排序列表<br>    limit 子句;<br>    - 特点：<br>    ① 表的顺序可以调换<br>    ② 内连接的结果&#x3D;多表的交集<br>    ③ n表连接至少需要n-1个连接条件<br>    - 分类：<br>    等值连接<br>    非等值连接<br>    自连接<br><br>    # 外连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    left|right|full【outer】 join 表2 别名 on 连接条件<br>    where 筛选条件<br>    group by 分组列表<br>    having 分组后的筛选<br>    order by 排序列表<br>    limit 子句;<br>    - 特点：<br>    ① 查询的结果&#x3D;主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null<br>    ② left join 左边的就是主表<br>      right join 右边的就是主表<br>      full join 两边都是主表<br>    ③ 一般用于查询除了交集部分的剩余的不匹配的行<br><br>    # 交叉连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    cross join 表2 别名;<br>    - 特点：<br>    类似于笛卡尔乘积<br></code></pre></td></tr></table></figure><h3 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 子查询的含义<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询<br><br># 2. 分类：<br>    # 按子查询出现的位置：<br>        select后面：<br>            仅仅支持标量子查询<br><br>        from后面：<br>            支持表子查询<br>        where或having后面：★<br>            标量子查询（单行） √<br>            列子查询  （多行） √<br>            行子查询<br><br>        exists后面（相关子查询）<br>            表子查询<br><br>    # 按结果集的行列数不同：<br>        标量子查询（结果集只有一行一列）<br>        列子查询（结果集只有一列多行）<br>        行子查询（结果集有一行多列）<br>        表子查询（结果集一般为多行多列）<br><br># 3. 示例<br># 3.1 where或having后面<br>特点：<br>① 子查询放在小括号内<br>② 子查询一般放在条件的右侧<br>③ 标量子查询，一般搭配着单行操作符使用<br>&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;<br>列子查询，一般搭配着多行操作符使用<br>in、any&#x2F;some、all<br><br>④ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果<br><br>    # 标量子查询<br>    案例：查询最低工资的员工姓名和工资<br>    ① 最低工资<br>    select min(salary) from employees<br>    ② 查询员工的姓名和工资，要求工资&#x3D;①<br>    select last_name,salary<br>    from employees<br>    where salary&#x3D;(<br>        select min(salary) from employees<br>    );<br><br>    # 列子查询 ★<br>    案例：查询所有是领导的员工姓名<br>    ① 查询所有员工的 manager_id<br>    select manager_id<br>    from employees<br>    ② 查询姓名，employee_id属于①列表的一个<br>    select last_name<br>    from employees<br>    where employee_id in(<br>        select manager_id<br>        from employees<br>    );<br>    <br>    # 行子查询（了解）<br>案例：查询员工编号最小并且工资最高的员工信息<br>    SELECT * <br>    FROM employees<br>    WHERE (employee_id,salary)&#x3D;(<br>        SELECT MIN(employee_id),MAX(salary)<br>        FROM employees<br>    );<br>    ① 查询最小的员工编号<br>    SELECT MIN(employee_id)<br>    FROM employees<br>② 查询最高工资<br>    SELECT MAX(salary)<br>    FROM employees<br>    ③ 查询员工信息<br>    SELECT *<br>    FROM employees<br>    WHERE employee_id&#x3D;(<br>        SELECT MIN(employee_id)<br>        FROM employees<br>    )AND salary&#x3D;(<br>        SELECT MAX(salary)<br>        FROM employees<br>    );<br>    <br># 3.2 select后面<br>仅仅支持标量子查询<br>    #案例：查询每个部门的员工个数<br>    SELECT d.*,(<br>        SELECT COUNT(*)<br>        FROM employees e<br>        WHERE e.department_id &#x3D; d.&#96;department_id&#96;<br>     ) 个数<br>     FROM departments d;<br><br><br># 3.3 from后面<br>将子查询结果充当一张表，要求必须起别名<br>    #案例：查询每个部门的平均工资的工资等级<br>    ① 查询每个部门的平均工资<br>    SELECT AVG(salary),department_id<br>    FROM employees<br>    GROUP BY department_id<br>    SELECT * FROM job_grades;<br><br>    ② 连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal<br>    SELECT  ag_dep.*,g.&#96;grade_level&#96;<br>    FROM (<br>        SELECT AVG(salary) ag,department_id<br>        FROM employees<br>        GROUP BY department_id<br>    ) ag_dep<br>    INNER JOIN job_grades g<br>    ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;<br><br><br># 3.4 exists后面（相关子查询）<br>语法：<br>exists(完整的查询语句)<br>结果：<br>1或0<br><br>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary&#x3D;300000);<br><br>    #案例：查询有员工的部门名<br>    #in<br>    SELECT department_name<br>    FROM departments d<br>    WHERE d.&#96;department_id&#96; IN(<br>        SELECT department_id<br>        FROM employees<br>    )<br>    #exists<br>    SELECT department_name<br>    FROM departments d<br>    WHERE EXISTS(<br>        SELECT *<br>        FROM employees e<br>        WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;<br>    );<br></code></pre></td></tr></table></figure><h3 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 分页查询<br>select 查询列表<br>from 表<br>[join type join 表2<br>on 连接条件<br>where 筛选条件<br>group by 分组字段<br>having 分组后的筛选<br>order by 排序的字段]<br>limit [offset，] size;<br><br># 2. 注意<br>offset代表的是起始的条目索引，默认从0开始<br>size代表的是显示的条目数<br><br># 3. 公式<br>假如要显示的页数为page，每一页条目数为size<br>select 查询列表<br>from 表<br>limit (page-1)*size,size;<br></code></pre></td></tr></table></figure><h3 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 联合查询: 将多条查询语句的结果合并成一个结果<br>查询语句1<br>union<br>查询语句2<br>union<br>...<br><br># 2. 应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时<br><br># 3. 特点：★<br>3.1 要求多条查询语句的查询列数是一致的！<br>3.2 要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.3 union关键字默认去重，如果使用union all 可以包含重复项<br><br># 4.案例：查询部门编号&gt;90或邮箱包含a的员工信息<br>SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;;<br>SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;<br></code></pre></td></tr></table></figure><h3 id="2-10-查询语句总结"><a href="#2-10-查询语句总结" class="headerlink" title="2.10 查询语句总结"></a>2.10 查询语句总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法以及执行顺序<br>select 查询列表    ⑦<br>from 表1 别名       ①<br>连接类型 join 表2   ②<br>on 连接条件         ③<br>where 筛选          ④<br>group by 分组列表   ⑤<br>having 筛选         ⑥<br>order by排序列表    ⑧<br>limit 起始条目索引，条目数;  ⑨<br></code></pre></td></tr></table></figure><h2 id="3-DML语言"><a href="#3-DML语言" class="headerlink" title="3. DML语言"></a>3. DML语言</h2><blockquote><p>数据操作语言：</p><p>插入：insert</p><p>修改：update</p><p>删除：delete</p></blockquote><h3 id="3-1-插入语句"><a href="#3-1-插入语句" class="headerlink" title="3.1 插入语句"></a>3.1 插入语句</h3><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法<br>insert into 表名(列名) values(值1,...);<br><br># 1.插入的值的类型要与列的类型一致或兼容<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br><br># 2.不可以为null的列必须插入值。可以为null的列如何插入值？<br># 2.1：<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br># 2.2：<br>INSERT INTO beauty(id,NAME,sex,phone)<br>VALUES(15,&#39;娜扎&#39;,&#39;女&#39;,&#39;1388888888&#39;);<br><br># 3.列的顺序是否可以调换<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);<br><br># 4.列数和值的个数必须一致<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);<br><br># 5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致<br>INSERT INTO beauty<br>VALUES(18,&#39;张飞&#39;,&#39;男&#39;,NULL,&#39;119&#39;,NULL,NULL);<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br>insert into 表名<br>set 列名&#x3D;值,列名&#x3D;值,...<br><br># 示例<br>INSERT INTO beauty<br>SET id&#x3D;19, NAME&#x3D;&#39;刘涛&#39;, phone&#x3D;&#39;999&#39;;<br></code></pre></td></tr></table></figure><p>对比两种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、方式一支持插入多行,方式二不支持<br>INSERT INTO beauty<br>VALUES(23,&#39;唐艺昕1&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)<br>,(24,&#39;唐艺昕2&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)<br>,(25,&#39;唐艺昕3&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br><br># 2、方式一支持子查询，方式二不支持<br>INSERT INTO beauty(id,NAME,phone)<br>SELECT 26,&#39;宋茜&#39;,&#39;11809866&#39;;<br><br>INSERT INTO beauty(id,NAME,phone)<br>SELECT id,boyname,&#39;1234567&#39;<br>FROM boys WHERE id&lt;3;<br></code></pre></td></tr></table></figure><h3 id="3-2-修改语句"><a href="#3-2-修改语句" class="headerlink" title="3.2 修改语句"></a>3.2 修改语句</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.修改单表的记录★<br>update 表名<br>set 列&#x3D;新值,列&#x3D;新值,...<br>where 筛选条件;<br><br># 2.修改多表的记录【补充】<br># sql92语法：<br>update 表1 别名,表2 别名<br>set 列&#x3D;值,...<br>where 连接条件<br>and 筛选条件;<br># sql99语法：<br>update 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br>set 列&#x3D;值,...<br>where 筛选条件;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.修改单表的记录<br>#案例1：修改beauty表中姓唐的女神的电话为13899888899<br>UPDATE beauty SET phone &#x3D; &#39;13899888899&#39;<br>WHERE NAME LIKE &#39;唐%&#39;;<br>#案例2：修改boys表中id好为2的名称为张飞，魅力值 10<br>UPDATE boys SET boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10<br>WHERE id&#x3D;2;<br><br>#2.修改多表的记录<br>#案例 1：修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;<br>SET b.&#96;phone&#96;&#x3D;&#39;119&#39;,bo.&#96;userCP&#96;&#x3D;1000<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;<br>#案例2：修改没有男朋友的女神的男朋友编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;<br>SET b.&#96;boyfriend_id&#96;&#x3D;2<br>WHERE bo.&#96;id&#96; IS NULL;<br>SELECT * FROM boys;<br></code></pre></td></tr></table></figure><h3 id="3-3-删除语句"><a href="#3-3-删除语句" class="headerlink" title="3.3 删除语句"></a>3.3 删除语句</h3><p> 方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、单表的删除【★】<br>delete from 表名 where 筛选条件<br><br># 2、多表的删除【补充】<br># sql92语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名,表2 别名<br>where 连接条件<br>and 筛选条件;<br># sql99语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.单表的删除<br># 案例：删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;<br><br># 2.多表的删除<br># 案例：删除张无忌的女朋友的信息<br>DELETE b<br>FROM beauty b<br>INNER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;<br># 案例：删除黄晓明的信息以及他女朋友的信息<br>DELETE b,bo<br>FROM beauty b<br>INNER JOIN boys bo ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;黄晓明&#39;;<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br>truncate table 表名;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#案例：将魅力值&gt;100的男神信息删除<br>TRUNCATE TABLE boys ;<br></code></pre></td></tr></table></figure><p><font color=#FF0000><strong>delete 对比 truncate</strong>  [面试题]</font> </p><blockquote><ol><li><p>delete 可以加where 条件，truncate不能加</p></li><li><p>truncate删除，效率高一丢丢</p></li><li><p>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</p></li><li><p>truncate删除没有返回值，delete删除有返回值</p></li><li><p>truncate删除不能回滚，delete删除可以回滚.</p></li></ol></blockquote><h2 id="4-DDL语言"><a href="#4-DDL语言" class="headerlink" title="4. DDL语言"></a>4. DDL语言</h2><p>数据定义语言    –&gt;   库和表的管理</p><blockquote><p>一、库的管理<br>创建、修改、删除</p><p>二、表的管理<br>创建、修改、删除</p></blockquote><p>创建： create<br>修改： alter<br>删除： drop</p><h3 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1、库的创建<br>create database  [if not exists]库名;<br>#案例：创建库Books<br>CREATE DATABASE IF NOT EXISTS books ;<br><br>#2、库的修改<br>RENAME DATABASE books TO 新库名;<br>#更改库的字符集<br>ALTER DATABASE books CHARACTER SET gbk;<br><br>#3、库的删除<br>DROP DATABASE IF EXISTS books;<br></code></pre></td></tr></table></figure><h3 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.表的创建 ★<br># 语法：<br>create table 表名(<br>列名 列的类型【(长度) 约束】,<br>列名 列的类型【(长度) 约束】,<br>列名 列的类型【(长度) 约束】,<br>...<br>列名 列的类型【(长度) 约束】<br>)<br># 案例：创建表Book<br>CREATE TABLE book(<br>id INT,#编号<br>bName VARCHAR(20),#图书名<br>price DOUBLE,#价格<br>authorId  INT,#作者编号<br>publishDate DATETIME#出版日期<br>);<br>DESC book;<br>#案例：创建表author<br>CREATE TABLE IF NOT EXISTS author(<br>id INT,<br>au_name VARCHAR(20),<br>nation VARCHAR(10)<br>)<br>DESC author;<br><br><br># 2.表的修改<br># 语法<br>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;<br># ① 修改列名<br>ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;<br># ② 修改列的类型或约束<br>ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;<br># ③ 添加新列<br>ALTER TABLE author ADD COLUMN annual DOUBLE; <br># ④ 删除列<br>ALTER TABLE book_author DROP COLUMN  annual;<br># ⑤ 修改表名<br>ALTER TABLE author RENAME TO book_author;<br><br><br># 3.表的删除<br>DROP TABLE IF EXISTS book_author;<br>SHOW TABLES;<br># 通用的写法：<br>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;<br>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE  表名();<br><br><br># 4.表的复制<br>INSERT INTO author VALUES<br>(1,&#39;村上春树&#39;,&#39;日本&#39;),<br>(2,&#39;莫言&#39;,&#39;中国&#39;),<br>(3,&#39;冯唐&#39;,&#39;中国&#39;),<br>(4,&#39;金庸&#39;,&#39;中国&#39;);<br><br>SELECT * FROM Author;<br>SELECT * FROM copy2;<br># 1.仅仅复制表的结构<br>CREATE TABLE copy LIKE author;<br># 2.复制表的结构+数据<br>CREATE TABLE copy2 <br>SELECT * FROM author;<br><br># 只复制部分数据<br>CREATE TABLE copy3<br>SELECT id,au_name<br>FROM author <br>WHERE nation&#x3D;&#39;中国&#39;;<br><br># 仅仅复制某些字段<br>CREATE TABLE copy4 <br>SELECT id,au_name<br>FROM author<br>WHERE 0;<br></code></pre></td></tr></table></figure><h3 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h3><blockquote><p>  常见的数据类型</p><ul><li><p>数值型：</p></li><li><p>整型</p></li><li><p>小数：</p><ul><li><p>定点数</p></li><li><p>浮点数</p></li></ul></li><li><p>字符型：</p></li><li><p>较短的文本：char、varchar</p></li><li><p>较长的文本：text、blob（较长的二进制数据）</p></li><li><p>日期型</p></li></ul></blockquote><p><strong>整型</strong></p><ul><li><p>分类：<br>tinyint、smallint、mediumint、int/integer、bigint<br>1              2               3                     4                     8</p></li><li><p>特点：<br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 如何设置无符号和有符号<br>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>t1 INT(7) ZEROFILL,<br>t2 INT(7) ZEROFILL,<br>    t3 INT UNSIGNED<br><br>);<br>DESC tab_int;<br><br><br>INSERT INTO tab_int VALUES(-123456);<br>INSERT INTO tab_int VALUES(-123456,-123456);<br>INSERT INTO tab_int VALUES(2147483648,4294967296);<br>INSERT INTO tab_int VALUES(123,123);<br>SELECT * FROM tab_int;<br></code></pre></td></tr></table></figure><p><strong>小数</strong></p><ul><li><p>分类：</p><ol><li>浮点型<br>float(M,D)<br>double(M,D)</li><li>定点型<br>dec(M，D)<br>decimal(M,D)</li></ol></li><li><p>特点：</p><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p><p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③</p><p>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p></li><li><p>原则：</p><p>所选择的类型越简单越好，能保存数值的类型越小越好</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#测试M和D<br>CREATE TABLE tab_float(<br>f1 FLOAT,<br>f2 DOUBLE,<br>f3 DECIMAL<br>);<br>SELECT * FROM tab_float;<br>DESC tab_float;<br><br>INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);<br>INSERT INTO tab_float VALUES(123.456,123.456,123.456);<br>INSERT INTO tab_float VALUES(123.4,123.4,123.4);<br>INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);<br></code></pre></td></tr></table></figure><p><strong>字符型</strong></p><ul><li><p>较短的文本：</p><p>char  varchar</p></li><li><p>其他：</p><p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p></li><li><p>较长的文本：<br>text<br>blob(较大的二进制)</p></li><li><p>char/varchar 对比</p></li></ul><table><thead><tr><th></th><th>写法</th><th>M的意思</th><th>特点</th><th>空间的耗费</th><th>效率</th></tr></thead><tbody><tr><td>char</td><td>char(M)</td><td>最大的字符数，可以省略，默认为1</td><td>固定长度的字符</td><td>比较耗费</td><td>高</td></tr><tr><td>varchar</td><td>varchar(M)</td><td>最大的字符数，不可以省略</td><td>可变长度的字符</td><td>比较节省</td><td>低</td></tr></tbody></table><ul><li>enum和set不区分大小写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tab_char(<br>c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)<br>);<br>INSERT INTO tab_char VALUES(&#39;a&#39;);<br>INSERT INTO tab_char VALUES(&#39;b&#39;);<br>INSERT INTO tab_char VALUES(&#39;c&#39;);<br>INSERT INTO tab_char VALUES(&#39;m&#39;);<br>INSERT INTO tab_char VALUES(&#39;A&#39;);<br>SELECT * FROM tab_char;<br><br>CREATE TABLE tab_set(<br>s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)<br>);<br>INSERT INTO tab_set VALUES(&#39;a&#39;);<br>INSERT INTO tab_set VALUES(&#39;A,B&#39;);<br>INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);<br></code></pre></td></tr></table></figure></li></ul><p><strong>日期型</strong></p><ul><li>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</li></ul><p>datetime保存日期+时间<br>timestamp保存日期+时间</p><table><thead><tr><th></th><th>写法</th><th>范围</th><th>时区等的影响</th></tr></thead><tbody><tr><td>datetime</td><td>8</td><td>1000-9999</td><td>不受</td></tr><tr><td>timestamp</td><td>4</td><td>1970-2038</td><td>受</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tab_date(<br>t1 DATETIME,<br>t2 TIMESTAMP<br>);<br>INSERT INTO tab_date VALUES(NOW(),NOW());<br>SELECT * FROM tab_date;<br><br># 查看当前时区<br>SHOW VARIABLES LIKE &#39;time_zone&#39;;<br># 更改时区<br>SET time_zone&#x3D;&#39;+9:00&#39;;<br></code></pre></td></tr></table></figure><h3 id="4-4-常见约束"><a href="#4-4-常见约束" class="headerlink" title="4.4 常见约束"></a>4.4 常见约束</h3><ul><li><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p></li><li><p>分类：六大约束</p><ul><li><p>NOT NULL：<strong>非空</strong>，用于保证该字段的值不能为空</p><pre><code>比如姓名、学号等</code></pre></li><li><p>DEFAULT：<strong>默认</strong>，用于保证该字段有默认值</p><pre><code>比如性别</code></pre></li><li><p>PRIMARY KEY：<strong>主键</strong>，用于保证该字段的值具有<strong>唯一性</strong>，并且<strong>非空</strong></p><pre><code>比如学号、员工编号等</code></pre></li><li><p>UNIQUE：<strong>唯一</strong>，用于保证该字段的值具有<strong>唯一性</strong>，可以为空</p><pre><code>比如座位号</code></pre></li><li><p>CHECK：检查约束【mysql中不支持】</p><pre><code>比如年龄、性别</code></pre></li><li><p>FOREIGN KEY：<strong>外键</strong>，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p><p>​    在<strong>从表添加外键约束</strong>，用于<strong>引用主表</strong>中某列的值<br>​    比如学生表的专业编号，员工表的部门编号，员工表的工种编号<br>​    </p></li></ul></li><li><p>添加约束的时机：</p><pre><code>1.创建表时2.修改表时</code></pre></li><li><p>约束的添加分类：</p><ul><li>列级约束：<br>六大约束语法上都支持，但外键约束没有效果        </li><li>表级约束：<br>除了非空、默认，其他的都支持<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型 列级约束,<br>字段名 字段类型,<br>表级约束<br>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>​    </p><ul><li><font color=#FF0000>主键和唯一的对比【面试题】</font> </li></ul><table><thead><tr><th></th><th>保证唯一性</th><th>是否允许为空</th><th>一个表中可以有多少个</th><th>是否允许组合</th></tr></thead><tbody><tr><td>主键</td><td>√</td><td>×</td><td>至多有1个</td><td>√，但不推荐</td></tr><tr><td>唯一</td><td>√</td><td>√</td><td>可以有多个</td><td>√，但不推荐</td></tr></tbody></table><ul><li><p>外键</p><ul><li><p>要求在从表设置外键关系</p></li><li><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p></li><li><p>主表的关联列必须是一个key（一般是主键或唯一）</p></li><li><p>插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 可以通过以下两种方式来删除主表的记录<br># 方式一：级联删除<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;<br># 方式二：级联置空<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>约束的增删改</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建表时添加约束<br># 1.添加列级约束<br>&#x2F;*<br>语法：<br>直接在字段名和类型后面追加 约束类型即可。<br>只支持：默认、非空、主键、唯一<br>*&#x2F;<br>USE students;<br>DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>id INT PRIMARY KEY,#主键<br>stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>gender CHAR(1) CHECK(gender&#x3D;&#39;男&#39; OR gender &#x3D;&#39;女&#39;),#检查<br>seat INT UNIQUE,#唯一<br>age INT DEFAULT  18,#默认约束<br>majorId INT REFERENCES major(id)#外键(这里外键无效)<br><br>);<br><br>CREATE TABLE major(<br>id INT PRIMARY KEY,<br>majorName VARCHAR(20)<br>);<br><br>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;<br><br><br># 2.添加表级约束<br>&#x2F;*<br>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名) <br>*&#x2F;<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT,<br><br>CONSTRAINT pk PRIMARY KEY(id),#主键<br>CONSTRAINT uq UNIQUE(seat),#唯一键<br>CONSTRAINT ck CHECK(gender &#x3D;&#39;男&#39; OR gender  &#x3D; &#39;女&#39;),#检查<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键<br><br>);<br><br>SHOW INDEX FROM stuinfo;<br><br><br># 通用的写法：★<br>CREATE TABLE IF NOT EXISTS stuinfo(<br>id INT PRIMARY KEY,<br>stuname VARCHAR(20),<br>sex CHAR(1),<br>age INT DEFAULT 18,<br>seat INT UNIQUE,<br>majorid INT,<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br><br>);<br><br><br># 二、修改表时添加约束<br>&#x2F;*<br>1. 添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;<br>2. 添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;<br>*&#x2F;<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT<br>)<br>DESC stuinfo;<br><br># 1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;<br># 2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br># 3.添加主键<br># ①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;<br># ②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);<br># 4.添加唯一<br># ①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;<br># ②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);<br># 5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); <br><br><br># 三、修改表时删除约束<br># 1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;<br># 2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;<br># 3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;<br># 4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;<br># 5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br><br>SHOW INDEX FROM stuinfo;<br></code></pre></td></tr></table></figure><ul><li><p>自增长列(标识列）</p><ul><li><p>含义：可以不用手动的插入值，系统提供默认的序列值</p></li><li><p>特点：</p><blockquote><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？<strong>至多一个</strong>！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p></blockquote></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.创建表时设置标识列<br>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>id INT,<br>NAME FLOAT UNIQUE AUTO_INCREMENT,<br>seat INT <br>);<br>TRUNCATE TABLE tab_identity;<br><br>INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#39;john&#39;);<br>INSERT INTO tab_identity(NAME) VALUES(&#39;lucy&#39;);<br>SELECT * FROM tab_identity;<br><br># 查看自增长相关变量<br>SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;<br># 设置自增长步长(一般要进行修改)<br>SET auto_increment_increment&#x3D;3;<br><br># 2.修改表时设置标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;<br><br># 3.修改表时删除标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT;<br></code></pre></td></tr></table></figure><h3 id="4-5-表与表之间的关系"><a href="#4-5-表与表之间的关系" class="headerlink" title="4.5 表与表之间的关系"></a>4.5 表与表之间的关系</h3><ul><li>一对一</li><li>一对多</li><li>多对多</li></ul><h2 id="5-TCL语言"><a href="#5-TCL语言" class="headerlink" title="5. TCL语言"></a>5. TCL语言</h2><p>Transaction Control Language 事务控制语言</p><h3 id="5-1-事务的含义"><a href="#5-1-事务的含义" class="headerlink" title="5.1 事务的含义"></a>5.1 事务的含义</h3><blockquote><p><strong>事务</strong>：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p></blockquote><h3 id="5-2-事务的特点"><a href="#5-2-事务的特点" class="headerlink" title="5.2 事务的特点"></a>5.2 事务的特点</h3><p><font color=#FF0000>事务的特性：ACID  [面试题]</font>  </p><ul><li>原子性：一个事务不可再分割，要么都执行要么都不执行.</li><li>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态.</li><li>隔离性：一个事务的执行不受其他事务的干扰.</li><li>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</li></ul><blockquote><p>存储引擎:</p><ol><li>概念: 在mysql中的数据用各种不同的技术存储在文件(或者内存)中.</li><li>通过<code>show engines;</code>来查看mysql支持的存储引擎.</li><li>在mysql中用的最多的存储引擎有: innodb, myisam, memory等. 其中innodb支持事务,而myisam和memory不支持事务.</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_2.png"></p><h3 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h3><ul><li><p>事务的创建</p><ul><li><p>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p><p>​    delete from 表 where id =1;</p></li><li><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用<code>set autocommit=0;</code></p></li></ul></li></ul><ul><li><p>显式事务的使用</p><p>① 开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p><p>② 编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p><p>设置回滚点：<br>savepoint 回滚点名;</p><p>③ 结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p></li><li><p>delete和truncate在事务使用时的区别：</p><ul><li>delete支持回滚</li><li>truncate不支持</li></ul></li></ul><h3 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h3><ul><li><p>事务的并发问题是如何发生的？</p><p>​    多个事务 同时 操作 同一个数据库的相同数据时</p></li><li><p><font color=#FF0000>并发问题都有哪些？</font> </p><ul><li><strong>脏读</strong>：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li><li><strong>不可重复读</strong>：一个事务多次读取，结果不一样</li><li><strong>幻读</strong>：一个事务读取了其他事务还没有提交的数据，只是读到的是其他事务“插入”的数据</li><li><strong>更新丢失</strong>：当两个或者多个事务选择同一行，然后基于最初的选定的值更新该行时，由于每一个事务都不知道其他事务的存在，就会发生更新问题。最后的更新覆盖了其他事务所做的更新。</li></ul></li><li><p>如何解决并发问题</p><p>​    通过设置隔离级别来解决并发问题</p></li><li><p><font color=#FF0000>事务的隔离级别</font>  </p></li></ul><table><thead><tr><th></th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted: 读未提交</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>×</td><td>×</td><td>×</td></tr><tr><td>read committed: 读已提交</td><td>语句级</td><td>√</td><td>×</td><td>×</td></tr><tr><td>repeatable read: 可重复读</td><td>事务级</td><td>√</td><td>√</td><td>×</td></tr><tr><td>serializable: 串行化 (每次读都需获得表级共享锁，读写相互都会阻塞,性能低下)</td><td>最高级别，事务级</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql中默认 第三个隔离级别 <br>repeatable read<br># oracle中默认第二个隔离级别 <br>read committed<br># 查看隔离级别<br>select @@tx_isolation;<br>show variables like &#39;tx_isolation&#39;;<br># 设置隔离级别<br>set session|global transaction isolation level 隔离级别;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.演示事务的使用步骤<br># 开启事务<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br># 编写一组事务的语句<br>UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;<br>UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;<br># 结束事务<br>ROLLBACK; # commit;<br>SELECT * FROM account;<br><br>#2.演示事务对于delete和truncate的处理的区别<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;<br><br>#3.演示savepoint 的使用<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id&#x3D;25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id&#x3D;28;<br>ROLLBACK TO a;#回滚到保存点<br>SELECT * FROM account;<br></code></pre></td></tr></table></figure><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><blockquote><p><strong>含义</strong>：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据, <strong>只保存了sql逻辑</strong>, 不保存查询结果</p></blockquote><ul><li><p>应用场景:</p><ul><li>多个地方用到相同的查询结果</li><li>该查询结果使用的sql语句比较复杂</li></ul></li><li><p>好处：</p><ul><li>重用sql语句</li><li>简化复杂的sql操作，不必知道它的查询细节</li><li>保护数据，提高安全性（只提供对方需要的信息）</li></ul></li><li><p>创建视图</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 示例：查询姓张的学生名和专业名<br># 1.原始sql语句<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;<br>WHERE s.&#96;stuname&#96; LIKE &#39;张%&#39;;<br># 2.①创建视图<br>CREATE VIEW v1<br>AS<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;;<br># 2.②使用视图简化原始sql语句<br>SELECT * FROM v1 WHERE stuname LIKE &#39;张%&#39;;<br></code></pre></td></tr></table></figure><ul><li>修改视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式一：<br>&#x2F;*<br>create or replace view  视图名<br>as<br>查询语句;<br>*&#x2F;<br>SELECT * FROM myv3 <br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;<br><br>#方式二：<br>&#x2F;*<br>语法：<br>alter view 视图名<br>as <br>查询语句;<br>*&#x2F;<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;<br></code></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：drop view 视图名,视图名,...;<br>DROP VIEW emp_v1,emp_v2,myv3;<br></code></pre></td></tr></table></figure><ul><li>查看视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC myv3;<br>SHOW CREATE VIEW myv3;<br></code></pre></td></tr></table></figure><ul><li>更新视图</li></ul><p>视图可以增删改，示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;<br>SELECT * FROM myv1;<br>SELECT * FROM employees;<br>#1.插入<br>INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;);<br>#2.修改<br>UPDATE myv1 SET last_name &#x3D; &#39;张无忌&#39; WHERE last_name&#x3D;&#39;张飞&#39;;<br>#3.删除<br>DELETE FROM myv1 WHERE last_name &#x3D; &#39;张无忌&#39;;<br></code></pre></td></tr></table></figure><p>具备以下特点的视图不允许更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># ① 包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT MAX(salary) m,department_id<br>FROM employees<br>GROUP BY department_id;<br>SELECT * FROM myv1;<br>#更新<br>UPDATE myv1 SET m&#x3D;9000 WHERE department_id&#x3D;10;<br><br># ② 常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS<br>SELECT &#39;john&#39; NAME;<br>SELECT * FROM myv2;<br>#更新<br>UPDATE myv2 SET NAME&#x3D;&#39;lucy&#39;;<br><br><br># ③ Select中包含子查询<br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;<br>#更新<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资&#x3D;100000;<br><br><br># ④ join<br>CREATE OR REPLACE VIEW myv4<br>AS<br>SELECT last_name,department_name<br>FROM employees e<br>JOIN departments d<br>ON e.department_id  &#x3D; d.department_id;<br>#更新<br>SELECT * FROM myv4;<br>UPDATE myv4 SET last_name  &#x3D; &#39;张飞&#39; WHERE last_name&#x3D;&#39;Whalen&#39;;<br>INSERT INTO myv4 VALUES(&#39;陈真&#39;,&#39;xxxx&#39;);<br><br># ⑤ from一个不能更新的视图<br>CREATE OR REPLACE VIEW myv5<br>AS<br>SELECT * FROM myv3;<br>#更新<br>SELECT * FROM myv5;<br>UPDATE myv5 SET 最高工资&#x3D;10000 WHERE department_id&#x3D;60;<br><br># ⑥ where子句的子查询引用了from子句中的表<br>CREATE OR REPLACE VIEW myv6<br>AS<br>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>SELECT  manager_id<br>FROM employees<br>WHERE manager_id IS NOT NULL<br>);<br>#更新<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary&#x3D;10000 WHERE last_name &#x3D; &#39;k_ing&#39;;<br></code></pre></td></tr></table></figure><ul><li>表和视图的对比<table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>create view</td><td>只是保存了sql逻辑</td><td>增删改查，只是一般不能增删改</td></tr><tr><td>表</td><td>create table</td><td>保存了数据</td><td>增删改查</td></tr></tbody></table></li></ul><h3 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h3><ul><li>系统变量：<ul><li>全局变量：</li></ul>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效<ul><li><p>会话变量：</p><p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p></li></ul></li><li>自定义变量：<ul><li>用户变量</li><li>局部变量</li></ul></li></ul><blockquote><ol><li>系统变量</li></ol></blockquote><p><strong>说明</strong>：变量由系统定义，不是用户定义，属于服务器层面<br><strong>注意</strong>：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br><strong>使用步骤</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、查看所有系统变量<br>show global|【session】variables;<br># 2、查看满足条件的部分系统变量<br>show global|【session】 variables like &#39;%char%&#39;;<br># 3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br># 4、为某个系统变量赋值<br># 方式一：<br>set global|【session】系统变量名&#x3D;值;<br># 方式二：<br>set @@global|【session】系统变量名&#x3D;值;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1》全局变量<br>&#x2F;*<br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>*&#x2F;<br># ① 查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br># ② 查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;<br># ③ 查看指定的系统变量的值<br>SELECT @@global.autocommit;<br># ④ 为某个系统变量赋值<br>SET @@global.autocommit&#x3D;0;<br>SET GLOBAL autocommit&#x3D;0;<br><br>#2》会话变量<br>&#x2F;*<br>作用域：针对于当前会话（连接）有效<br>*&#x2F;<br># ① 查看所有会话变量<br>SHOW SESSION VARIABLES;<br># ② 查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;<br># ③ 查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;<br># ④ 为某个会话变量赋值<br>SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;<br>SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>自定义变量</li></ol></blockquote><p><strong>说明</strong>：变量由用户自定义，而不是系统提供的<br><strong>使用步骤</strong>：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1》用户变量<br>&#x2F;*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*&#x2F;<br># 赋值操作符：&#x3D;或:&#x3D;<br># ① 声明并初始化<br>SET @变量名&#x3D;值;<br>SET @变量名:&#x3D;值;<br>SELECT @变量名:&#x3D;值;<br># ② 赋值（更新变量的值）<br>#方式一：<br>SET @变量名&#x3D;值;<br>SET @变量名:&#x3D;值;<br>SELECT @变量名:&#x3D;值;<br>#方式二：<br>SELECT 字段 INTO @变量名<br>FROM 表;<br># ③ 使用（查看变量的值）<br>SELECT @变量名;<br><br><br># 2》局部变量<br>&#x2F;*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*&#x2F;<br># ① 声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】<br># ② 赋值（更新变量的值）<br>#方式一：<br>SET 局部变量名&#x3D;值;<br>SET 局部变量名:&#x3D;值;<br>SELECT 局部变量名:&#x3D;值;<br>#方式二：<br>SELECT 字段 INTO 具备变量名<br>FROM 表;<br># ③ 使用（查看变量的值）<br>SELECT 局部变量名;<br><br><br># 案例：声明两个变量，求和并打印<br># 用户变量<br>SET @m&#x3D;1;<br>SET @n&#x3D;1;<br>SET @sum&#x3D;@m+@n;<br>SELECT @sum;<br># 局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM&#x3D;m+n;<br>SELECT SUM;<br></code></pre></td></tr></table></figure><p><strong>用户变量和局部变量的对比</strong>：</p><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><h3 id="6-3-存储过程和函数"><a href="#6-3-存储过程和函数" class="headerlink" title="6.3 存储过程和函数"></a>6.3 存储过程和函数</h3><ul><li>存储过程和函数：类似于java中的方法</li><li>好处：<br>1、提高代码的重用性<br>2、简化操作</li></ul><blockquote><ol><li><strong>存储过程</strong></li></ol></blockquote><p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建语法★<br>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN<br>存储过程体（一组合法的SQL语句）<br>END<br>&#x2F;*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)<br><br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值,in可以省略<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值<br><br>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*&#x2F;<br><br><br># 二、调用语法<br>CALL 存储过程名(实参列表);<br><br>#----------------------案例演示-------------------------<br># 1.空参列表<br>#案例：插入到admin表中五条记录<br>SELECT * FROM admin;<br>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>INSERT INTO admin(username,&#96;password&#96;) <br>VALUES(&#39;john1&#39;,&#39;0000&#39;),(&#39;lily&#39;,&#39;0000&#39;),(&#39;rose&#39;,&#39;0000&#39;),(&#39;jack&#39;,&#39;0000&#39;),(&#39;tom&#39;,&#39;0000&#39;);<br>END $<br>#调用<br>CALL myp1()$<br><br># 2.创建带in模式参数的存储过程<br>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息<br>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>SELECT bo.*<br>FROM boys bo<br>RIGHT JOIN beauty b ON bo.id &#x3D; b.boyfriend_id<br>WHERE b.name&#x3D;beautyName;<br>END $<br>#调用<br>CALL myp2(&#39;柳岩&#39;)$<br>#案例2 ：创建存储过程实现，用户是否登录成功<br>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>DECLARE result INT DEFAULT 0;#声明并初始化<br>SELECT COUNT(*) INTO result#赋值<br>FROM admin<br>WHERE admin.username &#x3D; username<br>AND admin.password &#x3D; PASSWORD;<br><br>SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用<br>END $<br>#调用<br>CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$<br><br># 3.创建out 模式参数的存储过程<br>#案例1：根据输入的女神名，返回对应的男神名<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>SELECT bo.boyname INTO boyname<br>FROM boys bo<br>RIGHT JOIN<br>beauty b ON b.boyfriend_id &#x3D; bo.id<br>WHERE b.name&#x3D;beautyName ;<br>END $<br>#调用<br>CALL myp7(&#39;小昭&#39;, @name)$<br>SELECT @name$<br>#案例2：根据输入的女神名，返回对应的男神名和魅力值<br>CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) <br>BEGIN<br>SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>FROM boys <br>RIGHT JOIN<br>beauty b ON b.boyfriend_id &#x3D; boys.id<br>WHERE b.name&#x3D;beautyName ;<br>END $<br>#调用<br>CALL myp7(&#39;小昭&#39;, @name, @cp)$<br>SELECT @name,@cp$<br><br># 4.创建带inout模式参数的存储过程<br>#案例1：传入a和b两个值，最终a和b都翻倍并返回<br>CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)<br>BEGIN<br>SET a&#x3D;a*2;<br>SET b&#x3D;b*2;<br>END $<br>#调用<br>SET @m&#x3D;10$<br>SET @n&#x3D;20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$<br><br><br># 三、删除存储过程<br>#语法：drop procedure 存储过程名<br>DROP PROCEDURE p1;<br>DROP PROCEDURE p2,p3;#×<br><br><br># 四、查看存储过程的信息<br>DESC myp2; # 不可以<br>SHOW CREATE PROCEDURE  myp2;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li><strong>函数</strong></li></ol></blockquote><p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p><strong>区别</strong>：</p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>函数体<br>END<br>&#x2F;*<br>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型<br>2.函数体：<br>肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记<br>*&#x2F;<br><br><br>#二、调用语法<br>SELECT 函数名(参数列表)<br><br>#-----------------案例演示-------------------<br># 1.无参有返回<br>#案例：返回公司的员工个数<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>DECLARE c INT DEFAULT 0;#定义局部变量<br>SELECT COUNT(*) INTO c#赋值<br>FROM employees;<br>RETURN c;<br>END $<br>SELECT myf1()$<br><br># 2.有参有返回<br># 案例1：根据员工名，返回它的工资<br>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>SET @sal&#x3D;0;#定义用户变量 <br>SELECT salary INTO @sal   #赋值<br>FROM employees<br>WHERE last_name &#x3D; empName;<br>RETURN @sal;<br>END $<br>SELECT myf2(&#39;k_ing&#39;) $<br># 案例2：根据部门名，返回该部门的平均工资<br>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>DECLARE sal DOUBLE ;<br>SELECT AVG(salary) INTO sal<br>FROM employees e<br>JOIN departments d ON e.department_id &#x3D; d.department_id<br>WHERE d.department_name&#x3D;deptName;<br>RETURN sal;<br>END $<br>SELECT myf3(&#39;IT&#39;)$<br><br><br>#三、查看函数<br>SHOW CREATE FUNCTION myf3;<br><br><br>#四、删除函数<br>DROP FUNCTION myf3;<br><br># 案例: 创建函数，实现传入两个float，返回二者之和<br>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>DECLARE SUM FLOAT DEFAULT 0;<br>SET SUM&#x3D;num1+num2;<br>RETURN SUM;<br>END $<br>SELECT test_fun1(1,2)$<br></code></pre></td></tr></table></figure><h3 id="6-4-流程控制结构"><a href="#6-4-流程控制结构" class="headerlink" title="6.4  流程控制结构"></a>6.4  流程控制结构</h3><p>顺序、分支、循环</p><blockquote><ol><li>分支结构</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.if函数<br>&#x2F;*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面<br>*&#x2F;<br><br># 2.case结构<br>&#x2F;*<br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>...<br>else 语句n;<br>end <br>情况2：<br>case <br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>...<br>else 语句n;<br>end <br>- 应用在begin end 中或外面<br>如果放在begin end 外面，作为表达式结合着其他语句使用<br>如果放在begin end 里面，一般作为独立的语句使用<br>- else语句可以省略，如果else省略了，全部when都不满足，则返回null<br><br># 3.if结构<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>....<br>else 语句n;<br>end if;<br>功能：类似于多重if<br>只能应用在begin end 中<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>循环结构</li></ol></blockquote><p><strong>分类</strong>：<br>while、loop、repeat</p><p><strong>循环控制</strong>：</p><p>iterate 【标签】 类似于 continue，继续，结束本次循环，继续下一次<br>leave 【标签】 类似于  break，跳出，结束当前所在的循环</p><p><strong>语法</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E5%9F%BA%E7%A1%80_1_%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png"></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.没有添加循环控制语句<br>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>WHILE i&lt;&#x3D;insertCount DO<br>INSERT INTO admin(username,&#96;password&#96;) VALUES(CONCAT(&#39;Rose&#39;,i),&#39;666&#39;);<br>SET i&#x3D;i+1;<br>END WHILE;<br>END $<br>CALL pro_while1(100)$<br><br>#2.添加leave语句<br>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>a:WHILE i&lt;&#x3D;insertCount DO<br>INSERT INTO admin(username,&#96;password&#96;)<br>VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);<br>IF i&gt;&#x3D;20 THEN LEAVE a;<br>END IF;<br>SET i&#x3D;i+1;<br>END WHILE a;<br>END $<br>CALL test_while1(100)$<br><br>#3.添加iterate语句<br>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>a:WHILE i&lt;&#x3D;insertCount DO<br>SET i&#x3D;i+1;<br>IF MOD(i,2)!&#x3D;0 THEN ITERATE a;<br>END IF;<br><br>INSERT INTO admin(username,&#96;password&#96;)<br>VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);<br>END WHILE a;<br>END $<br>CALL test_while1(100)$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo图床</title>
    <link href="/2021/03/07/PicGo/"/>
    <url>/2021/03/07/PicGo/</url>
    
    <content type="html"><![CDATA[<h1 id="PicGo图床"><a href="#PicGo图床" class="headerlink" title="PicGo图床"></a>PicGo图床</h1><h2 id="1-下载PicGo"><a href="#1-下载PicGo" class="headerlink" title="1. 下载PicGo"></a>1. 下载PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h2 id="2-安装PicGo"><a href="#2-安装PicGo" class="headerlink" title="2. 安装PicGo"></a>2. 安装PicGo</h2><p>直接运行.exe</p><h2 id="3-新建一个github仓库"><a href="#3-新建一个github仓库" class="headerlink" title="3. 新建一个github仓库"></a>3. 新建一个github仓库</h2><p>mycdn</p><h2 id="4-生成token"><a href="#4-生成token" class="headerlink" title="4.生成token"></a>4.生成token</h2><p>[进入github] -&gt; [点击头像] -&gt; [settings] -&gt; [Developers settings] -&gt; [Personal access token]</p><blockquote><p> 必须勾选repo</p></blockquote><p>生成后必须复制token，只显示一次</p><blockquote><p>0cb447c7cb66f97f8dd645d1b30f88b3bda94198</p></blockquote><h2 id="5-配置PicGo"><a href="#5-配置PicGo" class="headerlink" title="5. 配置PicGo"></a>5. 配置PicGo</h2><p>打开PicGo左栏依次选择[图床设置] -&gt; [github图床]</p><p>格式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">仓库名： 你的用户名/仓库名<br>分支： main<br>Token： <span class="hljs-number">0</span>cb447c7cb66f97f8dd645d1b30f88b3bda94198<br>存储路径： img/  <span class="hljs-comment"># 表示上传到你的仓库的img目录下</span><br>自定义域名格式： https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>LihengXu/mycdn<br></code></pre></td></tr></table></figure><p>因为github的服务器在国外，所以用来当图床的时候，国内的速度非常感人，但是我们可以使用<code>jsdelivr</code>提供的CDN服务，速度非常的快，基本不大的图片可以秒开。</p><p>所以上述<strong>自定义域名</strong>实际上是使用的<code>jsdelivr</code>的CDN服务。</p><h2 id="6-上传图片"><a href="#6-上传图片" class="headerlink" title="6. 上传图片"></a>6. 上传图片</h2><p>点击上传区，选择github图床</p><p>示例</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/myfig.png"></p>]]></content>
    
    
    <categories>
      
      <category>PicGo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO框架 个人博客搭建</title>
    <link href="/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO框架-个人博客搭建"><a href="#HEXO框架-个人博客搭建" class="headerlink" title="HEXO框架 个人博客搭建"></a>HEXO框架 个人博客搭建</h1><h2 id="一、-环境搭建"><a href="#一、-环境搭建" class="headerlink" title="一、 环境搭建"></a>一、 环境搭建</h2><h3 id="1-nodejs安装"><a href="#1-nodejs安装" class="headerlink" title="1. nodejs安装"></a>1. nodejs安装</h3><h4 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h4><p>下载地址（选择<strong>LTS</strong>稳定版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><blockquote><p>下载之后直接默认安装，一路next（建议不要放在C盘）</p></blockquote><h4 id="1-2-测试nodejs"><a href="#1-2-测试nodejs" class="headerlink" title="1.2 测试nodejs"></a>1.2 测试nodejs</h4><p>打开windows的命令行工具输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure><p>显示版本号则安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_1_%E6%B5%8B%E8%AF%95nodejs%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h4 id="1-3-测试npm"><a href="#1-3-测试npm" class="headerlink" title="1.3 测试npm"></a>1.3 测试npm</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> npm是nodejs安装时默认安装的</span><br><span class="hljs-meta">#</span><span class="bash"> 直接在windows的命令行工具输入</span><br>npm -v<br></code></pre></td></tr></table></figure><p>显示如下则安装成功, npm管理工具用于安装Hexo框架</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_2_%E6%B5%8B%E8%AF%95npm%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h4 id="1-4-安装nrm（需要一点耐心）"><a href="#1-4-安装nrm（需要一点耐心）" class="headerlink" title="1.4 安装nrm（需要一点耐心）"></a>1.4 安装nrm（需要一点耐心）</h4><blockquote><p> nrm的安装原因：需要切换下载源到国内镜像源，提升下载速度</p></blockquote><ul><li>默认npm的全局安装路径在C盘，我们需要修改到nodejs的安装目录，新建两个文件夹: <code>node_global_modules</code> 和 <code>node_cache</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_3_%E4%BF%AE%E6%94%B9npm%E9%BB%98%E8%AE%A4%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84.png"></p><ul><li><p>在命令行执行以下两条命令修改npm配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set prefix &quot;D:\Java\nodejs\node_modules\npm\node_global_modules&quot;<br>npm config set cache &quot;D:\Java\nodejs\node_modules\npm\node_cache&quot;<br></code></pre></td></tr></table></figure></li><li><p>执行后输入以下命令，查看npm配置结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config ls<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_4_npm%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png"></p><ul><li>验证配置成功后，需要配置环境变量。在环境变量中，新建一个系统变量，变量名：<code>NODE_HOME</code>，变量值：<code>D:\dev\nodejs</code>，效果如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_5_%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE_HOME.png"></p><ul><li><p>在系统环境变量<code>Path</code>变量名中，新建变量值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">NODE_HOME%</span><br><span class="hljs-meta">%</span><span class="bash">NODE_HOME%\node_modules</span><br><span class="hljs-meta">%</span><span class="bash">NODE_HOME%\node_modules\npm\node_global_modules\</span><br></code></pre></td></tr></table></figure></li></ul><p>效果如图（下图第二个路径写错了）：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_6_%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%88%B0path.png"></p><ul><li><p>保存后重新打开命令行工具，执行性全局安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install nrm -g<br></code></pre></td></tr></table></figure><p>安装结束后如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_7_nrm%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C.png"></p></li><li><p>在命令行输入指令查看下载源，可能会报错如下图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nrm ls<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_8_nrm%E6%8A%A5%E9%94%99.png"></p></li><li><p>找到nrm目录(错误第四行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">at Object.&lt;anonymous&gt; (D:\Java\nodejs\node_modules\npm\node_global_modules\node_modules\nrm\cli.js:17:20)<br></code></pre></td></tr></table></figure></li><li><p>打开cli.js 第17行修改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//const NRMRC = path.join(process.env.HOME, &#x27;.nrmrc&#x27;); (删除)</span><br><span class="hljs-keyword">const</span> NRMRC = path.join(process.env[(process.platform == <span class="hljs-string">&#x27;win32&#x27;</span>) ? <span class="hljs-string">&#x27;USERPROFILE&#x27;</span> : <span class="hljs-string">&#x27;HOME&#x27;</span>], <span class="hljs-string">&#x27;.nrmrc&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>重新输入<code>nrm ls</code>查看下载源</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_9_%E6%9F%A5%E7%9C%8Bnrm%E4%B8%8B%E8%BD%BD%E6%BA%90.png"></p></li><li><p>修改下载源指令，推荐选择taobao</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nrm use taobao # 选择淘宝<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-安装Hexo框架"><a href="#2-安装Hexo框架" class="headerlink" title="2. 安装Hexo框架"></a>2. 安装Hexo框架</h3><h4 id="2-1-安装hexo-cli脚手架"><a href="#2-1-安装hexo-cli脚手架" class="headerlink" title="2.1 安装hexo-cli脚手架"></a>2.1 安装hexo-cli脚手架</h4><p>打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装成功如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_10_hexo-cli%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png"></p><h4 id="2-2-验证hexo-cli安装成功"><a href="#2-2-验证hexo-cli安装成功" class="headerlink" title="2.2 验证hexo-cli安装成功"></a>2.2 验证hexo-cli安装成功</h4><p>命令行输入测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_11_hexo-cli%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85.png"></p><h3 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3. 安装Git"></a>3. 安装Git</h3><p>具体可以参考我的<a href="https://lihengxu.github.io/2020/08/21/gitstudy/">Git总结</a></p><h2 id="二、使用Hexo搭建博客"><a href="#二、使用Hexo搭建博客" class="headerlink" title="二、使用Hexo搭建博客"></a>二、使用Hexo搭建博客</h2><h3 id="1-创建项目文件夹"><a href="#1-创建项目文件夹" class="headerlink" title="1. 创建项目文件夹"></a>1. 创建项目文件夹</h3><p>在本地硬盘创建并进入项目文件夹（blog），并在该文件夹下打开命令行工具</p><h3 id="2-初始化blog项目"><a href="#2-初始化blog项目" class="headerlink" title="2. 初始化blog项目"></a>2. 初始化blog项目</h3><p>使用hexo命令初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>初始化项目文件如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_12_blog%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6.png"></p><h3 id="3-运行hexo服务预览博客"><a href="#3-运行hexo服务预览博客" class="headerlink" title="3. 运行hexo服务预览博客"></a>3. 运行hexo服务预览博客</h3><p>在当前路径下输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>命令行出现访问路径，直接点击访问即可</p><p>默认样式如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_13_hexo%E5%8D%9A%E5%AE%A2%E9%A2%84%E8%A7%88.png"></p><h3 id="4-创建文章"><a href="#4-创建文章" class="headerlink" title="4. 创建文章"></a>4. 创建文章</h3><p>在当前路径下输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo n &#x27;hexo test&#x27;<br></code></pre></td></tr></table></figure><p>回车后出现以标题命名的.md文件路径，打开该文件编辑文章内容</p><h3 id="5-更新文章"><a href="#5-更新文章" class="headerlink" title="5. 更新文章"></a>5. 更新文章</h3><p>命令行输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览博客<br></code></pre></td></tr></table></figure><h2 id="三、-博客部署到GitHub"><a href="#三、-博客部署到GitHub" class="headerlink" title="三、 博客部署到GitHub"></a>三、 博客部署到GitHub</h2><h3 id="1-登陆GitHub创建仓库"><a href="#1-登陆GitHub创建仓库" class="headerlink" title="1. 登陆GitHub创建仓库"></a>1. 登陆GitHub创建仓库</h3><p>创建仓库命：LihengXu.github.io (注意第一个.前面一定是账户名)</p><h3 id="2-在本地目录安装git部署插件"><a href="#2-在本地目录安装git部署插件" class="headerlink" title="2. 在本地目录安装git部署插件"></a>2. 在本地目录安装git部署插件</h3><p>在项目根目录下打开命令行工具输入如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-deployer-git # --save 表示只在本目录下安装<br></code></pre></td></tr></table></figure><h3 id="3-修改项目根目录下的配置文件"><a href="#3-修改项目根目录下的配置文件" class="headerlink" title="3. 修改项目根目录下的配置文件"></a>3. 修改项目根目录下的配置文件</h3><p>找到<code>_config.yaml</code>文件</p><p>找到最下面的<code>deploy：type</code> 进行编辑:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/LihengXu/LihengXu.github.io.git</span> <br>  <span class="hljs-comment"># repo : github上创建的仓库地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><blockquote><p>上面的repo：建议使用ssh并绑定公钥， 详细见如何<a href="https://lihengxu.github.io/2020/08/21/Git/#%E4%BD%BF%E7%94%A8%E7%A0%81%E4%BA%91gitee">GIt：使用码云gitee</a>（gitee和github操作没有区别）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:LihengXu/LihengXu.github.io.git</span><br></code></pre></td></tr></table></figure><h3 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h3><p>项目根目录下打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>提示你输入GitHub账户和密码后将代码提交到GitHub仓库</p><p>通过<a href="https://lihengxu.github.io/">GitHub链接</a>可访问博客</p><h2 id="四、-更换主题"><a href="#四、-更换主题" class="headerlink" title="四、 更换主题"></a>四、 更换主题</h2><h3 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h3><p>将主题文件下载到本地项目的<code>theme</code>文件夹</p><p>在本地项目根目录下打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><h3 id="2-修改配置-config-yml"><a href="#2-修改配置-config-yml" class="headerlink" title="2. 修改配置 _config.yml"></a>2. 修改配置 _config.yml</h3><p>找到<code>#Extensions</code>项的theme</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><p><a href="https://hexo.fluid-dev.com/docs/start/">fluid主题使用指南</a>，可以进一步自定义更多设置</p><h3 id="3-更新并重新部署"><a href="#3-更新并重新部署" class="headerlink" title="3. 更新并重新部署"></a>3. 更新并重新部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览<br>hexo d # 部署到github<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用</title>
    <link href="/2020/08/21/Git/"/>
    <url>/2020/08/21/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git初步使用"><a href="#Git初步使用" class="headerlink" title="Git初步使用"></a>Git初步使用</h1><p><strong>前言</strong>：用了比较长时间的github了，一直都不能把git理清楚，于是决定整理一下git的学习笔记，供自己梳理和回顾。</p><p><strong>说明</strong>：这里思路是B站up狂神的git教学<a href="https://www.bilibili.com/video/BV1FE411P7B3?p=1">狂神聊Git</a>，给大家安利一下这个up，他许多视频都很不错。</p><hr><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote><p><strong>版本控制</strong>  版本迭代的版本管理器(Revision control)</p></blockquote><p>尤其在多人开发中，使用版本控制尤为重要</p><blockquote><p><strong>常见的版本控制工具</strong></p></blockquote><p>主流的版本控制器有：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong> (subversion)</li><li><strong>CVS</strong> (Concurrent Version System)</li><li><strong>VSS</strong> (Micorosoft Visual SourceSafe)</li><li><strong>TFS</strong> (Team Foudation Server)</li><li>Visual Studio Online</li></ul><p>现在影响力最大也是使用最广泛的是<strong>Git</strong>和<strong>SVN</strong></p><blockquote><p><strong>版本控制分类</strong></p></blockquote><ol><li><p><strong>本地版本控制</strong></p><p>记录文件每次更新，可以对每个版本做一个快照，或者是记录补丁文件，适用于个人，如RCS。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_1_%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p></li><li><p><strong>集中版本控制</strong></p><p>所有版本数据都保存在服务器上，协同开发者从服务器上同步更新或者上传自己的修改。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_2_%E9%9B%86%E4%B8%AD%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p><p>所有的版本数据保存在服务器上，用户本地只有自己的以前所同步的版本，如果不联网，用户看不到历史版本，也午饭切换版本验证问题，或者不同分支工作。而且，所有有数据都保存在单一服务器上，一旦服务器损坏就会丢失所有数据，需要定期备份。代表有：<strong>SVN CVS VSS</strong></p></li><li><p><strong>分布式版本控制</strong></p><p>所有版本星信息全部同步到本地的每一个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需要在连网时push到相应的服务器或者其他用户那里。由于每一个用户保存的都是所有的版本数据，只要有一个用户设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_3_%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p></li></ol><blockquote><p><strong>Git和SVN的区别</strong></p></blockquote><p><strong>SVN</strong>是集中式版本控制系统，版本库集中放在中央服务器的，而工作的时候，用自己电脑首先要从重要服务器得到最新版本，然后工作，完成工作后需要推送到中央服务器。集中实版本控制系统必须联网才能工作，对网络带宽要求较高</p><p><strong>Git</strong>是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同方式：你在电脑上修改了文件A，其他人也修改了文件A，你们俩只需要把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到。</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p><strong>GIt</strong>是Linux社区 (特别是Linux的缔造者<strong>Linus Torvalds</strong>) 基于使用<strong>BitKeeper</strong>时的经验教训，开发出的自己的版本系统。大约花了<strong>两周左右</strong>，也就是后来的<strong>Git</strong>。</p><p><strong>Git</strong>是免费的、开源的、最初Git是为辅助Linux内核开发的，来代替BitKeeper。</p><h2 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h2><blockquote><p><strong>Git下载</strong></p></blockquote><p>打开官网<a href="https://git-scm.com/">git官网</a>，下载git对应操作系统的版本</p><p>下载过慢就是用镜像下载<a href="http://npm.taobao.org/mirrors/git-for-windows/">淘宝镜像</a></p><blockquote><p><strong>Git卸载</strong></p></blockquote><p>直接反安装即可、清理环境变量</p><blockquote><p><strong>Git安装</strong></p></blockquote><p>无脑下一步安装即可。</p><blockquote><p><strong>启动Git</strong></p></blockquote><p>安装成功后开始菜单会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_4_git%E9%80%89%E9%A1%B9.png"></p><p><strong>Git Bash</strong>:  Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD</strong>:  Windows风格的命令行</p><p><strong>GIt GUI</strong>:  图形界面的GIt，不建议初学者使用，尽量先熟悉常用的命令</p><blockquote><p><strong>基本的Linux命令</strong></p></blockquote><ol><li><p><strong>cd</strong> 改变目录</p></li><li><p><strong>cd ..</strong> 回退到上一个目录，直接cd进入默认目录</p></li><li><p><strong>pwd</strong> 显示当前目录路径</p></li><li><p><strong>ls(ll)</strong> 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更加详细</p></li><li><p><strong>touch</strong> 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p></li><li><p><strong>rm</strong> 删除一个文件，rm index.js 就会把index.js删除掉</p></li><li><p><strong>mkdir</strong> 新建一个目录，就是新建一个文件夹</p></li><li><p><strong>rm -r</strong> 删除一个文件夹，rm -r src 删除src目录</p><p>切勿随意在Linux系统中使用<strong>rm -rf /</strong> ，会从根目录全部递归删除，那么会删除电脑中全部文件。</p></li><li><p><strong>mv</strong> 移动文件，mv index.html src index.html 是我们要移动的文件，src是目标文件夹，这么写必须在同一目录下。</p></li><li><p><strong>reset</strong> 重新初始化终端/清屏</p></li><li><p><strong>clear</strong> 清屏</p></li><li><p><strong>history</strong> 查看命令历史</p></li><li><p><strong>help</strong> 帮助</p></li><li><p><strong>exit</strong> 退出</p></li><li><p>**#**表示注释</p></li></ol><blockquote><p><strong>Git配置</strong></p></blockquote><p>查看配置 <strong>git config -l</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_5_git%E9%85%8D%E7%BD%AE.png"></p><p>查看不同级别的配置文件 (都保存在本地) ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统config</span><br>git config --system --list<br><br><span class="hljs-comment"># 查看当前用户(global)配置</span><br>git config --global --list<br></code></pre></td></tr></table></figure><p><strong>Git相关的配置文件：</strong></p><ol><li>Git\etc\gitconfig : Git 安装目录下的gitconfig –system 系统级</li><li>C:\UsersAdminstrator\ .gitconfig 只适用于当前登录用户配置 –global 全局</li></ol><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里</p><blockquote><p><strong>配置用户名与邮箱 (用户标识，必要)</strong></p></blockquote><p>当你安装git后首先要设置你的用户名和e-mail地址。这非常重要，每次git提交都会使用该信息。它会被永远嵌入到你的提交中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;lihengxu&quot;</span> <span class="hljs-comment"># 名称</span><br>git config --global user.email 15882320389@163.com <span class="hljs-comment"># 邮箱</span><br></code></pre></td></tr></table></figure><p>只需要设置一次，只要传递了–global选项，Git将总会使用该信息来处理你在系统中的一切处理。如果你希望在一个特定的项目中使用不同的名称或email地址，你可以在该项目运行该命令而不要–global选项。总之–global为全局配置，不加为某一个项目的特定配置。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_6_git%E9%85%8D%E7%BD%AE--global.png"></p><h2 id="Git基本理论-核心"><a href="#Git基本理论-核心" class="headerlink" title="Git基本理论 (核心)"></a>Git基本理论 (核心)</h2><blockquote><p><strong>工作区域</strong></p></blockquote><p>Git本地有三个工作区域：</p><ol><li>工作目录(Working Direcitory)</li><li>暂存区(Stage/Index)</li><li>资源区(Repository 或 GIt Directory)</li></ol><p>如果加上远程的</p><ol start="4"><li>Git仓库(Remote Directory)</li></ol><p>就可以分为4个工作区域，转换关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_7_git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F.png"></p><ul><li><strong>Workspace</strong>: 工作区，就是平时你存放项目代码的地方</li><li><strong>Index/Stage</strong>： 暂存区，用于平时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li><strong>Repository</strong>：仓库区(或者本地仓库)， 就是安全存放数据的位置，这里面有你提交的所有版本数据。其中HEAD指向最新放入仓库的版本。</li><li><strong>Remote</strong>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</li></ul><p>本地三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_8_HEAD%E6%8C%87%E5%90%91%E7%9A%84%E7%89%88%E6%9C%AC.png"></p><ul><li><strong>Directory</strong>：使用GIt管理的目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li><strong>WorkSpace</strong>：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间</li><li><strong>.git</strong>：存放管理信息的目录，初始化仓库的时候自动创建。</li><li><strong>Index/Stage</strong>：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li><strong>Local Repo</strong>：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支(branch)。</li><li><strong>Stash</strong>：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><blockquote><p><strong>工作流程</strong></p></blockquote><p>git的工作流程一般是这样的：</p><ol><li>在工作目录中添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；</li><li>将暂存区域的文件提交到git仓库。</li></ol><p>因此，git管理文件有三种状态：已修改(modified)、已暂存(staged)、已提交(committed)</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_9_git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><blockquote><p>创建工程目录与常用指令</p></blockquote><p>工作目录(WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你的项目的目录，也可以是一个空目录，建议不要有中文，日常使用一下图中6个命令：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_10_git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库有两种方法：一种是创建一个全新仓库，另一种是克隆远程仓库。</p><ol><li><p>创建全新仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前目录中新建一个Git代码库</span><br>$ git init<br></code></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目中多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p></li></ol><blockquote><p>克隆远程仓库</p></blockquote><ol><li><p>另一种方式是克隆远程目录，也就是将远程服务器上的仓库完全镜像一份到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆一个项目和它整个历史代码(版本信息)</span><br>$ git <span class="hljs-built_in">clone</span> https://github.com/LihengXu/WPS_Apolloscape.git<br></code></pre></td></tr></table></figure></li><li><p>去gitee或者github上克隆一个测试</p></li></ol><h2 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h2><blockquote><p><strong>文件4种状态</strong></p></blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改，提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在不想提交的文件，或者要提交的文件没有提交上。</p><ul><li><strong>Untracked</strong>：未跟踪，此文件在文件夹种，并没有加入到git库，不参与版本控制，通过<code>git add</code> 状态变为 <code>staged</code></li><li><strong>Unmodify</strong>：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中的完全一致。这种类型的文件有两种去处，如果它被修改，而变为<code>Modified</code>，如果使用<code>git rm</code>移出版本库，则成为<code>untracked</code>文件</li><li><strong>Modified</strong>：文件已修改，仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过<code>git add</code>可以进入暂存<code>staged</code>状态，使用<code>git checkout</code>则丢弃修改，返回到<code>Unmodify</code>状态，这个<code>git checkout</code> 即从库中取出文件，覆盖当前修改。</li><li><strong>Staged</strong>：暂存状态。执行<code>git commit</code>则将修改同步到库中，这是库中文件和本地文件右边为一致，文件为<code>Unmodify</code>状态。执行<code>git reset HEAD filename</code>取消暂存，文件状态为<code>Modified</code>。</li></ul><blockquote><p><strong>查看文件状态</strong></p></blockquote><p>上面说文件有4种状态，通过如下命令可以查看文件的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看指定文件状态</span><br>git status [filename]<br><br><span class="hljs-comment"># 查看所有文件状态</span><br>git status<br><br><span class="hljs-comment"># 添加所有文件到暂存区</span><br>git add .<br><br><span class="hljs-comment"># 删除仓库中的&quot;README.en.md&quot;文件</span><br>git rm README.en.md<br><br><span class="hljs-comment"># 提交暂存区中内容到本地仓库，-m 提交信息</span><br>git commit -m <span class="hljs-string">&quot;for test&quot;</span><br><br><span class="hljs-comment"># 提交至远程仓库</span><br>git push<br></code></pre></td></tr></table></figure><blockquote><p><strong>忽略文件</strong></p></blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下面建立一个”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或者以井号(#)开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号(*)代表任意多字符，问号(?)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2,…})代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号(!)，表示例外规则，将不会忽略。</li><li>如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 为注释</span><br>*.txt      <span class="hljs-comment"># 忽略所有.txt结尾的文件，这样的话上传就不会被选中。</span><br>!lib.txt   <span class="hljs-comment"># 但lib.txt除外</span><br>/temp      <span class="hljs-comment"># 仅忽略根目录下的TODO文件，不包括其他目录temp</span><br>build/     <span class="hljs-comment"># 忽略build/目录下的所有文件</span><br>doc/*.txt  <span class="hljs-comment"># 会忽略doc/notes.txt但不包括doc/server/arch.txt</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通常前后端项目都需要的.gitignore的配置</span><br>*.class<br>*.<span class="hljs-built_in">log</span><br>*.lock<br><br><span class="hljs-comment"># Package Files #</span><br>*.jar<br>*.war<br>*.ear<br>target/<br><br><span class="hljs-comment"># idea</span><br>.idea/<br>*.iml<br><br>*velocity.log*<br><br><span class="hljs-comment">### STS ###</span><br>.apt_generated<br>.factorypath<br>.springBeans<br><br><span class="hljs-comment">### IntelliJ IDEA###</span><br>*.iml<br>*.ipr<br>*.iws<br>.idea<br>.classpath<br>.project<br>.settings/<br>bin/<br><br>*.<span class="hljs-built_in">log</span><br>tmp/<br><br><span class="hljs-comment">#rebel</span><br>*rebel.xml*<br></code></pre></td></tr></table></figure><h2 id="使用码云gitee"><a href="#使用码云gitee" class="headerlink" title="使用码云gitee"></a>使用码云gitee</h2><blockquote><p>国内一般使用gitee，而通常全球范围内大多都是用github，两者使用几乎一致，有些公司会自己搭建gitlab服务器</p></blockquote><ol><li><p>注册登录码云，完善个人信息，点击自己头像选设置</p></li><li><p>设置本机绑定SSH公钥，实现免密码登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入C:\Users\Administrator\.ssh目录</span><br><span class="hljs-comment"># 生成公钥，-t rsa是选择加密方式</span><br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_11_%E5%85%AC%E9%92%A5%E7%94%9F%E6%88%90%E7%BB%93%E6%9E%9C.png"></p></li><li><p>将公钥信息public key (打开上面的<code>.pub</code>文件，这就是公钥)添加到码云账户中即可</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_12_%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%A4%84.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_13_%E6%B7%BB%E5%8A%A0%E6%88%90%E5%8A%9F%E5%90%8E.png"></p></li><li><p>使用码云创建自己的仓库</p><p>新建仓库的位置</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_14_%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%931.png"></p><p>若公开的话有一个许可证选项：</p><p>开源是否可以随意转载，开源但是不能商用，等等各种限制协议。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_15_%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png"></p></li><li><p>最后克隆至本地即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://gitee.com/lihengxu/gitstudy.git<br></code></pre></td></tr></table></figure></li></ol><h2 id="IDEA中集成Git"><a href="#IDEA中集成Git" class="headerlink" title="IDEA中集成Git"></a>IDEA中集成Git</h2><p> <strong>(和Pycharm基本相同)</strong></p><ol><li>新建项目，绑定git<ul><li>将远程的git文件目录直接拷贝到项目中即可，或者直接创建项目到git文件目录下</li></ul></li><li>修改文件，使用IDEA操作git<ul><li>添加到暂存区：命令行 <code>git add .</code> ；或者手动鼠标右键点文件，选GIt然后点Add</li><li>commit提交：界面右上角有一个commit选项，点击后选择，并输入一下message即可</li><li>push到远程仓库：直接在命令行中输入<code>git push</code>即可</li></ul></li><li>提交测试</li></ol><hr><p><strong>以上全部都不涉及分支，全是单人操作</strong></p><hr><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支类似平行宇宙的概念，适用于多人协同开发</p><p>当存在多个分支，我们进行分支合并时，可能会有冲突产生</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_16_git%E5%88%86%E6%94%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>git分支中常见命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>git branch<br><br><span class="hljs-comment"># 列出所偶远程分支</span><br>git branch -r<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>git branch [branch -name]<br><br><span class="hljs-comment"># 切换到该分支</span><br>git checkout [branch]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><br><span class="hljs-comment"># 重命名分支</span><br>git branch -m [branch -oldname] [branch -newname]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 中止这一次提交的合并(当遇到冲突时)</span><br>$ git merge --abort<br><br><span class="hljs-comment"># 将分支变基(Rebase)到master</span><br><span class="hljs-comment"># 先切换到分支，再完成变基</span><br>$ git checkout [branch]<br>$ git rebase master<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch -name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch -name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><blockquote><p>想要形象的快速理解分支的概念，推荐一款图形化客户端<a href="https://www.gitkraken.com/">GitKraken</a></p></blockquote><blockquote><p>建议使用github账号关联登录，这里推荐<a href="https://www.bilibili.com/video/BV1KD4y1S7FL">教程</a>以及关于分支的进阶<a href="https://www.bilibili.com/video/bv1hA411v7qX/">教程</a></p></blockquote><p>注意主分支master应该非常稳定，只有分支代码稳定之后才能合并到主分支上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Git其实还是比较简单的，很多命令其实只要多用就能熟悉，尤其时分支的操作，这部分用图形界面多使用就能理解得更深刻</li><li>gitee下面有一个git大全，更多得一些插件，命令都能在里面查询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

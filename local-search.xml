<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis高级</title>
    <link href="/2021/03/27/Redis%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/03/27/Redis%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h1><p>基于<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>的视频的学习笔记</p><h2 id="1-Linux环节安装"><a href="#1-Linux环节安装" class="headerlink" title="1. Linux环节安装"></a>1. Linux环节安装</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_12_20210326.png"></p><h3 id="1-2-启动方式"><a href="#1-2-启动方式" class="headerlink" title="1.2 启动方式"></a>1.2 启动方式</h3><ul><li>普通默认端口启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 默认端口开启</span><br>redis-serve<br><span class="hljs-meta">#</span><span class="bash"> 默认端口连接</span><br>redis-cli<br></code></pre></td></tr></table></figure><ul><li>指定端口启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 换端口启动</span><br>redis-server --port 6380<br><span class="hljs-meta">#</span><span class="bash"> 连接客户端指定端口连接</span><br>redis-cli -p 6380<br></code></pre></td></tr></table></figure><ul><li>指定配置文件启动 redis-6379.conf</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br><span class="hljs-attribute">daemonize</span> yes<br><span class="hljs-attribute">logfile</span> <span class="hljs-string">&quot;6379.log&quot;</span><br><span class="hljs-attribute">dir</span> /redis-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/data<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动</span><br>redis-server redis-6379.conf<br>redis-server conf/redis-6379.conf<br><span class="hljs-meta">#</span><span class="bash"> 连接</span><br>redis-cli<br></code></pre></td></tr></table></figure><h2 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><blockquote><p>什么是持久化：</p></blockquote><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制</p><blockquote><p>为什么要持久化：</p></blockquote><p>防止数据的意外丢失，确保数据安全</p><blockquote><p>持久化过程保存什么</p></blockquote><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong></li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_13_20210326.png"></p><h3 id="2-2-RDB"><a href="#2-2-RDB" class="headerlink" title="2.2 RDB"></a>2.2 RDB</h3><h4 id="2-2-1-RDB启动方式1–save指令"><a href="#2-2-1-RDB启动方式1–save指令" class="headerlink" title="2.2.1 RDB启动方式1–save指令"></a>2.2.1 RDB启动方式1–save指令</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><h5 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h5><ul><li>dbfilename dump.rdb<ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb</li><li>经验：通常设置为<font color="0000FF"><strong>dump-</strong></font><font color="FF0000"><strong>端口号</strong></font><font color="0000FF"><strong>.rdb</strong></font></li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径</li><li>经验：通常设置成存储空间较大的目录中，目录名称<font color="FF0000"><strong>data</strong></font></li></ul></li><li>rdbcompression yes<ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li></ul><p>配置后，conf文件内容为：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_14_20210326.png"></p><h5 id="save指令工作原理"><a href="#save指令工作原理" class="headerlink" title="save指令工作原理"></a>save指令工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_15_20210326.png"></p><h4 id="2-2-2-RDB启动方式2–bgsave指令"><a href="#2-2-2-RDB启动方式2–bgsave指令" class="headerlink" title="2.2.2 RDB启动方式2–bgsave指令"></a>2.2.2 RDB启动方式2–bgsave指令</h4><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgsave<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong></p></li></ul><h5 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h5><ul><li><p>dbfilename dump.rdb（同save）</p></li><li><p>dir（同save）</p></li><li><p>rdbcompression yes（同save）</p></li><li><p>rdbchecksum yes（同save）</p></li><li><p>stop-writes-on-bgsave-error yes</p><ul><li>说明：后台存储过程中如果出现错误现象，是否停止保存现象</li><li>经验：通常默认为开启状态</li></ul></li></ul><h5 id="bgsave指令工作原理"><a href="#bgsave指令工作原理" class="headerlink" title="bgsave指令工作原理"></a>bgsave指令工作原理</h5><p><img src="C:\Users\LihengXu\AppData\Roaming\Typora\typora-user-images\image-20210326200500978.png" alt="image-20210326200500978"></p><h4 id="2-2-3-RDB启动方式3–save配置"><a href="#2-2-3-RDB启动方式3–save配置" class="headerlink" title="2.2.3 RDB启动方式3–save配置"></a>2.2.3 RDB启动方式3–save配置</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li><p>配置到.conf文件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes<br></code></pre></td></tr></table></figure><p>配置后：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_17_20210326.png"></p></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p></li><li><p>参数</p><ul><li>second：监控时间范围</li><li>changes：监控key的变化量</li></ul></li></ul><h5 id="save配置工作原理"><a href="#save配置工作原理" class="headerlink" title="save配置工作原理"></a>save配置工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_18_20210326.png"></p><p>注意：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系</li><li>save配置启动后执行的是<strong>bgsave操作</strong></li></ul><h4 id="2-2-4-三种启动方式对比"><a href="#2-2-4-三种启动方式对比" class="headerlink" title="2.2.4 三种启动方式对比"></a>2.2.4 三种启动方式对比</h4><table><thead><tr><th>方式</th><th>save指令</th><th>bgsave指令</th></tr></thead><tbody><tr><td>读写</td><td>同步</td><td>异步</td></tr><tr><td>阻塞客户端指令</td><td>是</td><td>否</td></tr><tr><td>额外内存消耗</td><td>否</td><td>是</td></tr><tr><td>启动新线程</td><td>否</td><td>是</td></tr></tbody></table><h4 id="2-2-5-RDB特殊启动形式（了解）"><a href="#2-2-5-RDB特殊启动形式（了解）" class="headerlink" title="2.2.5 RDB特殊启动形式（了解）"></a>2.2.5 RDB特殊启动形式（了解）</h4><ul><li><p>全量复制</p><p>在主从复制中详细讲解</p></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debug reload<br></code></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown save<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-6-RDB优缺点"><a href="#2-2-6-RDB优缺点" class="headerlink" title="2.2.6 RDB优缺点"></a>2.2.6 RDB优缺点</h4><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li></ul></li></ul><h3 id="2-3-AOF"><a href="#2-3-AOF" class="headerlink" title="2.3 AOF"></a>2.3 AOF</h3><h4 id="2-3-1-AOF概念"><a href="#2-3-1-AOF概念" class="headerlink" title="2.3.1 AOF概念"></a>2.3.1 AOF概念</h4><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li></ul><h4 id="2-3-2-AOF写数据过程"><a href="#2-3-2-AOF写数据过程" class="headerlink" title="2.3.2 AOF写数据过程"></a>2.3.2 AOF写数据过程</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_20_20210326.png"></p><h4 id="2-3-3-AOF写数据三种策略-appendfsync"><a href="#2-3-3-AOF写数据三种策略-appendfsync" class="headerlink" title="2.3.3 AOF写数据三种策略(appendfsync)"></a>2.3.3 AOF写数据三种策略(appendfsync)</h4><ul><li>always（每次）<ul><li>每次写入操作均同步到AOF文件中，<font color="0000FF"><strong>数据零误差</strong></font>，<font color="FF0000"><strong>性能较低</strong></font>，<strong>不建议使用</strong></li></ul></li><li>everysec（每秒）<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据<font color="0000FF"><strong>准确性较高</strong></font>，<font color="0000FF"><strong>性能较高</strong></font> ，<strong>建议使用</strong>，也是默认配置</li><li>在系统突然宕机的情况下丢失1秒内的数据</li></ul></li><li>no（系统控制）<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<font color="FF0000"><strong>不可控</strong></font></li></ul></li></ul><h4 id="2-3-4-AOF功能开启"><a href="#2-3-4-AOF功能开启" class="headerlink" title="2.3.4 AOF功能开启"></a>2.3.4 AOF功能开启</h4><ul><li><p>配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ul><li> 作用</li></ul><p>  是否开启AOF持久化功能，<strong>默认为不开启状态</strong></p></li><li><p>配置</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span><br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF写数据策略</p></li></ul></li></ul><p>配置后，conf配置文件如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_19_20210326.png"></p><h4 id="2-3-5-AOF相关配置"><a href="#2-3-5-AOF相关配置" class="headerlink" title="2.3.5 AOF相关配置"></a>2.3.5 AOF相关配置</h4><ul><li><p>配置</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">appendfilename filename</span><br></code></pre></td></tr></table></figure><ul><li> 作用</li></ul><p>  AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p></li><li><p>配置</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">dir</span><br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p></li></ul></li></ul><h4 id="2-3-6-AOF重写"><a href="#2-3-6-AOF重写" class="headerlink" title="2.3.6 AOF重写"></a>2.3.6 AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li></ul></li><li>对同一数据的多条写命令合并为一条命令<ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li><p>手动重写</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span><br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.触发条件设置</span><br><span class="hljs-meta">#</span><span class="bash"> 触发重写的最小大小</span><br>auto-aof-rewrite-min-size size <br><span class="hljs-meta">#</span><span class="bash"> 触发重写须达到的最小百分比</span> <br>auto-aof-rewrite-percentage percentage<br><br><span class="hljs-meta">#</span><span class="bash"> 2.触发比对参数（ 运行指令info Persistence获取具体信息 ）</span><br><span class="hljs-meta">#</span><span class="bash"> 当前.aof的文件大小</span><br>aof_current_size <br><span class="hljs-meta">#</span><span class="bash"> 基础文件大小</span><br>aof_base_size<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_22_20210326.png"></p></li></ul><h5 id="重写工作原理"><a href="#重写工作原理" class="headerlink" title="重写工作原理"></a>重写工作原理</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_21_20210326.png"></p><h5 id="重写工作流程"><a href="#重写工作流程" class="headerlink" title="重写工作流程"></a>重写工作流程</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_23_20210326.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_24_20210326.png"></p><h3 id="2-4-RDB与AOF的区别"><a href="#2-4-RDB与AOF的区别" class="headerlink" title="2.4 RDB与AOF的区别"></a>2.4 RDB与AOF的区别</h3><table><thead><tr><th>持久化方式</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级：压缩）</td><td>大（指令级：重写）</td></tr><tr><td>存储速度</td><td>慢</td><td>快</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>会丢失数据</td><td>依据策略决定</td></tr><tr><td>资源消耗</td><td>高/重量级</td><td>低/轻量级</td></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr></tbody></table><h3 id="2-5-RDB与AOF的选择"><a href="#2-5-RDB与AOF的选择" class="headerlink" title="2.5 RDB与AOF的选择"></a>2.5 RDB与AOF的选择</h3><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li><li><strong>灾难恢复选用RDB</strong></li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li></ul></li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2><h3 id="3-1-事务简介"><a href="#3-1-事务简介" class="headerlink" title="3.1 事务简介"></a>3.1 事务简介</h3><blockquote><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p></blockquote><h3 id="3-2-事务基本操作"><a href="#3-2-事务基本操作" class="headerlink" title="3.2 事务基本操作"></a>3.2 事务基本操作</h3><ul><li><p>开启事务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span><br></code></pre></td></tr></table></figure><ul><li>作用：作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li><p>取消事务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span><br></code></pre></td></tr></table></figure><ul><li>作用终止当前事务的定义，发生在multi之后，exec之前</li></ul></li><li><p>执行事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span><br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用</li></ul></li></ul><h3 id="3-3-事务工作流程"><a href="#3-3-事务工作流程" class="headerlink" title="3.3 事务工作流程"></a>3.3 事务工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_25_20210326.png"></p><h3 id="3-4-事务注意事项"><a href="#3-4-事务注意事项" class="headerlink" title="3.4 事务注意事项"></a>3.4 事务注意事项</h3><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p><ul><li>语法错误<ul><li>指命令书写格式有误 例如执行了一条不存在的指令</li></ul></li><li>处理结果<ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li></ul><p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong></p><ul><li>运行错误<ul><li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作</li></ul></li><li>处理结果<ul><li>能够正确运行的命令会执行，运行错误的命令不会被执行</li></ul></li></ul><p><font color="FF0000"><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。</font></p><h3 id="3-5-锁"><a href="#3-5-锁" class="headerlink" title="3.5 锁"></a>3.5 锁</h3><h4 id="3-5-1-基于特定条件的事务执行–锁"><a href="#3-5-1-基于特定条件的事务执行–锁" class="headerlink" title="3.5.1 基于特定条件的事务执行–锁"></a>3.5.1 基于特定条件的事务执行–锁</h4><p>监视锁类似CAS的思想，如果监视对象在事务执行前被修改了，那么就不执行了</p><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">watch</span> key<span class="hljs-number">1</span>, key<span class="hljs-number">2</span>....<br></code></pre></td></tr></table></figure></li><li><p>取消对<strong>所有</strong>key的监视</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-2基于特定条件的事务执行–分布式锁"><a href="#3-5-2基于特定条件的事务执行–分布式锁" class="headerlink" title="3.5.2基于特定条件的事务执行–分布式锁"></a>3.5.2基于特定条件的事务执行–分布式锁</h4><p>分布式锁类似悲观锁的思想，但是只是一个标记</p><ul><li><p>使用 setnx 设置一个公共锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 上锁</span><br>setnx lock-key value<br><span class="hljs-meta">#</span><span class="bash"> 释放锁</span><br>del lock-key<br></code></pre></td></tr></table></figure><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁</li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性</p><h4 id="3-5-3-分布式锁改良"><a href="#3-5-3-分布式锁改良" class="headerlink" title="3.5.3 分布式锁改良"></a>3.5.3 分布式锁改良</h4><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">expire <span class="hljs-keyword">lock</span>-key seconds<br>pexpire <span class="hljs-keyword">lock</span>-key millisecondsCopy<br></code></pre></td></tr></table></figure></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul><h2 id="4-删除策略"><a href="#4-删除策略" class="headerlink" title="4. 删除策略"></a>4. 删除策略</h2><h3 id="4-1-数据删除策略"><a href="#4-1-数据删除策略" class="headerlink" title="4.1 数据删除策略"></a>4.1 数据删除策略</h3><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_26_20210327.png"></p><h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p><h3 id="4-2-三种删除策略"><a href="#4-2-三种删除策略" class="headerlink" title="4.2 三种删除策略"></a>4.2 三种删除策略</h3><h4 id="4-2-1-定时删除"><a href="#4-2-1-定时删除" class="headerlink" title="4.2.1 定时删除"></a>4.2.1 定时删除</h4><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</li><li>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</li></ul><h4 id="4-2-2-惰性删除"><a href="#4-2-2-惰性删除" class="headerlink" title="4.2.2 惰性删除"></a>4.2.2 惰性删除</h4><ul><li>数据到达过期时间，不做处理。等下次访问该数据时<ul><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ul></li><li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除</li><li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能 （<strong>拿空间换时间</strong>）</li></ul><h4 id="4-2-3-定期删除（折中方案）"><a href="#4-2-3-定期删除（折中方案）" class="headerlink" title="4.2.3 定期删除（折中方案）"></a>4.2.3 定期删除（折中方案）</h4><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_27_20210327.png"></p><h4 id="4-2-4-删除策略对比"><a href="#4-2-4-删除策略对比" class="headerlink" title="4.2.4 删除策略对比"></a>4.2.4 删除策略对比</h4><table><thead><tr><th>删除策略</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>定时删除</td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频率高</td><td>拿时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>拿空间换时间</td></tr><tr><td>定期删除</td><td>内存定期随机清理</td><td>每秒花费固定的CPU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><p>redis内部一般使用惰性删除和定期删除</p><h3 id="4-3-逐出算法（淘汰算法）"><a href="#4-3-逐出算法（淘汰算法）" class="headerlink" title="4.3 逐出算法（淘汰算法）"></a>4.3 逐出算法（淘汰算法）</h3><p>**当新数据进入redis时，如果内存不足怎么办？ **</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()<strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为</strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h4 id="4-3-1-影响数据逐出的相关配置"><a href="#4-3-1-影响数据逐出的相关配置" class="headerlink" title="4.3.1 影响数据逐出的相关配置"></a>4.3.1 影响数据逐出的相关配置</h4><ul><li><p>最大可使用内存</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span><br></code></pre></td></tr></table></figure><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p>每次选取待删除数据的个数</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span><br></code></pre></td></tr></table></figure><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p>删除策略</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span><br></code></pre></td></tr></table></figure><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p></li><li><p>删除策略包括以下8种不同设置：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_28_20210327.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 配置方式</span><br>maxmemory-policy volatile-lru<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-3-2-数据逐出策略配置依据"><a href="#4-3-2-数据逐出策略配置依据" class="headerlink" title="4.3.2 数据逐出策略配置依据"></a>4.3.2 数据逐出策略配置依据</h4><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_29_20210327.png"></p><h2 id="5-服务器基础配置"><a href="#5-服务器基础配置" class="headerlink" title="5. 服务器基础配置"></a>5. 服务器基础配置</h2><h3 id="5-1-服务器端设定"><a href="#5-1-服务器端设定" class="headerlink" title="5.1 服务器端设定"></a>5.1 服务器端设定</h3><p>设置到conf文件中</p><ul><li>设置服务器以守护进程的方式运行</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span> | <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><ul><li>绑定主机地址</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><ul><li>设置服务器端口号</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><ul><li>设置数据库数量</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">database</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_30_20210327.png"></p><h3 id="5-2-日志配置"><a href="#5-2-日志配置" class="headerlink" title="5.2 日志配置"></a>5.2 日志配置</h3><ul><li>设置服务器以指定日志记录级别</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">loglevel <span class="hljs-keyword">debug</span>|<span class="hljs-keyword">verbose</span>|<span class="hljs-keyword">notice</span>|<span class="hljs-built_in">warning</span><br></code></pre></td></tr></table></figure><ul><li>日志记录文件名</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">logfile 端口号.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频率</p><h3 id="5-3-客户端配置"><a href="#5-3-客户端配置" class="headerlink" title="5.3 客户端配置"></a>5.3 客户端配置</h3><ul><li>设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis会关闭新的连接</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">maxclients</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为0</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">timeout</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h3 id="5-4-多服务器快捷配置"><a href="#5-4-多服务器快捷配置" class="headerlink" title="5.4 多服务器快捷配置"></a>5.4 多服务器快捷配置</h3><ul><li>导入并加载指定配置文件信息，用于快速船舰redis公共配置较多的redis实例配置文件，便于维护</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-regexp">/path/</span>server-端口号.conf<br></code></pre></td></tr></table></figure><h2 id="6-高级数据类型"><a href="#6-高级数据类型" class="headerlink" title="6. 高级数据类型"></a>6. 高级数据类型</h2><h3 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h3><h4 id="6-1-1-基础操作"><a href="#6-1-1-基础操作" class="headerlink" title="6.1.1 基础操作"></a>6.1.1 基础操作</h4><ul><li><p>获取指定key对应偏移量上的bit值</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">setbit key <span class="hljs-built_in">offset</span> value<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-1-2-扩展操作"><a href="#6-1-2-扩展操作" class="headerlink" title="6.1.2 扩展操作"></a>6.1.2 扩展操作</h4><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key<span class="hljs-number">1</span><span class="hljs-meta"> [key2...]</span><br></code></pre></td></tr></table></figure><ul><li>and：交</li><li>or：并</li><li>not：非</li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h3><h4 id="6-2-1-基数"><a href="#6-2-1-基数" class="headerlink" title="6.2.1 基数"></a>6.2.1 基数</h4><ul><li>基数是数据集<strong>去重后元素个数</strong></li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_31_20210327.png"></p><h4 id="6-2-2-基本操作"><a href="#6-2-2-基本操作" class="headerlink" title="6.2.2 基本操作"></a>6.2.2 基本操作</h4><ul><li><p>添加数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfadd</span> key element<span class="hljs-number">1</span>, element<span class="hljs-number">2</span>...<br></code></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfcount</span> key<span class="hljs-number">1</span> key<span class="hljs-number">2</span>....<br></code></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="6-2-3-相关说明"><a href="#6-2-3-相关说明" class="headerlink" title="6.2.3 相关说明"></a>6.2.3 相关说明</h4><ul><li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong></li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong></li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少</li></ul><h3 id="6-3-GEO"><a href="#6-3-GEO" class="headerlink" title="6.3 GEO"></a>6.3 GEO</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加坐标点</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">geoadd key longitude latitude member <span class="hljs-comment">[longitude latitude member ...]</span> <br>georadius key longitude latitude radius m|km|ft|mi <span class="hljs-comment">[withcoord]</span> <span class="hljs-comment">[withdist]</span> <span class="hljs-comment">[withhash]</span> <span class="hljs-comment">[count count]</span><br></code></pre></td></tr></table></figure></li><li><p>获取坐标点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geopos <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...] <br>georadiusbymember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-built_in">radius</span> m|km|ft|mi [withcoord] [withdist] [withhash] [count count]<br></code></pre></td></tr></table></figure></li><li><p>计算坐标点距离</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] <br>geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2021/03/26/Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/26/Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p>学习Javaweb时，学习过Redis的基本使用，学习<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>进阶内容顺带复习一下基础，整理本学习笔记</p><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h2><h3 id="1-1-NoSQL简介"><a href="#1-1-NoSQL简介" class="headerlink" title="1.1 NoSQL简介"></a>1.1 NoSQL简介</h3><p>NoSQL：即Not-OnlySQL（泛指非关系性数据库），作为关系型数据库的补充</p><p>作用：应对基于海量数据和海量用户的数据处理。</p><p>特征：</p><ul><li>可扩容，可伸展</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><p>常见的NoSQL数据库：</p><ul><li><font color="FF0000"><strong>Redis</strong></font></li><li>memcache</li><li>HBase</li><li>MongoDB</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_2_20210325.png"></p><h3 id="1-2-Redis简介"><a href="#1-2-Redis简介" class="headerlink" title="1.2 Redis简介"></a>1.2 Redis简介</h3><blockquote><p>概念：Redis（REmote DIctionary Server）是用C语言开发的一个开源的高性能键值对（key-value）数据库。</p></blockquote><p>特征：</p><ul><li>数据之间没有必然的联系</li><li>内部采用了单线程机制进行工作</li><li>高性能</li><li>多数据类型支持<ul><li>String</li><li>list</li><li>hash</li><li>set</li><li>sorted_set</li></ul></li><li>持久化支持，可以进行数据灾难恢复</li></ul><p>应用：</p><ul><li>热点数据加速查询（热点资讯，热点商品）</li><li>任务队列（秒杀）</li><li>即使信息查询（排行榜）</li><li>时效性习性控制（验证码）</li><li>分布式数据共享（分布式集群中的session分离）</li><li>消息队列</li><li>分布式锁</li></ul><h3 id="1-3-Redis常用指令"><a href="#1-3-Redis常用指令" class="headerlink" title="1.3 Redis常用指令"></a>1.3 Redis常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动容器</span><br>docker run -d -p 6379:6379 -it  --name=&quot;myredis&quot;  redis<br><span class="hljs-meta">#</span><span class="bash"> 输入密码：</span><br>auth 密码<br><span class="hljs-meta">#</span><span class="bash"> 进入redis容器</span><br>docker exec -it myredis  redis-cli<br><span class="hljs-meta">#</span><span class="bash"> 退出</span><br>quit<br>exit<br><span class="hljs-meta">#</span><span class="bash"> 清屏</span><br>clear<br><span class="hljs-meta">#</span><span class="bash"> 获取帮助, 可以使用Tab键来切换</span><br>help 命令名称<br>help @组名<br><span class="hljs-meta">#</span><span class="bash"> 设置/获取数据</span><br>set name xlh<br>get name<br></code></pre></td></tr></table></figure><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>redis数据存储格式</p><ul><li>redis自身是一个map，其中所有的数据都是采用的<font color="FF0000">key：value</font>的形式存储[^1]</li><li>数据类型指的是value部分的类型，key部分都是String</li></ul><h3 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h3><h4 id="2-1-1-基本操作"><a href="#2-1-1-基本操作" class="headerlink" title="2.1.1 基本操作"></a>2.1.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置String</span><br>set key value<br>mset key1 value1 key2 value2...<br><br><span class="hljs-meta">#</span><span class="bash"> 得到String</span><br>get key <br>mget key1 key2...<br><span class="hljs-meta">#</span><span class="bash"> 获取字符串长度</span><br>strlen key<br><br><span class="hljs-meta">#</span><span class="bash"> 删除String</span><br>del key<br><br><span class="hljs-meta">#</span><span class="bash"> 向字符串的后面追加字符，如果有就补在后面，如果没有就新建</span><br>append key value<br></code></pre></td></tr></table></figure><h4 id="2-1-2-单-多指令对比"><a href="#2-1-2-单-多指令对比" class="headerlink" title="2.1.2 单/多指令对比"></a>2.1.2 单/多指令对比</h4><ul><li>单指令对比多指令（对于多指令，如果执行事间过长对于单线程操作时不适用的，注意及时切割）</li></ul><h4 id="2-1-3-拓展操作"><a href="#2-1-3-拓展操作" class="headerlink" title="2.1.3 拓展操作"></a>2.1.3 拓展操作</h4><ul><li><p>String作为数值的操作</p><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。</li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意：<font color="FF0000">按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。</font> 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p><strong>tips：</strong></p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></li><li>此方案适用于所有数据库，且支持数据库集群</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 增长指令，只有当value为数字时才能增长</span><br>incr key  <br>incrby key increment  <br>incrbyfloat key increment <br><br><span class="hljs-meta">#</span><span class="bash"> 减少指令，有当value为数字时才能减少</span><br>decr key  <br>decrby key increment<br></code></pre></td></tr></table></figure><ul><li><strong>指定生命周期</strong><ul><li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置数据的生命周期，单位 秒</span><br>setex key seconds value<br><span class="hljs-meta">#</span><span class="bash"> 设置数据的生命周期，单位 毫秒</span><br>psetex key milliseconds value<br></code></pre></td></tr></table></figure><h4 id="2-1-4-String类型数据操作的注意事项"><a href="#2-1-4-String类型数据操作的注意事项" class="headerlink" title="2.1.4 String类型数据操作的注意事项"></a>2.1.4 String类型数据操作的注意事项</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_3_20210325.png"></p><ul><li><p>key的设置约定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_4_20210326.png"></p></li></ul><h3 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_5_20210326.png"></p><ul><li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>需要的存储结构：一个存储空间保存多个键值对数据</li><li>hash类型：底层使用哈希表结构实现数据存储</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_6_20210325.png"></p><h4 id="2-2-1-基本操作"><a href="#2-2-1-基本操作" class="headerlink" title="2.2.1 基本操作"></a>2.2.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 插入（如果已存在同名的field，会被覆盖）</span><br>hset key field value<br>hmset key field1 value1 field2 value2...<br><br><span class="hljs-meta">#</span><span class="bash"> 取出</span><br>hget key field<br>hgetall key<br><br><span class="hljs-meta">#</span><span class="bash"> 删除</span><br>hdel key field1 field2...<br><br><span class="hljs-meta">#</span><span class="bash"> 获取field数量</span><br>hlen key<br><br><span class="hljs-meta">#</span><span class="bash"> 查看是否存在</span><br>hexists key field<br></code></pre></td></tr></table></figure><h4 id="2-2-2-拓展操作"><a href="#2-2-2-拓展操作" class="headerlink" title="2.2.2 拓展操作"></a>2.2.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取哈希表中所有的字段名或字段值</span> <br>hkeys key<br>hvals key<br><br><span class="hljs-meta">#</span><span class="bash"> 设置指定字段的数值数据增加指定范围的值</span> <br>hincrby key field increment <br>hdecrby key field increment<br><br><span class="hljs-meta">#</span><span class="bash"> 插入（如果已存在同名的field，不会被覆盖）</span><br>hsetnx key field value<br></code></pre></td></tr></table></figure><h4 id="2-2-3-hash类型数据操作的注意事项"><a href="#2-2-3-hash类型数据操作的注意事项" class="headerlink" title="2.2.3 hash类型数据操作的注意事项"></a>2.2.3 hash类型数据操作的注意事项</h4><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong></li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li></ul><h3 id="2-3-List"><a href="#2-3-List" class="headerlink" title="2.3 List"></a>2.3 List</h3><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型：保存多个数据，底层使用双向链表存储结构实现</li><li><strong>元素有序，且可重</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_8_20210326.png"></p><h4 id="2-3-1-基本操作"><a href="#2-3-1-基本操作" class="headerlink" title="2.3.1 基本操作"></a>2.3.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加修改数据,lpush为从左边添加，rpush为从右边添加</span><br>lpush key value1 value2 value3...<br>rpush key value1 value2 value3...<br><br><span class="hljs-meta">#</span><span class="bash"> 查看数据, 从左边开始向右查看. 如果不知道list有多少个元素，end的值可以为-1,代表倒数第一个元素</span><br><span class="hljs-meta">#</span><span class="bash"> lpush先进的元素放在最后,rpush先进的元素放在最前面</span><br>lrange key start end<br><span class="hljs-meta">#</span><span class="bash"> 取出对应索引的元素</span><br>lindex key index<br><span class="hljs-meta">#</span><span class="bash"> 得到长度</span><br>llen key<br><br><span class="hljs-meta">#</span><span class="bash"> 获取并移除元素（从list左边或者右边移除）</span><br>lpop key<br>rpop key<br></code></pre></td></tr></table></figure><h4 id="2-3-2-拓展操作"><a href="#2-3-2-拓展操作" class="headerlink" title="2.3.2 拓展操作"></a>2.3.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><br>blpop key1 key2... timeout<br>brpop key1 key2... timeout<br><br><span class="hljs-meta">#</span><span class="bash"> 移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span><br>lrem key count value<br></code></pre></td></tr></table></figure><h4 id="2-3-3-list类型数据操作注意事项"><a href="#2-3-3-list类型数据操作注意事项" class="headerlink" title="2.3.3 list类型数据操作注意事项"></a>2.3.3 list类型数据操作注意事项</h4><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul><h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><ul><li>新的存储需求：存储大量数据，在查询方面提供更高的效率</li><li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存键，不存值（nil），并且值时不允许重复的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_7_20210325.png"></p><h4 id="2-4-1-基本操作"><a href="#2-4-1-基本操作" class="headerlink" title="2.4.1 基本操作"></a>2.4.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加元素</span><br>sadd key member1 member2...<br><br><span class="hljs-meta">#</span><span class="bash"> 查看元素</span><br>smembers key<br><br><span class="hljs-meta">#</span><span class="bash"> 移除元素</span><br>srem key member<br><br><span class="hljs-meta">#</span><span class="bash"> 查看元素个数</span><br>scard key<br><br><span class="hljs-meta">#</span><span class="bash"> 查看某个元素是否存在</span><br>sismember key member<br></code></pre></td></tr></table></figure><h4 id="2-4-2-拓展操作"><a href="#2-4-2-拓展操作" class="headerlink" title="2.4.2 拓展操作"></a>2.4.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从<span class="hljs-built_in">set</span>中任意选出count个元素</span><br>srandmember key count<br><br><span class="hljs-meta">#</span><span class="bash"> 从<span class="hljs-built_in">set</span>中任意选出count个元素并移除</span><br>spop key count<br><br><span class="hljs-meta">#</span><span class="bash"> 求两个集合的交集、并集、差集</span><br>sinter key1 key2...<br>sunion key1 key2...<br>sdiff key1 key2...<br><br><span class="hljs-meta">#</span><span class="bash"> 求两个<span class="hljs-built_in">set</span>的交集、并集、差集，并放入另一个<span class="hljs-built_in">set</span>中</span><br>sinterstore destination key1 key2...<br>sunionstore destination key1 key2...<br>sdiffstore destination key1 key2...<br><br><span class="hljs-meta">#</span><span class="bash"> 求指定元素从原集合放入目标集合中</span><br>smove source destination key<br></code></pre></td></tr></table></figure><h4 id="2-4-3-Set类型数据操作的注意事项"><a href="#2-4-3-Set类型数据操作的注意事项" class="headerlink" title="2.4.3 Set类型数据操作的注意事项"></a>2.4.3 Set类型数据操作的注意事项</h4><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启动hash中存储值的空间</li></ul><h3 id="2-5-Sorted-set"><a href="#2-5-Sorted-set" class="headerlink" title="2.5 Sorted_set"></a>2.5 Sorted_set</h3><ul><li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式</li><li>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li><li><strong>不重但有序（score）</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_9_20210326.png"></p><h4 id="2-5-1-基本操作"><a href="#2-5-1-基本操作" class="headerlink" title="2.5.1 基本操作"></a>2.5.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 插入元素, 需要指定score(用于排序)</span><br>zadd key score1 member1 score2 member2<br><br><span class="hljs-meta">#</span><span class="bash"> 查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrange key start end [withscore]<br><span class="hljs-meta">#</span><span class="bash"> 查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br>zrevrange key start end [withscore]<br><br><span class="hljs-meta">#</span><span class="bash"> 移除元素</span><br>zrem key member1 member2...<br><br><span class="hljs-meta">#</span><span class="bash"> 按条件获取数据, 其中offset为索引开始位置，count为获取的数目</span><br>zrangebyscore key min max [withscore] [limit offset count]<br>zrevrangebyscore key max min [withscore] [limit offset count]<br><br><span class="hljs-meta">#</span><span class="bash"> 按条件移除元素</span><br>zremrangebyrank key start end<br>zremrangebyscore key min max<br><span class="hljs-meta">#</span><span class="bash"> 按照从大到小的顺序移除count个值</span><br>zpopmax key [count]<br><span class="hljs-meta">#</span><span class="bash"> 按照从小到大的顺序移除count个值</span><br>zpopmin key [count]<br><br><span class="hljs-meta">#</span><span class="bash"> 获得元素个数</span><br>zcard key<br><br><span class="hljs-meta">#</span><span class="bash"> 获得元素在范围内的个数</span><br>zcount min max<br><br><span class="hljs-meta">#</span><span class="bash"> 求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目</span><br>zinterstore destination numkeys key1 key2...<br>zunionstore destination numkeys key1 key2...<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong></li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong></li></ul><h4 id="2-5-2-拓展操作"><a href="#2-5-2-拓展操作" class="headerlink" title="2.5.2 拓展操作"></a>2.5.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看某个元素的索引(排名)</span><br>zrank key member<br>zrevrank key member<br><br><span class="hljs-meta">#</span><span class="bash"> 查看某个元素索引的值</span><br>zscore key member<br><span class="hljs-meta">#</span><span class="bash"> 增加某个元素索引的值</span><br>zincrby key increment member<br></code></pre></td></tr></table></figure><h4 id="2-5-3-sorted-set类型数据操作的注意事项"><a href="#2-5-3-sorted-set类型数据操作的注意事项" class="headerlink" title="2.5.3 sorted_set类型数据操作的注意事项"></a>2.5.3 sorted_set类型数据操作的注意事项</h4><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li></ul><h2 id="3-通用指令"><a href="#3-通用指令" class="headerlink" title="3. 通用指令"></a>3. 通用指令</h2><h3 id="3-1-key-特征"><a href="#3-1-key-特征" class="headerlink" title="3.1 key 特征"></a>3.1 key 特征</h3><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据</li></ul><h3 id="3-2-key通用操作"><a href="#3-2-key通用操作" class="headerlink" title="3.2 key通用操作"></a>3.2 key通用操作</h3><h4 id="3-2-1-基本操作"><a href="#3-2-1-基本操作" class="headerlink" title="3.2.1 基本操作"></a>3.2.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看key是否存在</span><br>exists key<br><br><span class="hljs-meta">#</span><span class="bash"> 删除key</span><br>del key<br><br><span class="hljs-meta">#</span><span class="bash"> 查看key的类型</span><br>type key<br></code></pre></td></tr></table></figure><h4 id="3-2-2-拓展操作"><a href="#3-2-2-拓展操作" class="headerlink" title="3.2.2 拓展操作"></a>3.2.2 拓展操作</h4><ul><li>时效性操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置生命周期</span><br>expire key seconds<br>pexpire key milliseconds<br><span class="hljs-meta">#</span><span class="bash"> Linux下使用时间戳设置有效事件</span><br>expireat key timestamp<br>pexpireat key milliseconds-timestamp<br><br><span class="hljs-meta">#</span><span class="bash"> 查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br>ttl key<br>pttl key<br><br><span class="hljs-meta">#</span><span class="bash"> 将有时限的数据设置为永久有效</span><br>persist key<br></code></pre></td></tr></table></figure><ul><li>查询操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 根据key查询符合条件的数据</span><br>keys pattern<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_10_20210326.png"></p><ul><li>其他操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span><br>rename key newKey<br>renamenx key newKey<br><br><span class="hljs-meta">#</span><span class="bash"> 查看所有关于key的操作, 可以使用Tab快速切换</span><br>help @generic<br></code></pre></td></tr></table></figure><h3 id="3-3-数据库的通用指令"><a href="#3-3-数据库的通用指令" class="headerlink" title="3.3 数据库的通用指令"></a>3.3 数据库的通用指令</h3><p>key重复的问题</p><ul><li>key时程序员定义的</li><li>redis使用中数据量不断增加，key也会不断增多</li><li>数据部分种类，类别混在在一起容易重复或冲突</li></ul><p>解决：数据库</p><ul><li>Redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul><h4 id="3-3-1-基本操作"><a href="#3-3-1-基本操作" class="headerlink" title="3.3.1 基本操作"></a>3.3.1 基本操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换数据库 0~15</span><br>select index<br><br><span class="hljs-meta">#</span><span class="bash"> 其他操作</span><br>quit<br>ping<br>echo massage<br></code></pre></td></tr></table></figure><h4 id="3-3-2-拓展操作"><a href="#3-3-2-拓展操作" class="headerlink" title="3.3.2 拓展操作"></a>3.3.2 拓展操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 移动数据, 必须保证目的数据库中没有该数据</span><br>mov key db<br><br><span class="hljs-meta">#</span><span class="bash"> 查看该库中数据总量</span><br>dbsize<br></code></pre></td></tr></table></figure><h2 id="4-Jedis"><a href="#4-Jedis" class="headerlink" title="4. Jedis"></a>4. Jedis</h2><ul><li>Java语言连接redis的服务<ul><li>Jedis</li><li>SpringData Redis</li><li>Lettuce</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_11_20210326.png"></p><ul><li><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</li></ul><h3 id="4-1-Java操作redis的步骤"><a href="#4-1-Java操作redis的步骤" class="headerlink" title="4.1 Java操作redis的步骤"></a>4.1 Java操作redis的步骤</h3><ul><li>连接Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数为Redis所在的ip地址和端口号</span><br>Jedis jedis = <span class="hljs-keyword">new</span> Jedis(String host, <span class="hljs-keyword">int</span> port)<br></code></pre></td></tr></table></figure><ul><li>操作Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 操作redis的指令和redis本身的指令几乎一致</span><br>jedis.set(String key, String value);<br></code></pre></td></tr></table></figure><ul><li>断开连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.close();<br></code></pre></td></tr></table></figure><ul><li>常规演示Test</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jedis.test;<br><br><span class="hljs-keyword">import</span> cn.itcast.jedis.util.JedisPoolUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jedis的测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 快速入门</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//2. 操作</span><br>        jedis.set(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * string 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">//存储</span><br>        jedis.set(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        <span class="hljs-comment">//获取</span><br>        String username = jedis.get(<span class="hljs-string">&quot;username&quot;</span>);<br>        System.out.println(username);<br>        <span class="hljs-comment">//可以使用setex()方法存储可以指定过期时间的 key value</span><br>        jedis.setex(<span class="hljs-string">&quot;activecode&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;hehe&quot;</span>);<span class="hljs-comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span><br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hash 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// 存储hash</span><br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;23&quot;</span>);<br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;gender&quot;</span>,<span class="hljs-string">&quot;female&quot;</span>);<br>        <span class="hljs-comment">// 获取hash</span><br>        String name = jedis.hget(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>        <span class="hljs-comment">// 获取hash的所有map中的数据</span><br>        Map&lt;String, String&gt; user = jedis.hgetAll(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">// keyset</span><br>        Set&lt;String&gt; keySet = user.keySet();<br>        <span class="hljs-keyword">for</span> (String key : keySet) &#123;<br>            <span class="hljs-comment">//获取value</span><br>            String value = user.get(key);<br>            System.out.println(key + <span class="hljs-string">&quot;:&quot;</span> + value);<br>        &#125;<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * list 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// list 存储</span><br>        jedis.lpush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-comment">//从左边存</span><br>        jedis.rpush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-comment">//从右边存</span><br>        <span class="hljs-comment">// list 范围获取</span><br>        List&lt;String&gt; mylist = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(mylist);<br>        <span class="hljs-comment">// list 弹出</span><br>        String element1 = jedis.lpop(<span class="hljs-string">&quot;mylist&quot;</span>);<span class="hljs-comment">//c</span><br>        System.out.println(element1);<br>        <br>        String element2 = jedis.rpop(<span class="hljs-string">&quot;mylist&quot;</span>);<span class="hljs-comment">//c</span><br>        System.out.println(element2);<br>        <span class="hljs-comment">// list 范围获取</span><br>        List&lt;String&gt; mylist2 = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(mylist2);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// set 存储</span><br>        jedis.sadd(<span class="hljs-string">&quot;myset&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;php&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>);<br>        <span class="hljs-comment">// set 获取</span><br>        Set&lt;String&gt; myset = jedis.smembers(<span class="hljs-string">&quot;myset&quot;</span>);<br>        System.out.println(myset);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * sortedset 数据结构操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1. 获取连接</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis();<span class="hljs-comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br>        <span class="hljs-comment">//2. 操作</span><br>        <span class="hljs-comment">// sortedset 存储</span><br>        jedis.zadd(<span class="hljs-string">&quot;mysortedset&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;亚瑟&quot;</span>);<br>        jedis.zadd(<span class="hljs-string">&quot;mysortedset&quot;</span>,<span class="hljs-number">30</span>,<span class="hljs-string">&quot;后裔&quot;</span>);<br>        jedis.zadd(<span class="hljs-string">&quot;mysortedset&quot;</span>,<span class="hljs-number">55</span>,<span class="hljs-string">&quot;孙悟空&quot;</span>);<br>        <span class="hljs-comment">// sortedset 获取</span><br>        Set&lt;String&gt; mysortedset = jedis.zrange(<span class="hljs-string">&quot;mysortedset&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        System.out.println(mysortedset);<br>        <span class="hljs-comment">//3. 关闭连接</span><br>        jedis.close();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * jedis连接池使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//0.创建一个配置对象</span><br>        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        config.setMaxTotal(<span class="hljs-number">50</span>);<br>        config.setMaxIdle(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//1.创建Jedis连接池对象</span><br>        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//2.获取连接</span><br>        Jedis jedis = jedisPool.getResource();<br>        <span class="hljs-comment">//3. 使用</span><br>        jedis.set(<span class="hljs-string">&quot;hehe&quot;</span>,<span class="hljs-string">&quot;heihei&quot;</span>);<br>        <span class="hljs-comment">//4. 关闭 归还到连接池中</span><br>        jedis.close();;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * jedis连接池工具类使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//通过连接池工具类获取</span><br>        Jedis jedis = JedisPoolUtils.getJedis();<br>        <span class="hljs-comment">//3. 使用</span><br>        jedis.set(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>        <span class="hljs-comment">//4. 关闭 归还到连接池中</span><br>        jedis.close();;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Jedis工具类抽取"><a href="#4-2-Jedis工具类抽取" class="headerlink" title="4.2 Jedis工具类抽取"></a>4.2 Jedis工具类抽取</h3><ul><li>redis.properties(配置文件)</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">host</span>=<span class="hljs-string">127.0.0.1</span><br><span class="hljs-attr">port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">maxTotal</span>=<span class="hljs-string">50</span><br><span class="hljs-attr">maxIdle</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure><ul><li>JedisPoolUtils工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> JedisPool工具类</span><br><span class="hljs-comment">    加载配置文件，配置连接池的参数</span><br><span class="hljs-comment">    提供获取连接的方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisPoolUtils</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取配置文件</span><br>        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jedis.properties&quot;</span>);<br>        <span class="hljs-comment">//创建Properties对象</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">//关联文件</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            pro.load(is);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//获取数据，设置到JedisPoolConfig中</span><br>        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        <br>config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="hljs-string">&quot;maxTotal&quot;</span>)));<br>        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="hljs-string">&quot;maxIdle&quot;</span>)));<br><br>        <span class="hljs-comment">//初始化JedisPool</span><br>        jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,pro.getProperty(<span class="hljs-string">&quot;host&quot;</span>),Integer.parseInt(pro.getProperty(<span class="hljs-string">&quot;port&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Jedis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯天美开发实习一面</title>
    <link href="/2021/03/26/%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E4%B8%80%E9%9D%A2/"/>
    <url>/2021/03/26/%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="腾讯天美实习一面"><a href="#腾讯天美实习一面" class="headerlink" title="腾讯天美实习一面"></a>腾讯天美实习一面</h1><p>自我介绍</p><p>项目介绍</p><p>你会C++么，会一些脚本语言么？</p><h2 id="1-多线程和多进程的区别？"><a href="#1-多线程和多进程的区别？" class="headerlink" title="1.多线程和多进程的区别？"></a>1.多线程和多进程的区别？</h2><p>“进程是资源分配的最小单位，线程是CPU调度的最小单位”，具体看 <a href="http://blog.csdn.net/bing_bing/article/details/8093552">http://blog.csdn.net/bing_bing/article/details/8093552</a></p><table><thead><tr><th>维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据是分开的:共享复杂，需要用IPC;同步简单</td><td>多线程共享进程数据：共享简单；同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多、切换复杂、CPU利用率低</td><td>占用内存少，切换简单，CPU利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度快</td><td>线程占优</td></tr><tr><td>编程调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会相互影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布</td><td>进程占优</td></tr></tbody></table><p>线程和进程间的比较</p><table><thead><tr><th>子进程继承父进程的属性：</th><th>子线程继承主线程的属性：</th></tr></thead><tbody><tr><td>实际用户ID，实际组ID，有效用户ID，有效组ID；附加组ID；<br/>进程组ID；<br/>会话ID；<br/>控制终端；<br/>设置用户ID标志和设置组ID标志；<br/>当前工作目录；<br/>根目录；<br/>文件模式创建屏蔽字（umask）；<br/>信号屏蔽和安排；<br/>针对任一打开文件描述符的在执行时关闭（close-on-exec）标志；<br/>环境；<br/>连接的共享存储段；<br/>存储映射；<br/>资源限制；</td><td>进程中的所有信息对该进程的所有线程都是共享的；<br/>可执行的程序文本;<br/>程序的全局内存；<br/>堆内存；<br/>栈；<br/>文件描述符；<br/>信号的处理是进程中所有线程共享的（注意：如果信号的默认处理是终止该进程那么即是把信号传给某个线程也一样会将进程杀掉）；</td></tr><tr><td>父子进程之间的区别：</td><td>子线程特有的：</td></tr><tr><td>fork的返回值(=0子进程)；<br/>进程ID不同；<br/>两个进程具有不同的父进程ID；<br/>子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime均被设置为0;<br/>不继承父进程设置的文件锁；<br/>子进程的未处理闹钟被清除；<br/>子进程的未处理信号集设置为空集；</td><td>线程ID;<br/>一组寄存器值；<br/>栈；<br/>调度优先级和策略；<br/>信号屏蔽字；<br/>errno变量；<br/>线程私有数据；</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_1.png"></p><h2 id="2-linux了解么，select、poll、epoll的区别？"><a href="#2-linux了解么，select、poll、epoll的区别？" class="headerlink" title="2.linux了解么，select、poll、epoll的区别？"></a>2.linux了解么，select、poll、epoll的区别？</h2><p><a href="https://zhuanlan.zhihu.com/p/272891398?utm_source=wechat_timeline">https://zhuanlan.zhihu.com/p/272891398?utm_source=wechat_timeline</a></p><h2 id="3-进程间如何通信的？"><a href="#3-进程间如何通信的？" class="headerlink" title="3.进程间如何通信的？"></a>3.进程间如何通信的？</h2><ul><li>管道</li><li>有名管道</li><li>消息队列</li><li>信号</li><li>信号量</li><li>共享内存</li><li>套接字socket</li></ul><h2 id="4-你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？"><a href="#4-你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？" class="headerlink" title="4.你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？"></a>4.你了解设计模式么？单例模式有哪两种实现？哪一种是线程安全的？</h2><p><font color="FF0000">饿汉是线程安全的，懒汉是线程不安全的所以需要双重检查。双重检查保证了懒汉的线程安全，但是性能会有所损耗。</font></p><h2 id="5-索引是什么？"><a href="#5-索引是什么？" class="headerlink" title="5.索引是什么？"></a>5.索引是什么？</h2><p>排好序的数据结构（InnoDB是B+Tree）</p><h2 id="6-对于事务的了解？怎么实现的-？（回答了事务的特性，实现原理）"><a href="#6-对于事务的了解？怎么实现的-？（回答了事务的特性，实现原理）" class="headerlink" title="6.对于事务的了解？怎么实现的 ？（回答了事务的特性，实现原理）"></a>6.对于事务的了解？怎么实现的 ？（回答了事务的特性，实现原理）</h2><p>ACID（原子性、一致性、隔离性、持久性）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_2.png"></p><h2 id="7-MySQL有缓存么？"><a href="#7-MySQL有缓存么？" class="headerlink" title="7.MySQL有缓存么？"></a>7.MySQL有缓存么？</h2><p>（个人看法：其实数据库查询缓存一般都用redis，mysql8.0后都被移除了，再加上我看javaguide说mysql缓冲不太实用，我就没仔细看，我回答的说这个不是不常用么，回想起来感觉有点尴尬。）</p><p>详细解析见：<a href="https://blog.csdn.net/weixin_34275734/article/details/89624537">https://blog.csdn.net/weixin_34275734/article/details/89624537</a></p><h2 id="8-缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？"><a href="#8-缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？" class="headerlink" title="8.缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？"></a>8.缓存置换算法有哪些（问的mysql，由于不知道就回答os的页面置换算法）？</h2><p>查证了以下好像是一样的FIFO，LRU，LFU</p><h2 id="9-B-Tree、红黑树、hash表的使用场景区别-？"><a href="#9-B-Tree、红黑树、hash表的使用场景区别-？" class="headerlink" title="9.B+Tree、红黑树、hash表的使用场景区别 ？"></a>9.B+Tree、红黑树、hash表的使用场景区别 ？</h2><p>B+Tree和红黑树的对比：</p><ol><li><a href="https://blog.csdn.net/zcf9916/article/details/84915506">https://blog.csdn.net/zcf9916/article/details/84915506</a></li><li><a href="https://blog.csdn.net/ljfirst/article/details/112506408">https://blog.csdn.net/ljfirst/article/details/112506408</a></li></ol><p>hash表：</p><p>区间查找可行性为0</p><p>如果数据量非常庞大，链表过长依然导致查找效率过低，且IO效率低下</p><h2 id="10-有哪些排序算法，复杂度怎么样？（原理和时间复杂度）"><a href="#10-有哪些排序算法，复杂度怎么样？（原理和时间复杂度）" class="headerlink" title="10.有哪些排序算法，复杂度怎么样？（原理和时间复杂度）"></a>10.有哪些排序算法，复杂度怎么样？（原理和时间复杂度）</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_3.png"></p><h2 id="11-你如果学习C-大概需要多少时间？"><a href="#11-你如果学习C-大概需要多少时间？" class="headerlink" title="11.你如果学习C++大概需要多少时间？"></a>11.你如果学习C++大概需要多少时间？</h2><p>额..</p><h2 id="最后一个环节：对面试官提问"><a href="#最后一个环节：对面试官提问" class="headerlink" title="最后一个环节：对面试官提问"></a>最后一个环节：对面试官提问</h2><p>你们部门有Java开发的岗位么</p><p>回答：没有，全部都是C++开发</p>]]></content>
    
    
    <categories>
      
      <category>Interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络总结</title>
    <link href="/2021/03/23/%E8%AE%A1%E7%BD%91/"/>
    <url>/2021/03/23/%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络总结"><a href="#计算机网络总结" class="headerlink" title="计算机网络总结"></a>计算机网络总结</h1><p>本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="JavaGuide面试突袭v4.0，计算机网络">[2]</span></a></sup>以及少量的补充</p><h2 id="1-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#1-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="1. OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>1. OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png"></p><h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><blockquote><p><strong>应用层</strong>：直接为用户的应用进程提供网络服务。</p></blockquote><p><strong>应用层协议</strong>： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候像应用层协议就可以规定这些数据的格式要满足什么形式。</p><p>在互联网中应用层协议很多，如</p><ul><li>域名系统<strong>DNS</strong></li></ul><blockquote><p>域名系统DNS：</p><p>是因特网的一项核心服务，他作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，不用去记住能够背极其直接读取的IP数串。</p></blockquote><ul><li>支持万维网应用的 <strong>HTTP</strong>协议</li></ul><blockquote><p>HTTP协议: </p><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p></blockquote><ul><li>支持电子邮件的 <strong>SMTP</strong>协议</li><li>文件传输 <strong>FTP</strong>等等</li></ul><p>我们把应用层交互的数据单元称为报文。</p><h4 id="1-1-2-表示层"><a href="#1-1-2-表示层" class="headerlink" title="1.1.2 表示层"></a>1.1.2 表示层</h4><blockquote><p><strong>表示层</strong>：在满足用户需求的基础上，尽可能的节省传输费用而设置的，表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。</p></blockquote><p>表示层的<strong>数据转换</strong>包括:</p><ul><li><p>数据加密</p></li><li><p>数据压缩</p></li><li><p>数据格式转换等。</p></li></ul><p>比如传输压缩文件，jpeg或者加密文件等格式。</p><h4 id="1-1-3-会话层"><a href="#1-1-3-会话层" class="headerlink" title="1.1.3 会话层"></a>1.1.3 会话层</h4><blockquote><p>会话层：<strong>管理</strong>主机之间的<strong>会话进程</strong>，即负责建立、管理、终止进程之间的会话。</p></blockquote><h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><blockquote><p><strong>运输层</strong>：为应用进程之间提供端到端的逻辑通讯。</p></blockquote><h4 id="1-2-1-运输层协议⭐"><a href="#1-2-1-运输层协议⭐" class="headerlink" title="1.2.1 运输层协议⭐"></a>1.2.1 运输层协议⭐</h4><p><font color="FF0000"><strong>运输层协议</strong></font>:  IP协议是<strong>主机之间</strong>的通信，TCP和UDP是进程之间的通信。</p><ul><li><p>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）</p><p>提供面向连接的，可靠的数据传输服务</p><ul><li>客户端和服务器之间要保持一个会话直到传输结束</li><li>分段传输建立会话可靠传输流量控制（发送窗口大小根据接收窗口大小确定）</li><li>流量控制、拥塞控制，全双工</li><li>每一条TCP连接有两个端点（套接字：IP+端口号）</li></ul></li><li><p>用户数据协议 <strong>UDP</strong>（User Datagram Protocol）</p><p>提供无连接的，尽最大努力的数据传输服务</p><ul><li>不保证数据传输的可靠性</li><li>不分段</li><li> 支持一对一，一对多，多对一通信</li></ul></li><li><p>TCP和UDP对比<a href="3.TCP/UDP 协议的区别⭐">见问题三</a></p></li></ul><h4 id="1-2-2-本层加端口号"><a href="#1-2-2-本层加端口号" class="headerlink" title="1.2.2 本层加端口号"></a>1.2.2 本层加端口号</h4><p>常见端口：</p><ul><li><p>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制；</p></li><li><p>Telnet（远程登录协议）：23；</p></li><li><p>DNS（域名解析服务）：53；</p></li><li><p>TFTP（简单文件传输协议）：69；</p></li><li><p>HTTP（超文本传输协议）：80</p></li></ul><h4 id="1-2-3-传输层进行差错检测"><a href="#1-2-3-传输层进行差错检测" class="headerlink" title="1.2.3 传输层进行差错检测"></a>1.2.3 传输层进行差错检测</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png"></p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><blockquote><p><strong>网络层</strong>（网际层/IP层）：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。(<strong>路径选择、路由及逻辑寻址</strong>)</p></blockquote><ul><li><p><strong>协议</strong>：ARP IP ICMP IGMP(ARP为IP提供服务，IP为ICMP和IGMP提供服务）</p><ul><li>由于网络层使用 <font color="FF0000"><strong>IP 协议</strong></font>，因此分组也叫 IP 数据报 ，简称<strong>数据报</strong></li><li>无论是哪一层的数据单元都可以笼统的用”分组“表示，主要不要混淆”用户数据包UDP“和网络层的”IP数据报“</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png"></p></li><li><p><strong>特点</strong>：网络层不管发的顺序也不管丢数据不（对方传输层负责），根据目标地址选择合适路径转发。</p></li><li><p><strong>本层加源IP地址与目标IP地址，构成IP数据报。</strong> <strong>IP协议非常简单，仅仅提供不可靠、无连接的传送服务</strong>。 IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p></li><li><p><font color="FF0000"><strong>路由器工作在网络层</strong></font>，在不同网段转发数据。</p></li></ul><h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><blockquote><p>数据链路层：数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 </p></blockquote><ul><li><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <strong>IP 数据报组装成帧</strong>，进行传送。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。</p></li><li><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 </p></li><li><p>封装成帧（帧头、帧尾、物理地址、校验值） 透明传输（字节填充法，传输数据出现控制字符前面插入一个转义字符） 差错校验（循环冗余检验CRC）</p></li></ul><blockquote><p><strong>数据链路层协议</strong>(了解)：</p></blockquote><ul><li><p>PPP（点到点信道） （拨号电话线接入因特网就是PPP）</p></li><li><p>CSMA/CD(带冲突检测的载波监听多路访问协议）（使用广播信道）（局域网）  </p></li><li><p>多路访问：多个设备可以同时访问介质（多个设备在同一信道发送信号协议），一个设备发送的帧也可以被多个设备接收。  </p></li><li><p>载波监听：每一个设备发送数据前，对信道侦听，空闲才可以发送，如果有其他设备正在发暂时不发避免碰撞。</p></li><li><p>碰撞检测：设备边发数据边检测信道上电压大小，一旦出现碰撞，立即停止发送，等待一段时间后再发。 这个协议只能<strong>半双工</strong>通信。</p></li></ul><blockquote><p><strong>以太网</strong>（ 全球使用最广泛的局域网技术）拓扑结构为总线型</p></blockquote><p>以太网的标准<a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91">拓扑</a>结构为<a href="https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91">总线型拓扑</a>，但目前的快速以太网为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a href="https://baike.baidu.com/item/%E6%98%9F%E5%9E%8B">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a href="https://baike.baidu.com/item/CSMA%2FCD">CSMA/CD</a>（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png"></p><blockquote><p>网桥交换机：网桥设备（可以连接集线器）</p></blockquote><p>网桥既有过滤帧的功能。当网桥收到一个帧的时候，并不是像所有接口发此帧，而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口。</p><ul><li><p>网桥口越来越多了就变成了交换机（直接连计算机）</p></li><li><p>交换机前身为网桥</p></li><li><p>交换机口可以存储转发，基于MAC地址转发，通过学习构建MAC地址表</p></li></ul><p><strong>本层加MAC地址</strong></p><h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><blockquote><p>物理层：实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p></blockquote><ul><li><p>在物理层上传送比特流</p></li><li><p>频分复用，时分复用</p></li></ul><blockquote><p>集线器：多接口转发器，工作在物理层</p></blockquote><h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>发送端：</p><ul><li><p>应用程序准备传输的文件</p></li><li><p>传输层  将文件分段 并编号</p></li><li><p>网络层  添加目标IP地址源IP地址</p></li><li><p>数据链路层  两种情况</p><p>使用自己的子网掩码 判断自己在那个网段</p><p>使用自己的子网掩码 判断目标地址在哪个网段</p><ul><li>如果是同一个网段 arp协议广播解析目标IP地址的MAC</li><li>如果不是同一个网段 则mac写网关地址</li></ul></li></ul><hr><p>一些帮助理解的解释：</p><ul><li><p>ARP发送的广播包，目标MAC是全1（48位），交换机会给所有出口转发。得到MAC地址后会缓存，过一段时间不和目标地址通信了，这个缓存会删除掉。</p></li><li><p>交换机根据mac地址转发数据</p></li><li><p>每个计算机配有网关（知道自己所在子网的路由网口地址）</p></li><li><p>点到点信道，物理层地址固定为FF（因为只能这个传给对方，不用看地址）</p></li><li><p>IP地址决定了数据的起点与终点，MAC地址决定了本点和下一跳给谁</p></li><li><p>集线器：</p><p>只负责把比特流传出去，并对信号进行加强，属于物理层设备（与网线差不多，只认比特流）</p></li><li><p>交换机（一个网段内转给其他计算机还是路由器）：</p><p>收完比特流，存储，看目标mac地址，选择出口，工作在第二层数据链路层设备，存储转发（只能看懂mac地址看不懂IP地址）</p></li><li><p>路由器：</p><p>有网卡（接口）接收比特流，可以看懂mac，判断是不是给自己，然后会把mac地址去掉，剩下IP数据报，根据数据报的目标地址按照路由表选择出口（路由器看不懂具体传的数据），出口写上新的MAC地址，为三层设备网络设备</p><p>路由器–网关–交换机三层结构：</p><p>知道IP地址，想知道具体是哪个物理PC机</p><ul><li>首先要通过IP地址的网段查找到是哪个网关的</li><li>然后在网关ARP表中查找mac地址和交换机位置</li><li>然后通过MAC表查找到物理PC机。</li><li>即IP地址-网关-MAC地址-交换机-port-PC机</li></ul><blockquote><p><strong>mac表</strong>：记录交换机接口（端口）和终端MAC的对应关系，即说明交换机哪个端口和终端的哪个MAC地址对应，指的是物理层面的连接关系，存在于交换机当中。</p><p><strong>ARP缓存表</strong>：记录主机的IP地址和MAC地址的对应关系，对于同一台PC机，IP地址是可变的，但是MAC地址是物理网卡的地址，是网卡特有的信息，是不可变的。这个缓存表一般不存在交换机里面，而是在交换机上一层的仪器中，即网关中。这个表里面只能知道IP地址和MAC的对应关系，以及在哪个交换机上连接着，并不能知道在交换机的哪个端口，需要和mac表相结合才能知道。</p><p><strong>路由表</strong>：记录路由器掌握的所有目的地网段，以及到达这些目的的最佳路径</p></blockquote></li><li><p>工作在哪一层指的最高能看懂那一层的内容</p></li><li><p>对方物理层收到比特流后，数据链路层看目标mac地址是给自己的，然后到网络层去掉mac地址剩下IP数据报，然后数据报把IP地址去掉（IP地址）给传输层，传输层排序检查丢包后给应用层</p></li></ul><hr><p>病毒是一个代码，也会分段传，路由器只能看到每一段所以中不了病毒，交换机以及集线器也不会</p><h3 id="1-7-TCP-IP协议有了解吗？"><a href="#1-7-TCP-IP协议有了解吗？" class="headerlink" title="1.7 TCP/IP协议有了解吗？"></a>1.7 TCP/IP协议有了解吗？</h3><p>TCP/IP 协议不是TCP 和IP 这两个协议的合称，而是指因特网整个TCP/IP 协议族，是一系列网络协议的总称。</p><p>TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为</p><ul><li><strong>应用层</strong></li><li><strong>传输层</strong></li><li><strong>网络层</strong></li><li><strong>链路层</strong></li></ul><h2 id="2-TCP-三次握手和四次挥手⭐"><a href="#2-TCP-三次握手和四次挥手⭐" class="headerlink" title="2. TCP 三次握手和四次挥手⭐"></a>2. TCP 三次握手和四次挥手⭐</h2><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p><h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h3><ul><li><p>第一次握手：主机A 发送syn＝1,随机产生seq=x(如1234567) 的数据包到服务器，主机B由SYN=1 知道，A 要求建立联机；</p></li><li><p>第二次握手： 主机B 收到请求后要确认联机信息， 向A 发送ack=( 主机A 的seq+1),syn=1,ack=1,随机产生seq=y(如7654321） 的包</p></li><li><p>第三次握手：主机A 收到后检查ack是否正确，即第一次发送的seq +1,以及位码ACK是否为1，若正确，主机A 会再发送ack =(主机B 的seq+1),ACK=1，主机B 收到后确认</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png"></p><p><strong>序列号</strong>：TCP缓存中字节流分数据段发，序号是这个数据段的第一个字节是整个文件的第几个字节（ 如果传输的数据字节为0，即只有首部，那序列号还增加吗？当syn 或 fin被置1，虽然报文里长度为0（应用层的数据叫报文），计算ack时我们可以认为其长度为1。其他情况（如只有ack）不增加）</p><p><strong>SYN 同步序列编号</strong>(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的<strong>握手信号</strong>。</p><p><strong>确认号ack</strong>：根据收到的数据包的最后一个字节，给信号说下一个该发哪个字节了，这个确认号就是下一个该发得字节号</p><p><strong>ACK</strong>：0确认号无效，1确认号有效</p><blockquote><p>状态变化:</p><ul><li><p>客户端: Close-&gt;SYN_SENT-&gt;ESTABLISHED</p></li><li><p>服务端: Close-&gt;Listen-&gt;SYN_RCVD-&gt;EATABLISHED</p></li></ul></blockquote><h3 id="2-2-为什么要三次握手？"><a href="#2-2-为什么要三次握手？" class="headerlink" title="2.2 为什么要三次握手？"></a>2.2 为什么要三次握手？</h3><p>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收是正常的。 <strong>核心思想</strong>：<font color="FF0000"><strong>让双方都证实对方能发收</strong></font>。</p><ul><li><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p></li><li><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p></li><li><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p></li></ul><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h3 id="2-3-两次握手可以么？"><a href="#2-3-两次握手可以么？" class="headerlink" title="2.3 两次握手可以么？"></a>2.3 两次握手可以么？</h3><p>不可以</p><blockquote><p>假如只有前面两次握手，那么服务器在接收到第一次握手信号，发出第二次握手信号后就会开始工作。</p></blockquote><ol><li>服务器角度：可能客户端发送的第一次握手请求传输过程中阻塞，客户端会再次发送一个请求，这个时候服务器先后接收到两次请求，并持续等两个客户端请求发送数据，其实只有一个，服务端却有两个响应，极端情况可能N个，会造成资源浪费。</li><li>客户端角度：假如发送建立连接的请求阻塞，过了一段时间发现没回复，然后再发一个（这次很快到达），然后给确认也很快， 就开始发数据。过了一会第一个阻塞的建立连接的请求也到了，再给一个确认给A，结果A不认了，刚已经收到确认了，就不理了，然后B就得等着传数据（没收到数据过一段就释放了），会造成资源浪费，所以需要第三个数据包的确认</li></ol><h3 id="2-4-第2次握手传回了ACK，为什么还要传回SYN？"><a href="#2-4-第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="2.4 第2次握手传回了ACK，为什么还要传回SYN？"></a>2.4 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。</p><p>而回传SYN则是为了建立并确认从服务端到客户端的通信，还要客户端确认我的发送是否正常（SYN=1了ack才为seq+1）。</p><h3 id="2-5-四次挥手"><a href="#2-5-四次挥手" class="headerlink" title="2.5 四次挥手"></a>2.5 四次挥手</h3><ul><li><p>第一次：主机A 请求断开连接 发送FIN=1 seq=u后，进入终止等待状态1， </p></li><li><p>第二次： 服务端对客户端的请求应答：ACK=1,ack=u+1,seq=v，然后服务器B 就进入关闭等待状态，此时TCP 服务器进程就通知高层应用进程，因而从A 到B 的连接就释放了。此时是“半关闭”状态。即A 不可以发送给B，但是B 可以发送给A。</p></li><li><p>第三次：此时，若B 没有数据报要发送给A 了，其应用进程就通知TCP 释放连接， 服务端请求断开连接：FIN=1，ACK=1,seq=w,ack=u+1，并等待确认。</p></li><li><p>第四次： 客户端对服务端的请求应答： ACK=1，seq=u+1，ack=w+1，A 进入时间等待，注意，此时TCP 连接还没有释放掉，然后经过时间等待计时器设置的2MSL 后，A 才进入到关闭状态。</p></li></ul><p>（FIN：finish）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png"></p><blockquote><p>状态变化：</p><p>客户端：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE</p><p>服务端：ESTABLISHED-&gt;CLOSE_WAIT-&gt; LAST_ACK-&gt;CLOSE</p></blockquote><h3 id="2-7-为什么要四次挥手？"><a href="#2-7-为什么要四次挥手？" class="headerlink" title="2.7 为什么要四次挥手？"></a>2.7 为什么要四次挥手？</h3><p>我们可以看出服务端响应断开连接的请求时，其<font color="FF0000"><strong>ACK和FIN包并不是一起发送给客户端的</strong></font>，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><h3 id="2-8-四次挥手主动方为什么需要等待2MSL"><a href="#2-8-四次挥手主动方为什么需要等待2MSL" class="headerlink" title="2.8 四次挥手主动方为什么需要等待2MSL?"></a>2.8 四次挥手主动方为什么需要等待2MSL?</h3><p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p><blockquote><p>MSL（Maximum Segment Lifetime）： </p><p>表示最大报文生存周期，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。（ 去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)=2MSL）</p></blockquote><p>Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了， 主动关闭方需要等待2MSL是为了，<font color="FF0000"><strong>防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号</strong></font>。（若重发的又没到，客户端就关闭了，server最后就会异常关闭连接，把链接错误问题报告给高层）</p><h3 id="2-9-已经建立连接，但客户端故障怎么办？"><a href="#2-9-已经建立连接，但客户端故障怎么办？" class="headerlink" title="2.9 已经建立连接，但客户端故障怎么办？"></a>2.9 已经建立连接，但客户端故障怎么办？</h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。</p><p>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是<strong>设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔<strong>75</strong>秒发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="3-TCP-UDP-协议的区别⭐"><a href="#3-TCP-UDP-协议的区别⭐" class="headerlink" title="3.TCP/UDP 协议的区别⭐"></a>3.TCP/UDP 协议的区别⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png"></p><ul><li>TCP协议进行数据通信之前需要<strong>三次握手建立连接</strong>，UDP协议不需要建立连接即可发送数据。</li><li>TCP有<strong>确认</strong>机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。<strong>传输可靠性</strong>区别</li><li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</li><li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</li></ul><blockquote><p>UDP（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播、屏幕广播、DNS、多播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p></blockquote><h3 id="3-1-一个网络数据包包括哪些有了解吗？"><a href="#3-1-一个网络数据包包括哪些有了解吗？" class="headerlink" title="3.1 一个网络数据包包括哪些有了解吗？"></a>3.1 一个网络数据包包括哪些有了解吗？</h3><p>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部（链路层）；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png"></p><h3 id="3-2-每一层的数据叫什么名字？"><a href="#3-2-每一层的数据叫什么名字？" class="headerlink" title="3.2 每一层的数据叫什么名字？"></a>3.2 每一层的数据叫什么名字？</h3><p>我们把应用层交互的数据单元称为报文</p><p>传输层：TCP叫报文段，UDP叫用户数据报</p><p>网络层：把运输层的报文段或者用户数据报封装成分组或者包，也叫IP数据报（数据报）</p><p>链路层：帧</p><p>物理层：比特流</p><h3 id="3-3-TCP协议中的数据包分片与重组功能有了解吗？"><a href="#3-3-TCP协议中的数据包分片与重组功能有了解吗？" class="headerlink" title="3.3 TCP协议中的数据包分片与重组功能有了解吗？"></a>3.3 TCP协议中的数据包分片与重组功能有了解吗？</h3><p>当TCP传输的数据包比较大时，在发送方会进行分片，在接收方进行数据包的重组。</p><ul><li><p>发送方：</p><p>将数据包分为多个<strong>TCP头部+数据包</strong>的组合，TCP头部中存着不同的<strong>数据序号</strong>；之后将多个组合交由IP模块，<strong>统一添加IP头部和MAC头部</strong>，IP头部的<strong>ID号</strong>设为统一的。</p></li><li><p>接收方：</p><p>IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在<strong>IP头部</strong>的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中<strong>具有相同ID的包</strong>全部到达。此外，IP头部还有一个<strong>分片偏移量</strong>的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。</p></li></ul><blockquote><p>链路层MTU(Maximum Transmission Unit)：每一种物理网络都会规定链路层数据帧的最大长度。IP协议在传输数据包时，若IP数据报加上数据帧头部后长度大于MTU，则将数据报文分为若干分片进行传输，并在目标系统中进行重组。</p></blockquote><blockquote><p>MSS：是TCP数据包每次能够传输的最大报文分段。</p></blockquote><h3 id="3-4-TCP粘包"><a href="#3-4-TCP粘包" class="headerlink" title="3.4 TCP粘包"></a>3.4 TCP粘包</h3><p>TCP粘包是指一种发送方发送的数据包在接收方的缓冲区中粘成了一包，也就是出现了数据包首尾相接的现象。</p><ul><li><p>产生原因：主要是发送方使用了Nagle算法，或者接收方的处理速度小于数据包的接收速度，导致接收缓冲区中消息堆积。</p></li><li><p>解决方法：可以通过关闭Nagle算法或者规定每个数据包的具体格式和长度，在接收方的应用层来进行判断</p></li></ul><p>还有UDP是不会产生粘包现象的，因为数据包之间具有明确的消息保护边界。</p><h2 id="4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）"><a href="#4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）" class="headerlink" title="4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）"></a>4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）</h2><ul><li><p><strong>确认</strong>：</p><p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储哪些已发送但是未收到确认的报文段，以便重传。</p><p>TCP默认使用<strong>累计确认</strong>，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对<strong>按序</strong>到达的最后一个分组发送确认（中间没到的可能丢了也可能阻塞还没到），这就表示到这个分组为止的所有分组都已经正确收到了。（但是不会立即发送这个确认号的数据包，因为其有可能只是阻塞了还能到，会等到这个报文段设置的重传时间到了还没收到确认就重传）</p></li><li><p><strong>重传：</strong>两种事件会导致TCP对报文段的重传：超时和冗余ACK。</p><ul><li>超时：TCP每发送一个报文段，就对这个报文段设置一次计时器，计时器设置的重传时间到期但还未收到确认，就重传。  </li><li>冗余ACK：超时触发重传的周期往往太长。TCP规定每当比期望序号更大的失序报文段到达时，就发送一个冗余ACK（再次确认某个报文段的ACK，之前已经收到过），TCP规定当发送方接收到对同一报文段的3个冗余ACK时，可以认为这个报文段已经丢失，立即执行重传，也称<strong>快速重传</strong>。</li></ul></li><li><p><strong>序列号</strong>：TCP 给 每个字节的数据都进行了编号，即序列号。 </p><p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答， 也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发（对丢包的会重传）。接收方根据编号会丢弃重复编号的数据（如超时重传中若是因为应答信号丢失，则会再传重复的数据），把有序数据传送给应用层。</p></li><li><p><strong>校验和</strong>： 目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></li></ul><blockquote><p>校验和的计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p><p>发送方：在发送数据之前计算检验和，并进行校验和的填充。 </p><p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png"></p><blockquote><p>如果接收方比对校验和与发送方不一致，数据一定传输有误。</p><p>如果接收方比对校验和与发送方一致，数据不一定传输成功。</p></blockquote><p>此外，TCP协议还通过</p><ul><li><p>流量控制</p></li><li><p>拥塞控制</p></li><li><p>ARQ协议</p></li></ul><p>保证传输的可靠性。</p><h3 id="4-1-TCP-流量控制"><a href="#4-1-TCP-流量控制" class="headerlink" title="4.1 TCP 流量控制"></a>4.1 TCP 流量控制</h3><p>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。 </p><p>TCP 利用滑动窗口实现流量控制，在三次握手阶段，双方互相将自己的<strong>数据接收缓冲池大小</strong>告诉对方。 <strong>接收方有即时窗口</strong>（滑动窗口）， 窗口大小的内容 实际上是接收端接收数据缓冲区的剩余大小，而且接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。 发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度， 如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p><h3 id="4-2-TCP-拥塞控制"><a href="#4-2-TCP-拥塞控制" class="headerlink" title="4.2 TCP 拥塞控制"></a>4.2 TCP 拥塞控制</h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><p>发送方维持一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><blockquote><p>发送窗口的上限为接收窗口和拥塞窗口中较小的一个。</p></blockquote><p><strong>拥塞控制与流量控制的区别：</strong></p><ul><li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li></ul><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></p><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1（最大一个报文段的长度），每经过一个传播轮次（即往返时间），cwnd加倍，指数型增长，一直到规定的慢开始门限，然后改用拥塞避免算法。</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1，按照线性增长。（即加法增大）。当出现一次超时（网络拥塞时）。令慢开始门限为当前cwnd的一半，cwnd重置为1，执行慢开始算法（即乘法减小）</p></li><li><p><strong>快重传与快恢复FRR：</strong></p><ul><li>快重传：使用冗余ACK来检测丢包的发生。冗余ACK也用于网络拥塞的检测（丢包当然意味着网络可能出现了拥塞）。</li><li>快恢复：收到三个冗余ACK，执行乘法减小，把慢开始门限减为当前cwnd的一半，但是cwnd不置为1，置为新的慢开始门限值（即减半），然后执行加法增大。由于跳过了cwnd从1开始的慢开始过程所以称为快恢复。</li></ul></li></ul><p><strong>小结</strong>：当发送方检测到超时的时候，采用慢开始+拥塞避免，当发送方接收到冗余ACK时，采用快重传+快恢复</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png"></p><h3 id="4-3-ARQ协议"><a href="#4-3-ARQ协议" class="headerlink" title="4.3 ARQ协议"></a>4.3 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层和传输层</strong>的错误纠正协议之一。使用了<strong>确认和超时</strong>的两个机制。</p><p>ARQ包括：</p><ul><li>停止等待ARQ协议</li><li>连续ARQ协议。</li></ul><blockquote><p>停止等待ARQ协议</p></blockquote><ul><li><p>停止等待协议：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p></li><li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p></li><li><p>优缺点：</p><ul><li>优点： 简单</li><li>缺点： 信道利用率低，等待时间长</li></ul></li><li><p>几种具体情况：</p><ul><li><p>无差错情况:</p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p></li><li><p>出现差错情况（超时重传）:</p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p></li><li><p>确认丢失和确认迟到</p><ul><li>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li><li>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul></li></ul></li></ul><blockquote><p>连续 ARQ 协议</p></blockquote><p>可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认（过一段时间确认一次，发送方其实是按照顺序发送的，可能由于网络原因，包到达的顺序不一致），而发送方每接收到一个确认，窗口就向前滑动一定距离。</p><ul><li>优缺点：<ul><li>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul></li></ul><h2 id="5-在浏览器中输入url地址-—-gt-显示主页的过程"><a href="#5-在浏览器中输入url地址-—-gt-显示主页的过程" class="headerlink" title="5. 在浏览器中输入url地址 —&gt; 显示主页的过程"></a>5. 在浏览器中输入url地址 —&gt; 显示主页的过程</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png"></p><blockquote><p>上图有一个错误，请注意，是OSPF不是OPSF。 </p><p>OSPF（Open Shortest Path Fitst）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li><p><strong>DNS解析</strong></p><blockquote><p>域名解释：<a href="http://www.baidu.com/">www.baidu.com</a>.</p></blockquote><ul><li>以最右边英文.开始，称为域名的根：注意最后一个com的后面有点这个就是根，实际用的时候最后加不加点都行</li><li>.下面这个名称就为顶级域名，代表服务器/网站的性质：<ul><li>com（商业性质） </li><li>edu（教育性质） </li><li>net（提供信息）</li><li>cn（中国） </li><li>org（组织） </li><li>gov（政府部门）</li></ul></li><li>二级域名：自己申请，比如baidu   完全限定域名：FQDN，比如<a href="http://www.baidu.com/">www.baidu.com</a>（后面的<a href="http://baidu.com/">baidu.com</a>已经全球唯一）</li><li>三级域名：<a href="http://kkk.baidu.com/">kkk.baidu.com</a>的kkk就是第三级，也可以四级五级。一般网站习惯用www，也有<a href="http://mail.baidu.com/">mail.baidu.com</a>,也可以<a href="http://wwww.baidu.com/">wwww.baidu.com</a>代表一个域名下的不同服务器，只要对应的IP配正确就可以  谷歌公司的DNS服务器0.0.0.0 电信公司的DNS服务器222.222.222.222）</li></ul><blockquote><p>客户端浏览器通过DNS解析到域名的IP地址。</p></blockquote><p>域名解析的过程：</p><ul><li><p>迭代查询：</p><p>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器向根域名服务器发送请求, 根DNS服务器，不负责具体的域名解析，但是他知道负责解析顶级域名的服务器IP（知道哪个DNS服务器负责哪一块的域名解析），会返回这个IP。本地域名服务器收到这个IP后，联系负责解析该顶级域名的服务器，这个顶级域名的服务器如果自己无法解析就找管理这个二级域名解析的服务器IP地址给本地域名服务器，然后本地域名服务器就去联系这个服务器直到解析成功为止，并把这个IP缓存到本地，供下次查询使用。</p></li><li><p>转发查询：（递归）</p><p>DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。</p><p>若有多个合适的服务器，DNS服务器可以返回一个跟用户最接近的点的IP地址给用户。（DNS负载均衡）</p></li></ul></li><li><p><strong>建立TCP连接</strong></p><p>在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，对于客户端与服务器的TCP链接，必然要说的就是三次握手。</p></li><li><p><strong>浏览器向WEB服务器发起Http请求</strong></p><p>建立TCP连接之后，发起HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（HTTP80端口）</p><ul><li><strong>传输层</strong> 把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。 </li><li><strong>网络层：</strong>添加源IP和目标IP。 </li><li><strong>链路层：</strong>客户端的链路层，发送ARP请求查找下一跳MAC，跨网段是网关的MAC</li><li>HTTP请求报文由三部分组成：<ul><li>请求行（ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD）</li><li>请求头（ HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息）</li><li>请求正文（ 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中）。</li></ul></li></ul></li><li><p><strong>服务器端处理请求并返回HTTP报文</strong></p><ul><li><p>服务器端收到请求后的由web服务器（如 Tomcat）处理请求。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p></li><li><p>HTTP响应报文也是由三部分组成: </p><ul><li>状态码（<a href="7. 常见HTTP状态码">如下述问题</a>）</li><li>响应报头</li><li>响应报文（ 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分）。</li></ul></li></ul></li><li><p><strong>浏览器解析渲染页面</strong></p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p></li></ol><ol start="6"><li><p><strong>关闭TCP链接</strong></p><p>四次挥手</p></li></ol><h2 id="6-Get和Post区别"><a href="#6-Get和Post区别" class="headerlink" title="6. Get和Post区别"></a>6. Get和Post区别</h2><ul><li><p>Get一般是从服务器上请求数据，Post一般是向服务器传送数据。</p></li><li><p>GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。 POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制。</p></li><li><p>GET请求刷新浏览器或回退时没有影响，POST回退时会重新提交数据请求。</p></li><li><p>GET 请求可被浏览器主动缓存， POST 请求不会除非手动设置  GET 请求保留在浏览器历史记录中， 可被收藏为书签； POST 请求不会保留在浏览器历史记录中，  POST 不能被收藏为书签</p></li><li><p>GET 只接受ASCII字符，  POST支持多种编码方式</p></li><li><p>GET产生一个TCP数据包， 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST产生两个TCP数据包， 浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）（ 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次）。</p></li></ul><blockquote><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议， HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</p></blockquote><h2 id="7-常见HTTP状态码"><a href="#7-常见HTTP状态码" class="headerlink" title="7. 常见HTTP状态码"></a>7. 常见HTTP状态码</h2><p>1xx：表示通知信息，例如表示收到或者是正在处理（临时响应）</p><p>2xx：表示成功，例如表示接受或知道了</p><p>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动</p><p>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成</p><p>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p><h2 id="8-HTTP协议和各种协议的关系"><a href="#8-HTTP协议和各种协议的关系" class="headerlink" title="8. HTTP协议和各种协议的关系"></a>8. HTTP协议和各种协议的关系</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png"></p><h2 id="9-HTTP长连接-短连接"><a href="#9-HTTP长连接-短连接" class="headerlink" title="9. HTTP长连接,短连接"></a>9. HTTP长连接,短连接</h2><p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/gotodsp/p/6366163.html">[3]</span></a></sup></p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><blockquote><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p></blockquote><p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损。 </p><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p><ul><li><p>使用场景：</p><ul><li><strong>短链接</strong>：像WEB网站的http服务一般都用短链接</li></ul><p>原因：长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><ul><li><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li></ul></li></ul><h2 id="10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）"><a href="#10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）" class="headerlink" title="10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）"></a>10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）</h2><p>HTTP 是一种不保存状态，即无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。 </p><p>我们可以使用cookie和session来保持会话状态，</p><ul><li><p>会话：一次会话中包含多次请求和响应</p></li><li><p>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</p></li></ul><blockquote><p>cookie和session功能就是在一次会话的范围内的多次请求间，共享数据。</p></blockquote><ul><li><p>客户端会话技术：Cookie，将数据保存到客户端浏览器（cookie一般用于存出少量的不太敏感的数据或是在不登录的情况下，完成服务器对客户端的身份识别）；</p></li><li><p>服务器端会话技术：Session，将数据保存在服务器端的对象中，Session的实现是依赖于Cookie的。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。这样做有一个缺点就是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。</p></li></ul><p>实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</p><blockquote><p>Cookie 被禁用怎么办?</p></blockquote><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p><p>参考回答：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png"></p><h2 id="11-Cookie的作用是什么-和Session有什么区别？"><a href="#11-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="11. Cookie的作用是什么?和Session有什么区别？"></a>11. Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Session没有数据大小限制，Cookie有。</p><p>相对 Cookie 来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="12-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#12-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="12. HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>12. HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><ol><li>在HTTP/1.0中，默认使用的是短连接，HTTP 1.1起，默认使用长连接。 </li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h2 id="13-URI和URL的区别是什么"><a href="#13-URI和URL的区别是什么" class="headerlink" title="13. URI和URL的区别是什么?"></a>13. URI和URL的区别是什么?</h2><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URI就是在某一规则下能把一个资源独一无二地标识出来。如：身份证</li><li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL就是用定位的方式实现的URI。 可认为由4部分组成：协议、主机、端口、路径   http:localhost:8080/index.jsp ( 对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息)  如：具体住址</li></ul><p>​    URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="14-HTTP-和-HTTPS-的区别？"><a href="#14-HTTP-和-HTTPS-的区别？" class="headerlink" title="14. HTTP 和 HTTPS 的区别？"></a>14. HTTP 和 HTTPS 的区别？</h2><ol><li>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li><li>安全性和资源消耗： <ul><li>HTTP协议运行在TCP之上，所有传输的内容都是明文。  </li><li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。（ HTTPS协议在HTTP的基础上加入了SSL（安全套接字层）协议，SSL逐渐演变为了TLS协议，但是业界习惯仍然称其为SSL协议。）所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li></ul></li></ol><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>JavaGuide面试突袭v4.0，计算机网络<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">https://www.cnblogs.com/gotodsp/p/6366163.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>CS</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPs</tag>
      
      <tag>TCP</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BIO_AIO_NIO区别</title>
    <link href="/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="BIO-AIO-NIO区别"><a href="#BIO-AIO-NIO区别" class="headerlink" title="BIO_AIO_NIO区别"></a>BIO_AIO_NIO区别</h1><blockquote><p>简单对比：</p><ul><li>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题的关键其实就是理解同步/异步、阻塞/非阻塞的含义。</p><p>最初我看了很多blog以及一些所谓的面试考题讲解视频，以为理解了同步/异步、阻塞/非阻塞的含义，但其实越想越经不起推敲</p><p>比如下面的一些理解（我认为是不对的）：</p><blockquote><p><del>同步和异步（针对请求），阻塞和非阻塞（针对客户端）</del></p><p><del>在网络请求中，客户端会发出一个请求到服务端</del></p><ol><li><del>客户端发了请求后，就一直等着服务端的返回相应。 客户端：阻塞。 请求：同步</del></li><li><del>客户端发了请求后，就去干别的事情了，时不时来检查服务端是否给出了响应。 客户端：非阻塞。 请求： 同步。</del></li><li><del>换成异步请求后，客户端发出请求后，就坐在椅子上，等着服务端的返回相应。 客户端：阻塞。 请求：异步。</del></li><li><del>客户端发出请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。 客户端：阻塞。 请求：异步。</del></li></ol></blockquote><p>像这样举通俗的例子来说明这几个概念，通常都经不起推敲，原因在于，例子中缺少了一个“操作系统”级别的调度者。</p><ul><li><p>阻塞非阻塞是跟进程/线程严密相关的，而进程/线程又是依赖于操作系统存在的，所以自然不能脱离操作系统来讨论阻塞非阻塞。</p></li><li><p>同步/异步也是跟任务流相关的，所以举例子必须考虑到并发的任务流，不然，肯定很难举出恰当的例子的。</p></li></ul><p>本文的讨论：</p><ul><li><p>限定Linux环境下的network IO作为背景来讨论同步/异步、阻塞/非阻塞的理解。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=" UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/historyasamirror/article/details/5778378">[2]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/112810033">[4]</span></a></sup></p></li><li><p>讨论Java中对应的编程模型</p></li><li><p>对比BIO/NIO的区别<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/83597838">[3]</span></a></sup></p></li></ul><h2 id="1-Linux下的五种I-O模型"><a href="#1-Linux下的五种I-O模型" class="headerlink" title="1.  Linux下的五种I/O模型"></a>1.  Linux下的五种I/O模型</h2><p>Stevens在文章中一共比较了五种IO Model：</p><ul><li>blocking IO</li><li>nonblocking IO</li><li>IO multiplexing</li><li>signal driven IO</li><li>asynchronous IO</li></ul><p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p><blockquote><p>IO发生时涉及的对象和步骤:</p><ul><li>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象:<ul><li>一个是调用这个IO的process (or thread)</li><li>另一个就是系统内核(kernel)</li></ul></li><li>当一个read操作发生时，它会经历两个阶段：<br>   1 等待数据准备 (Waiting for the data to be ready)<br>   2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li><li>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</li></ul></blockquote><h3 id="1-1-阻塞I-O（blocking-I-O）"><a href="#1-1-阻塞I-O（blocking-I-O）" class="headerlink" title="1.1 阻塞I/O（blocking I/O）"></a>1.1 阻塞I/O（blocking I/O）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png"></p><ul><li><p>第一阶段：准备数据</p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。</p></li><li><p>第二阶段：数据拷贝</p><p>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p></li></ul><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。以下是java实现的服务器bio代码（需要掌握），注意阻塞方法阻塞的第一个阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BIO阻塞代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTcpSocket</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建一个ServerSocket连接</span><br>            <span class="hljs-keyword">final</span> ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>            <span class="hljs-comment">// 2.绑定端口号</span><br>            serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 3.当前线程放弃cpu资源等待获取数据</span><br>            System.out.println(<span class="hljs-string">&quot;等待获取数据...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept(); <span class="hljs-comment">// 阻塞方法</span><br>                executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            System.out.println(<span class="hljs-string">&quot;获取到数据...&quot;</span>);<br>                            <span class="hljs-comment">// 4.读取数据</span><br>                            <span class="hljs-keyword">int</span> read = socket.getInputStream().read(bytes); <span class="hljs-comment">// 会阻塞</span><br>                            String result = <span class="hljs-keyword">new</span> String(bytes);<br>                            System.out.println(result);<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                        &#125;<br>                    &#125;<br>                &#125;);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用程序</strong>想要读取数据就会调用<code>recvfrom</code>,而<code>recvfrom</code>会通知OS来执行，OS就会判断<strong>数据报是否准备好</strong>(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会<strong>将数据从内核空间拷贝到用户空间</strong>(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后<code>socket.read()</code>就会解除阻塞，并得到read的结果。</p><h3 id="1-2-非阻塞（Non-Blocking-IO）"><a href="#1-2-非阻塞（Non-Blocking-IO）" class="headerlink" title="1.2 非阻塞（Non-Blocking IO）"></a>1.2 非阻塞（Non-Blocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png"></p><ul><li><p>第一阶段：准备数据</p><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p></li><li><p>第二阶段：数据拷贝</p><p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p></li></ul><p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。一定要注意这个地方，<strong>Non-Blocking还是会阻塞的</strong>。</p><p>以下是java实现的服务器bio代码（需要掌握），注意数据准备阶段是非阻塞方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NIO非阻塞式代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerNioTcpSocket</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建一个ServerSocketChannel连接</span><br>            <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">// 2.绑定端口号</span><br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 设置为非阻塞式</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 非阻塞式</span><br>            SocketChannel socketChannel = serverSocketChannel.accept(); <br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> j = socketChannel.read(byteBuffer);  <span class="hljs-comment">// 此处不会阻塞</span><br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">byte</span>[] bytes = Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());<br>                    System.out.println(<span class="hljs-string">&quot;获取到数据&quot;</span> + <span class="hljs-keyword">new</span> String(bytes));<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;程序执行完毕..&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NIO中提供了集中Channel：<code>ServerSocketChannel；SocketChannel；FileChannel；</code> <code>DatagramChannel</code>只有<code>FileChannel</code>无法设置成非阻塞模式，其他Channel都可以设置为非阻塞模式。</p><p>当设置为非阻塞后，我们的<code>socket.read()</code>方法就会立即得到一个返回结果(成功 or 失败)，我们可以根据返回结果执行不同的逻辑，比如在失败时，我们可以做一些其他的事情。但事实上这种方式也是低效的，因为我们不得不使用轮询方法区一直问OS：“我的数据好了没啊”。第一个代码是该线程不断的轮询，第二个代码是使用selector实现轮询等待有效请求。</p><p>NIO 不会在<code>recvfrom</code>也就是<code>socket.read()</code>时候阻塞，但是还是会在<strong>将数据从内核空间拷贝到用户空间</strong>阻塞。</p><h3 id="1-3-I-O复用-IO-multiplexing"><a href="#1-3-I-O复用-IO-multiplexing" class="headerlink" title="1.3 I/O复用 IO multiplexing"></a>1.3 I/O复用 IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。</p><p>有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p><p>它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png"></p><p>这里用java的NIO示意select</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>); <br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待事件发生...&quot;</span>);<br>            <span class="hljs-comment">// 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br>            <span class="hljs-keyword">int</span> select = selector.select(); <br><br>            System.out.println(<span class="hljs-string">&quot;事件发生了...&quot;</span>);<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectionKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                <span class="hljs-comment">// 删除本次已处理的key， 防止下次select重复处理</span><br>                it.remove();<br>                handle(key);<br>            &#125;      <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了...&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">// 处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 通过Selector监听Channel时对读事件感兴趣</span><br>            sc.register(selector, SelectionKey.OP_READ); <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了...&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据:&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br>            ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes());<br>            sc.write(bufferToWrite);<br>            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable) &#123;<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            System.out.println(<span class="hljs-string">&quot;write事件...&quot;</span>);<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br>            <span class="hljs-comment">// 在有数据往外写的时候在注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">// sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><blockquote><p>多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p></blockquote><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h3 id="1-4-异步I-O-Asynchronous-IO"><a href="#1-4-异步I-O-Asynchronous-IO" class="headerlink" title="1.4 异步I/O(Asynchronous IO)"></a>1.4 异步I/O(Asynchronous IO)</h3><p>linux下的asynchronous IO其实用得很少(所以这里就不贴AIO的java代码了，一般不要求掌握）。先看一下它的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。</p><p>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。</p><h3 id="1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解"><a href="#1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解" class="headerlink" title="1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解"></a>1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解</h3><p>其实是POSIX的定义是这样子的：</p><ul><li><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p></li><li><p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></li></ul><p>核心区别是：synchronous IO做”IO operation”的时候会将process阻塞</p><ol><li><p>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p></li><li><p>而asynchronous IO,当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p></li></ol><blockquote><p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png"></p><p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h3 id="1-6-select，poll，epoll区别"><a href="#1-6-select，poll，epoll区别" class="headerlink" title="1.6 select，poll，epoll区别"></a>1.6 select，poll，epoll区别</h3><p>他们是NIO中多路复用的三种实用机制（底层是三个C++的API），是由Linux操作系统提供的。</p><p>Unix，Linux操作系统的一些基本知识：</p><ul><li><p>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间</p></li><li><p>文件描述符File Descriptor（FD）：是一个抽象概念，形式上是一个整数，实际上是一个索引值。指向内核中为每一个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD。</p></li></ul><blockquote><p>select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。（fd_set是一个数组结构，拷贝大小受限制 x64最大2048）</p><p>poll机制：和select机制差不多的。将fd_set结构进行了优化，FD集合大小突破了操作系统限制。（pollfd结构来代替fd_set，通过链表实现的）</p><p>Epoll机制：Event Poll不在扫描所有的FD，只将用户关心的FD的事件存放到内核的一个事件表当中。可以减少用户空间与内核空间之间需要拷贝的数据。</p></blockquote><table><thead><tr><th></th><th>操作方式</th><th>底层实现</th><th>最大连接数</th><th>IO效率</th></tr></thead><tbody><tr><td>select（1984）</td><td>遍历</td><td>数组</td><td>受限于内核</td><td>一般</td></tr><tr><td>poll（1997）</td><td>遍历</td><td>链表</td><td>无上限</td><td>一般</td></tr><tr><td>epoll（2002）</td><td>事件回调</td><td>红黑树</td><td>无上限</td><td>高</td></tr></tbody></table><p>Java NIO当中是使用哪一种机制？</p><p>基于内核版本，可以查看DefaultSelectorProvider源码：</p><ul><li><p>windows下，WindowsSelectorProvider。</p></li><li><p>Linux下，内核2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。</p></li></ul><h2 id="2-Java的IO编程模型"><a href="#2-Java的IO编程模型" class="headerlink" title="2. Java的IO编程模型"></a>2. Java的IO编程模型</h2><blockquote><p>BIO 同步阻塞IO。 可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。</p><p>编程模型最简单。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复习黑马文件上传的服务端BIO代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动..... &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept(); <span class="hljs-comment">// 阻塞方法</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">            Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() ‐&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() +<br>                    <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != ‐<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果不活跃的连接逐渐增多，线程池里的线程慢慢的也都开始阻塞等待IO，线程池里真正在运行的线程数会越来越少，当线程池处理不过来时，会放置到线程池配置的BlockingQueue中，队列塞满后，慢慢的线程池中线程的数目会逐渐达到线程池配置的maximumPoolSize，如果再处理不过来，执行拒绝策略。也就是说，<code>最终会导致请求无法及时处理。</code></p><p>这样带来的问题是，假设有线程池corePoolSize设置为100，只要有100个不活跃的连接正在阻塞读写IO，就会把前corePoolSize线程都阻塞住，后续的请求就无法及时处理。</p><blockquote><p>NIO 同步非阻塞IO。 可靠性比较好，吞吐量也比较高，适用于连接比较多且连接比较短（轻操作）。例如聊天室。JDK1.4开始支持。（应用最广）</p><p>编程模型最复杂。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png"></p><p>NIO非阻塞体现:</p><ul><li>accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</li><li>首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</li></ul><p>(我的一些看法，java的NIO就是Linux中IO复用和NIO两个模型的结合)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>); <br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待事件发生...&quot;</span>);<br>            <span class="hljs-comment">// 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br>            <span class="hljs-keyword">int</span> select = selector.select(); <br><br>            System.out.println(<span class="hljs-string">&quot;事件发生了...&quot;</span>);<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectionKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                <span class="hljs-comment">// 删除本次已处理的key， 防止下次select重复处理</span><br>                it.remove();<br>                handle(key);<br>            &#125;      <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了...&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">// 处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 通过Selector监听Channel时对读事件感兴趣</span><br>            sc.register(selector, SelectionKey.OP_READ); <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了...&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据:&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br>            ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes());<br>            sc.write(bufferToWrite);<br>            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable) &#123;<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            System.out.println(<span class="hljs-string">&quot;write事件...&quot;</span>);<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br>            <span class="hljs-comment">// 在有数据往外写的时候在注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">// sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AIO 异步非阻塞IO。解决了服务端需要一直守着线程的问题，可靠性是最好的，吞吐量也是非常高的，适用于连接比较多且比较长（重操作）。 例如相册服务器。 JDK7开始支持。</p><p>编程模型比较简单，但需要操作系统来支持异步服务。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码(了解)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open().bind(<span class="hljs-keyword">new</span> InewSocketAddress(<span class="hljs-number">9000</span>));<br>        <br>        serverChannel.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHander&lt;AsynchronousServerSocketChannel, Object&gt;())&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(AsynchronousServerSocketChannel socketChannel, Object attachment)</span></span>&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-comment">// 再次接受客户端连接，如果不写这一行代码后面的客户端连接不上服务器端</span><br>                    serverChannel.accept(attachment, <span class="hljs-keyword">this</span>);<br>                    System.out.println(socketChannel.getRemoteAddress());<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    socketChannel.read(buffer, buffer, <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer buffer)</span></span>&#123;<br>                            buffer.flip();<br>                            System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, result));<br>                            socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes()));<br>                        &#125;<br>                        <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;exc.printStackTrace();&#125;<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;exc.printStackTrace();&#125;<br>        &#125;);<br>        <br>        Thread.sleep(Integer.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-BIO-NIO区别"><a href="#3-BIO-NIO区别" class="headerlink" title="3. BIO/NIO区别"></a>3. BIO/NIO区别</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png"></p><h2 id="4-BIO、NIO、AIO适用场景"><a href="#4-BIO、NIO、AIO适用场景" class="headerlink" title="4. BIO、NIO、AIO适用场景"></a>4. BIO、NIO、AIO适用场景</h2><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><h2 id="5-Java-NIO的3个核心组件"><a href="#5-Java-NIO的3个核心组件" class="headerlink" title="5. Java NIO的3个核心组件"></a>5. Java NIO的3个核心组件</h2><blockquote><p>NIO重点:</p><p>Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><blockquote><p>简单解释：</p></blockquote><ul><li><p>每一个channel对应一个buffer缓冲区。</p></li><li><p>channel会注册到selector。</p></li><li><p>selector会根据channel上发生的读写事件，将请求交由某一个空闲线程处理。</p></li><li><p>selector对应一个或者多个线程。</p></li><li><p>buffer和channel都是可读可写的。</p></li></ul><h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p><p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p><ul><li>ByteBuffer：字节缓冲区</li><li>CharBuffer:字符缓冲区</li><li>ShortBuffer：短整型缓冲区</li><li>IntBuffer：整型缓冲区</li><li>LongBuffer:长整型缓冲区</li><li>FloatBuffer：浮点型缓冲区</li><li>DoubleBuffer：双精度浮点型缓冲区</li></ul><h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p><p>Channel有四种实现：</p><ul><li>FileChannel:是从文件中读取数据。</li><li>DatagramChannel:从UDP网络中读取或者写入数据。</li><li>SocketChannel:从TCP网络中读取或者写入数据。</li><li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li></ul><h3 id="5-3-多路复用器Selector"><a href="#5-3-多路复用器Selector" class="headerlink" title="5.3 多路复用器Selector"></a>5.3 多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p><p><strong>关键对象</strong></p><ul><li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li><li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li></ul><p><strong>监听注册</strong></p><p>监听注册在Selector</p><blockquote><p>socketChannel.register(selector, SelectionKey.OP_READ);</p></blockquote><p><strong>监听的事件有</strong></p><ul><li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li><li>OP_READ: 读取就绪，socketChannel使用</li><li>OP_WRITE: 写入就绪，socketChannel使用</li><li>OP_CONNECT: 连接就绪，socketChannel使用</li></ul><h3 id="5-4-NIO的一些应用和框架"><a href="#5-4-NIO的一些应用和框架" class="headerlink" title="5.4 NIO的一些应用和框架"></a>5.4 NIO的一些应用和框架</h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p><p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/83597838">https://zhuanlan.zhihu.com/p/83597838</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/112810033">https://zhuanlan.zhihu.com/p/112810033</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL并发时经典的死锁及解决方法</title>
    <link href="/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL并发时经典的死锁及解决方法"><a href="#MySQL并发时经典的死锁及解决方法" class="headerlink" title="MySQL并发时经典的死锁及解决方法"></a>MySQL并发时经典的死锁及解决方法</h1><h2 id="1-MySQL都有锁分类"><a href="#1-MySQL都有锁分类" class="headerlink" title="1. MySQL都有锁分类"></a>1. MySQL都有锁分类</h2><blockquote><p>MySQL有三种锁的级别：页级、表级、行级。</p></blockquote><ul><li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></li><li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p></li><li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></li></ul><blockquote><p>算法</p></blockquote><ul><li><p>Next-KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap   </p></li><li><p>Gap锁，不锁记录，仅仅记录前面的Gap</p></li><li><p>Recordlock锁（锁数据，不锁Gap）</p></li></ul><p>总结：所以其实 Next-KeyLocks = Gap锁 + Recordlock锁</p><h2 id="2-什么情况下会造成死锁"><a href="#2-什么情况下会造成死锁" class="headerlink" title="2. 什么情况下会造成死锁"></a>2. 什么情况下会造成死锁</h2><blockquote><p>所谓死锁<DeadLock>: </p><p>是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p></blockquote><p>死锁的关键在于：<strong>两个(或以上)的Session加锁的顺序不一致</strong>。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p><h2 id="3-一些常见的死锁案例"><a href="#3-一些常见的死锁案例" class="headerlink" title="3.  一些常见的死锁案例"></a>3.  一些常见的死锁案例</h2><h3 id="3-1-案例一"><a href="#3-1-案例一" class="headerlink" title="3.1 案例一"></a>3.1 案例一</h3><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>抽象出来就是一个session通过for循环会有几条如下的语句：</p><p>Select * from xxx where id=’随机id’ for update</p><p>基本来说，程序开启后不一会就死锁。</p><p>这可以是说最经典的死锁情形了。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p><strong>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Select * from xxx where id in (xx,xx,xx) for update<br></code></pre></td></tr></table></figure><p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs mysql">例如（以下会话id为主键）：<br><br>Session1:<br><br>mysql&gt; select * from t3 where id in (8,9) for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>|  8 | WA     | f    | 2016-03-02 11:36:30 |<br><br>|  9 | JX     | f    | 2016-03-01 11:36:30 |<br><br>+----+--------+------+---------------------+<br><br>2 rows in set (0.04 sec)<br><br> <br><br> <br><br>Session2:<br><br>select * from t3 where id in (10,8,5) for update;<br><br>锁等待中……<br><br>其实这个时候id&#x3D;10这条记录没有被锁住的，但id&#x3D;5的记录已经被锁住了，锁的等待在id&#x3D;8的这里。<br><br> <br><br>不信请看<br><br>Session3:<br><br>mysql&gt; select * from t3 where id&#x3D;5 for update;<br><br>锁等待中<br><br> <br><br>Session4:<br><br>mysql&gt; select * from t3 where id&#x3D;10 for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>| 10 | JB     | g    | 2016-03-10 11:45:05 |<br><br>+----+--------+------+---------------------+<br><br>1 row in set (0.00 sec)<br><br> <br><br>在其它session中id&#x3D;5是加不了锁的，但是id&#x3D;10是可以加上锁的。<br></code></pre></td></tr></table></figure><h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">以id为主键为例，目前还没有id&#x3D;22的行<br><br>Session1:<br><br>select * from t3 where id&#x3D;22 for update;<br><br>Empty set (0.00 sec)<br><br> <br><br>session2:<br><br>select * from t3 where id&#x3D;23  for update;<br><br>Empty set (0.00 sec)<br><br> <br><br>Session1:<br><br>insert into t3 values(22,&#39;ac&#39;,&#39;a&#39;,now());<br><br>锁等待中……<br><br> <br><br>Session2:<br><br>insert into t3 values(23,&#39;bc&#39;,&#39;b&#39;,now());<br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br></code></pre></td></tr></table></figure><p>当对<font color="FF0000">存在的行</font>进行锁的时候(主键)，mysql就只有行锁。</p><p>当对<font color="FF0000">未存在的行</font>进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有Gap锁）</p><blockquote><p>锁住的范围为：</p><p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p></blockquote><p>如：如果表中目前有已有的id为（11 ， 12）</p><p>那么就锁住（12，无穷大）</p><p>如果表中目前已有的id为（11 ， 30）</p><p>那么就锁住（11，30）</p><p><strong>对于这种死锁的解决办法是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t3(xx,xx) on duplicate key update xx&#x3D;&#39;XX&#39;;<br></code></pre></td></tr></table></figure><p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p><h3 id="3-3-案例三"><a href="#3-3-案例三" class="headerlink" title="3.3 案例三"></a>3.3 案例三</h3><p>直接上情景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t3 where id&#x3D;9 for update;<br><br>+----+--------+------+---------------------+<br><br>| id | course | name | ctime               |<br><br>+----+--------+------+---------------------+<br><br>|  9 | JX     | f    | 2016-03-01 11:36:30 |<br><br>+----+--------+------+---------------------+<br><br>1 row in set (0.00 sec)<br><br> <br><br>Session2:<br><br>mysql&gt; select * from t3 where id&lt;20 for update;<br><br>锁等待中<br><br> <br><br>Session1:<br><br>mysql&gt; insert into t3 values(7,&#39;ae&#39;,&#39;a&#39;,now());<br><br>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br></code></pre></td></tr></table></figure><p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p><p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p><p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/zejin2008/p/5262751.html%E8%BD%AC%E8%BD%BD%E8%AF%A5%E6%96%87">https://www.cnblogs.com/zejin2008/p/5262751.html转载该文</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 断点调试技巧</title>
    <link href="/2021/03/15/IDEA%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <url>/2021/03/15/IDEA%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA-断点调试技巧"><a href="#IDEA-断点调试技巧" class="headerlink" title="IDEA 断点调试技巧"></a>IDEA 断点调试技巧</h1><p>简单记录一下IDEA最常用到的debug方式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV1ur4y1P7SV?">[1]</span></a></sup></p><h1 id="1-行断点"><a href="#1-行断点" class="headerlink" title="1. 行断点"></a>1. 行断点</h1><p>普通在左侧打的断点就是行断点</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><h1 id="2-详细断点-源断点"><a href="#2-详细断点-源断点" class="headerlink" title="2. 详细断点 | 源断点"></a>2. 详细断点 | 源断点</h1><p>按住<code>shift</code>键加上鼠标点击代码左侧出现下图</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li><p>如果我们只勾选Enabled，再点击右下角done，则调试效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li>我们可以看到该断点并没有挂起，只是打出断点所触发的位置（具体的类及所在方法）</li></ul></li><li><p>勾选Suspend（挂起）和All，再点击右done，实际就是打了普通行断点，全部线程都会停止</p></li><li><p>勾选Suspend（挂起）和Thread，再点击done，只有<strong>当前线程才会在该断点停止</strong></p></li><li><p>condition中可以添加一些if else条件判断，但触发条件才会停止（高阶用法）</p></li></ul><h1 id="3-方法断点-接口跳转实现类"><a href="#3-方法断点-接口跳转实现类" class="headerlink" title="3. 方法断点 | 接口跳转实现类"></a>3. 方法断点 | 接口跳转实现类</h1><ul><li><p>方法断点既在方法左侧打的断点，如下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E8%A1%8C%E6%96%AD%E7%82%B9.png"></p><ul><li><p>我们可以发现，该断点在进入方法第一句和方法返回的最后一句都会停止</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B92.png"></p></li></ul></li></ul><ul><li><p>如果是在接口的方法打方法断点，则会跳转到相应的实现类的方法第一句和返回出停止</p><ul><li>因此当我们不知道具体是哪一个实现类时可以直接在接口打方法断点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B93.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B94.png"></p></li></ul><h1 id="4-异常断点-全局捕获"><a href="#4-异常断点-全局捕获" class="headerlink" title="4. 异常断点 | 全局捕获"></a>4. 异常断点 | 全局捕获</h1><p>点击左下的断点图标如图</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9.png"></p><p>则会显示这么一个界面</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B92.png"></p><p>先选中Exception Breakpoints，在点左上加号添加</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B93.png"></p><p>再选中第三项</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B94.png"></p><p>那么可以再弹出窗口搜索你想要全局捕获的异常断点，也可以搜索你自己定义的异常</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B95.png"></p><p>最后添加并点击done确认</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B96.png"></p><p>那么在debug时就能捕获到异常并停下</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B97.png"></p><h1 id="5-字段断点-读写监控"><a href="#5-字段断点-读写监控" class="headerlink" title="5. 字段断点 | 读写监控"></a>5. 字段断点 | 读写监控</h1><p>在类的成员变量左侧打断点</p><p>可以监控这个成员整个生命周期值的变化</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_%E5%AD%97%E6%AE%B5%E6%96%AD%E7%82%B9.png"></p><p>下面我们看看debug的效果</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_%E5%AD%97%E6%AE%B5%E6%96%AD%E7%82%B92.png"></p><p>我们可以看到在字段断点在监控的某一个字段某一个属性值一旦发生写的操作，改变了它的值就会触发停顿。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1ur4y1P7SV">https://www.bilibili.com/video/BV1ur4y1P7SV</a>?<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>IDE</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级</title>
    <link href="/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p>基于<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">MySQL高级</a>的学习笔记<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV12b411K7Zu?p=179">[2]</span></a></sup></p><blockquote><p>内容说明：</p><p>MySQL 是目前最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 也是目前最好的 RDBMS 应用软件之一。随着淘宝去IOE(去除IBM小型机、Oracle数据库及EMC存储设备)化的推进，MySQL 数据库在当前的互联网应用中变得越来越重要。</p><p>包括的MySQL 高级知识：索引，如何避免索引失效，索引优化策略，innodb和myisam存储引擎，MySQL锁机制，配置MySQL主从复制，explain、show profile、慢查询日志等日常SQL诊断和性能分析策略。</p></blockquote><h2 id="1-MySQL的架构介绍"><a href="#1-MySQL的架构介绍" class="headerlink" title="1.MySQL的架构介绍"></a>1.MySQL的架构介绍</h2><h3 id="1-1-MySQL简介"><a href="#1-1-MySQL简介" class="headerlink" title="1.1 MySQL简介"></a>1.1 MySQL简介</h3><ul><li><p>概述：关系型数据库管理系统RDBMS</p></li><li><p>高级MySQL：完整的mysql优化需要很深的功底，大公司有专门的DBA</p><ul><li><p>数据库内部结构和原理</p></li><li><p>数据库建模优化</p></li><li><p>数据库索引建立</p></li><li><p>SQL语句优化</p></li><li><p>SQL编程</p></li><li><p>mysql服务器安装配置</p></li><li><p>数据库的性能监控分析与系统优化</p></li><li><p>各种参数常量设定</p></li><li><p>主从复制</p></li><li><p>分布式架构搭建、垂直切割和水平切割</p></li><li><p>数据迁移</p></li><li><p>容灾备份和恢复</p></li><li><p>shell或python等脚本语言开发</p></li><li><p>对开源数据库进行二次开发</p></li></ul></li></ul><h3 id="1-2-MysqlLinux版的安装（mysql5-5）"><a href="#1-2-MysqlLinux版的安装（mysql5-5）" class="headerlink" title="1.2 MysqlLinux版的安装（mysql5.5）"></a>1.2 MysqlLinux版的安装（mysql5.5）</h3><ul><li>下载地址：</li></ul><p>官网下载地址：<a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a>     </p><ul><li><p>拷贝&amp;解压缩</p></li><li><p>检查工作</p><ul><li><p>检查是否安装过mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 执行安装命令前，先执行查询命令</span><br>rpm -qa|grep mysql<br><span class="hljs-meta">#</span><span class="bash"> 如果存在mysql-libs的旧版本包如下：请先执行卸载命令</span><br>rpm -e --nodeps  mysql-libs  <br></code></pre></td></tr></table></figure></li><li><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -R 777 /tmp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在mysql的安装文件目录下执行：</span><br>rpm -ivh MySQL-server-5.5.54-1.linux2.6.x86_64.rpmrpm -ivh MySQL-client-5.5.54-1.linux2.6.x86_64.rpm <br></code></pre></td></tr></table></figure></li></ul><ul><li><p>查看MySQL安装版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqladmin --version<br></code></pre></td></tr></table></figure></li><li><p>mysql服务的启+停</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start<br>ps -ef|grep mysql # 查看服务是否开启<br>service mysql stop<br></code></pre></td></tr></table></figure></li><li><p>首次登陆</p><p>安装完成后会提示出如下的提示：在mysql首次登录前要给 root 账号设置密码 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动服务后，执行命令</span> <br>/usr/bin/mysqladmin -u root  password &#x27;123123&#x27;<br><span class="hljs-meta">#</span><span class="bash"> 登录</span> <br>mysql -uroot -p123123  <br></code></pre></td></tr></table></figure></li><li><p>自启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chkconfig mysql on # 设置开机自启动<br>chkconfig --list | grep mysql<br>ntsysv # 看到[*]mysql这一行，表示开机后会自启动mysql<br></code></pre></td></tr></table></figure></li><li><p>mysql的安装位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef|grep mysql # 在linux下查看安装目录<br></code></pre></td></tr></table></figure><p> 参数路径解释备注</p><ul><li><p>basedir:  /usr/bin 相关命令目录mysqladmin mysqldump等命令</p></li><li><p>datadir: /var/lib/mysql/ mysql数据库文件的存放路径 </p></li><li><p>plugin-dir: /usr/lib64/mysql/pluginmysql插件存放路径</p></li><li><p>log-error: /var/lib/mysql/jack.atguigu.errmysql错误日志路径</p></li><li><p>pid-file: /var/lib/mysql/jack.atguigu.pid进程pid文件</p></li><li><p>socket:/var/lib/mysql/mysql.sock本地连接时用的unix套接字文件</p></li><li><p>/usr/share/mysql 配置文件目录mysql脚本及配置文件</p></li><li><p>/etc/init.d/mysql服务启停相关脚本 </p></li></ul></li><li><p>mysql修改字符集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 查看字符集设置</span><br>show variables like &#x27;character%&#x27;;<br>show variables like &#x27;%char%&#x27;;<br><span class="hljs-meta">#</span><span class="bash"> 默认的是客户端和服务器都用了latin1，所以会乱码</span><br><br><span class="hljs-meta">#</span><span class="bash"> 2. 修改my.cnf</span><br><span class="hljs-meta">#</span><span class="bash"> 在/usr/share/mysql/ 中找到my.cnf的配置文件，拷贝其中的my-huge.cnf 到/etc/, 并命名为my.cnf mysql</span><br><span class="hljs-meta">#</span><span class="bash"> 优先选中/etc/下的配置文件然后修改my.cnf:</span><br>[client]<br>default-character-set=utf8<br>[mysqld]<br>character_set_server=utf8character_set_client=utf8collation-server=utf8_general_ci<br>[mysql]<br>default-character-set=utf8<br><br><span class="hljs-meta">#</span><span class="bash"> 3. 重新启动mysql</span><br><span class="hljs-meta">#</span><span class="bash"> 但是原库的设定不会发生变化，参数修改之对新建的数据库生效</span> <br><br><span class="hljs-meta">#</span><span class="bash"> 4. 已生成的库表字符集如何变更修改数据库的字符集</span><br>alter database mytest character set &#x27;utf8&#x27;;<br><span class="hljs-meta">#</span><span class="bash"> 修改数据表的字符集</span><br>alter table user convert to  character set &#x27;utf8&#x27;; <br>但是原有的数据如果是用非&#x27;utf8&#x27;编码的话，数据本身不会发生改变。     <br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-mysql配置文件"><a href="#1-3-mysql配置文件" class="headerlink" title="1.3 mysql配置文件"></a>1.3 mysql配置文件</h3><p>  （先大致了解，混个眼熟）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p><h3 id="1-4-mysql逻辑框架简介"><a href="#1-4-mysql逻辑框架简介" class="headerlink" title="1.4 mysql逻辑框架简介"></a>1.4 mysql逻辑框架简介</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png"></p><blockquote><p>和其它数据库相比，MySQL有点与众不同，<strong>它的架构可以在多种不同场景中应用并发挥良好作用</strong>。</p><p>主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。</p><p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p></blockquote><ul><li><p>连接层 </p><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p></li><li><p>服务层</p><ol><li>Management Serveices &amp; Utilities： 系统管理和控制工具 </li><li>SQL Interface: SQL接口   接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li><li>Parser: 解析器    SQL命令传递到解析器的时候会被解析器验证和解析。</li><li> Optimizer: 查询优化器。   SQL语句在查询之前会使用查询优化器对查询进行优化。   用一个例子就可以理解： select uid,name from user where gender= 1;   优化器来决定先投影还是先过滤。</li><li>Cache和Buffer： 查询缓存。   如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。   这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等    缓存是负责读，缓冲负责写。</li></ol></li><li><p>引擎层 </p><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB </p></li><li><p>存储层 </p><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p></li></ul><h3 id="1-5-mysql存储引擎"><a href="#1-5-mysql存储引擎" class="headerlink" title="1.5 mysql存储引擎"></a>1.5 mysql存储引擎</h3><h4 id="1-5-1-查看命令"><a href="#1-5-1-查看命令" class="headerlink" title="1.5.1 查看命令"></a>1.5.1 查看命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 看你的mysql现在已提供什么存储引擎</span><br>show engines; <br><span class="hljs-meta">#</span><span class="bash"> 看你的mysql当前默认的存储引擎:</span>  <br>show variables like &#x27;%storage_engine%&#x27;; <br></code></pre></td></tr></table></figure><h4 id="1-5-2-MyISAM和InnoDB"><a href="#1-5-2-MyISAM和InnoDB" class="headerlink" title="1.5.2  MyISAM和InnoDB"></a>1.5.2  <font color=#FF0000><strong>MyISAM和InnoDB</strong></font></h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png"></p><h4 id="1-5-3-各个存储引擎介绍"><a href="#1-5-3-各个存储引擎介绍" class="headerlink" title="1.5.3 各个存储引擎介绍"></a>1.5.3 各个存储引擎介绍</h4><ol><li><strong>InnoDB</strong>存储引擎：InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况 </li><li><strong>MyISAM</strong>存储引擎：MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 </li><li>Archive引擎：Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。 </li><li>Blackhole引擎：Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </li><li>CSV引擎：CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。 </li><li>Memory引擎：如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis) </li><li>Federated引擎：Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。 </li></ol><h4 id="1-5-4-阿里巴巴、淘宝用哪个"><a href="#1-5-4-阿里巴巴、淘宝用哪个" class="headerlink" title="1.5.4 阿里巴巴、淘宝用哪个"></a>1.5.4 阿里巴巴、淘宝用哪个</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png"></p><h2 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2.  索引优化分析"></a>2.  索引优化分析</h2><h3 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png"></p><h3 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png"></p><ul><li><p>SQL解析：机读顺序（先from）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png"></p></li><li><p>Join图（重点，基本功一定要记住）：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BE.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_9_join%E5%9B%BE.png"></p></li></ul><h3 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h3><h4 id="2-3-1-索引是什么（重点）"><a href="#2-3-1-索引是什么（重点）" class="headerlink" title="2.3.1 索引是什么（重点）"></a>2.3.1 索引是什么（重点）</h4><blockquote><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p></blockquote><ul><li><p><strong>索引的本质</strong>：索引是<font color=#FF0000>数据结构</font></p></li><li><p>索引的目的：在于提高查询效率</p><p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p></li><li><p>简单理解： <font color=#FF0000><strong>索引是排好序的快速查找数据结构</strong></font> </p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png"></p><ul><li>二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。</li><li>B-TREE：(B:balance) 会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)  </li><li>B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。</li><li>B+TREE：Innodb 所使用的索引</li></ul></li><li><p><font color=#FF0000><strong>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引</strong></font>。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p></li></ul><h4 id="2-3-2-索引的优势"><a href="#2-3-2-索引的优势" class="headerlink" title="2.3.2 索引的优势"></a>2.3.2 索引的优势</h4><ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><h4 id="2-3-3-索引的劣势"><a href="#2-3-3-索引的劣势" class="headerlink" title="2.3.3 索引的劣势"></a>2.3.3 索引的劣势</h4><ul><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要<strong>占用空间</strong>的</p></li><li><p>虽然索引大大<strong>提高了查询速度</strong>，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</p></li><li><p><font color=#FF0000><strong>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</strong></font></p></li></ul><h4 id="2-3-4-索引的分类"><a href="#2-3-4-索引的分类" class="headerlink" title="2.3.4 索引的分类"></a>2.3.4 索引的分类</h4><h5 id="2-3-4-1-单值索引"><a href="#2-3-4-1-单值索引" class="headerlink" title="2.3.4.1 单值索引"></a>2.3.4.1 单值索引</h5><blockquote><p>即一个索引只包含单个列，一个表可以有多个单列索引</p></blockquote><h5 id="2-3-4-2-唯一索引"><a href="#2-3-4-2-唯一索引" class="headerlink" title="2.3.4.2 唯一索引"></a>2.3.4.2 唯一索引</h5><blockquote><p>索引列的值必须唯一，但允许有空值</p></blockquote><h5 id="2-3-4-3-复合索引"><a href="#2-3-4-3-复合索引" class="headerlink" title="2.3.4.3 复合索引"></a>2.3.4.3 复合索引</h5><blockquote><p>即一个索引包含多个列</p></blockquote><h5 id="2-3-4-4-主键索引"><a href="#2-3-4-4-主键索引" class="headerlink" title="2.3.4.4 主键索引"></a>2.3.4.4 主键索引</h5><blockquote><p>设定为主键后数据库会自动建立索引，innodb为聚簇（聚集）索引</p><p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><h5 id="2-3-4-5-基本语法"><a href="#2-3-4-5-基本语法" class="headerlink" title="2.3.4.5 基本语法"></a>2.3.4.5 基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 创建<br>CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length))<br>ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) <br><br># 2. 删除<br>DROP INDEX [indexName] ON mytable<br><br># 3. 查看<br>SHOW INDEX FROM table_name\G<br><br># 4. 使用ALTER命令<br># 有四种方式来添加数据表的索引：<br>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) # 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。<br>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list) # 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次<br>ALTER TABLE tbl_name ADD INDEX index_name (column_list) # 添加普通索引，索引值可出现多次。<br>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) #该语句指定了索引为 FULLTEXT ，用于全文索引。 <br></code></pre></td></tr></table></figure><h4 id="2-3-5-mysql索引结构⭐"><a href="#2-3-5-mysql索引结构⭐" class="headerlink" title="2.3.5 mysql索引结构⭐"></a>2.3.5 mysql索引结构⭐</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><ul><li><p>B-Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><ul><li>d为大于1的一个正整数，称为B-Tree的度。</li><li>h为一个正整数，称为B-Tree的高度。</li><li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li><li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li><li>所有叶节点具有相同的深度，等于树高h。</li><li>key和指针互相间隔，节点两端是指针。</li><li>一个节点中的key从左到右非递减排列。</li><li>所有节点组成树结构。</li><li>每个指针要么为null，要么指向另外一个节点。</li><li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li><li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li><li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png"></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">BTree_Search(node, key) &#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    foreach(node.key)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(node.key[i] == key) <span class="hljs-keyword">return</span> node.data[i];<br>            <span class="hljs-keyword">if</span>(node.key[i] &gt; key) <span class="hljs-keyword">return</span> BTree_Search(point[i]-&gt;node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> BTree_Search(point[i+<span class="hljs-number">1</span>]-&gt;node);<br>&#125;<br>data = BTree_Search(root, my_key);<br></code></pre></td></tr></table></figure><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p></li><li><p>B+Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li><p>每个节点的指针上限为2d而不是2d+1。</p></li><li><p>内节点不存储data，只存储key；叶子节点不存储指针。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png"></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p></li><li><p>带有顺序访问指针的B+Tree<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png"></p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p></li><li><p>为什么使用B-Tree（B+Tree）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础</p><p>考虑到<strong>主存存取原理</strong>，<strong>磁盘存取原理</strong>，<strong>局部性原理与磁盘预读</strong>详细见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li><p>一般使用磁盘I/O次数评价索引结构的优劣。</p></li><li><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><blockquote><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p></blockquote></li><li><p><font color=#FF0000><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(logdN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）</strong></font></p></li><li><p>综上所述，用B-Tree作为索引结构效率是非常高的</p></li><li><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多</p></li></ul></li></ul><ul><li><p>B+Tree适合外存索引的原因<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup>：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png"></p></li></ul><ul><li><p>MyISAM索引实现<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png"></p><blockquote><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png"></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><blockquote><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p></blockquote></li></ul><ul><li><p>InnoDB索引实现<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">[1]</span></a></sup></p><ul><li><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p></li><li><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png"></p><blockquote><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p></blockquote><ul><li><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如下图为定义在Col3上的一个辅助索引</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png"></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p></li></ul></li></ul><h4 id="2-3-6-哪些情况需要创建索引"><a href="#2-3-6-哪些情况需要创建索引" class="headerlink" title="2.3.6 哪些情况需要创建索引"></a>2.3.6 哪些情况需要创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><h4 id="2-3-7-哪些情况不需要创建索引"><a href="#2-3-7-哪些情况不需要创建索引" class="headerlink" title="2.3.7 哪些情况不需要创建索引"></a>2.3.7 哪些情况不需要创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><p>关于<strong>2.3.7.4</strong>的判断公式：<img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"></p><h3 id="2-4-索引性能分析"><a href="#2-4-索引性能分析" class="headerlink" title="2.4 索引性能分析"></a>2.4 索引性能分析</h3><h4 id="2-4-1-MySQL-Query-Optimizer"><a href="#2-4-1-MySQL-Query-Optimizer" class="headerlink" title="2.4.1 MySQL Query Optimizer"></a>2.4.1 MySQL Query Optimizer</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png"></p><h4 id="2-4-2-MySQL常见瓶颈"><a href="#2-4-2-MySQL常见瓶颈" class="headerlink" title="2.4.2 MySQL常见瓶颈"></a>2.4.2 MySQL常见瓶颈</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png"></p><h4 id="2-4-3-Explain"><a href="#2-4-3-Explain" class="headerlink" title="2.4.3 Explain"></a>2.4.3 <font color=#FF0000><strong>Explain</strong></font></h4><h5 id="2-4-3-1-Explain是什么"><a href="#2-4-3-1-Explain是什么" class="headerlink" title="2.4.3.1 Explain是什么"></a>2.4.3.1 Explain是什么</h5><blockquote><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p></blockquote><p>官网介绍: <a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">http://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p><h5 id="2-4-3-2-Explain能干嘛"><a href="#2-4-3-2-Explain能干嘛" class="headerlink" title="2.4.3.2 Explain能干嘛"></a>2.4.3.2 Explain能干嘛</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png"></p><h5 id="2-4-3-3-Explain怎么用"><a href="#2-4-3-3-Explain怎么用" class="headerlink" title="2.4.3.3 Explain怎么用"></a>2.4.3.3 Explain怎么用</h5><blockquote><p>Explain + SQL语句</p></blockquote><ul><li><p>执行计划包含的信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png"></p></li></ul><h5 id="2-4-3-4-Explain执行计划各字段解释"><a href="#2-4-3-4-Explain执行计划各字段解释" class="headerlink" title="2.4.3.4 Explain执行计划各字段解释"></a>2.4.3.4 Explain执行计划各字段解释</h5><ul><li><p>id ⭐：</p><ul><li><p>含义：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的<strong>顺序</strong></p></li><li><p>三种情况：</p><ul><li><p>id相同：执行顺序由上至下</p></li><li><p>id不同：如果是子查询，id的序号会递增，<font color=#FF0000><strong>id值越大优先级越高</strong></font>，越先被执行</p></li><li><p>id相同/不同，同时存在：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png"></p><p>衍生表 = derived2 –&gt; derived + 2 </p><p>（2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）</p></li></ul></li></ul></li></ul><ul><li><p>select_type：</p><ul><li><p>包含：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png"></p></li><li><p>查询的类型：</p><p>主要是用于区别：普通查询、联合查询、子查询等的复杂查询</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png"></p></li></ul></li></ul><ul><li>table：显示这一行的数据是关于哪张表的</li></ul><ul><li><p>type⭐：</p><ul><li><p>包含：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png"></p></li><li><p> type显示的是访问类型，是较为重要的一个指标</p></li><li><p><font color=#FF0000><strong>结果值从最好到最坏依次是</strong></font>：</p><p>(system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL )</p><p><font color=#FF0000><strong>简化版（记住）</strong></font>：<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong> 一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png"></p></li></ul></li></ul><ul><li>possible_keys：<ul><li>显示可能应用在这张表中的索引，一个或多个。</li><li>查询涉及到的字段上若存在索引，则该索引将被列出，<font color=#FF0000><strong>但不一定被查询实际使用</strong></font></li></ul></li></ul><ul><li>key⭐：<ul><li>实际使用的索引。如果为NULL，则没有使用索引、索引失效</li><li><font color=#0000FF><strong>查询中若使用了覆盖索引，则该索引和查询的select字段重叠</strong></font></li></ul></li></ul><ul><li>key_len：<ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。不损失精度性的情况下，长度越短越好 </li><li>key_len字段能够帮你检查是否充分的利用上了索引</li></ul></li></ul><ul><li>ref：<ul><li>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li></ul></li></ul><ul><li>rows⭐：<ul><li>rows列显示MySQL认为它执行查询时必须检查的行数。</li><li>越少越好</li></ul></li></ul><ul><li>Extra⭐：<ul><li><p>包含不适合在其他列中显示但十分重要的额外信息</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png"></p></li><li><p><font color=#0000FF><strong>覆盖索引</strong></font>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p><p>①一个索引 </p><p>②包含了(或覆盖了)[select子句]与查询条件[Where子句]中 </p><p>③所有需要的字段就叫做<font color=#FF0000><strong>覆盖索引</strong></font>。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png"></p><p><strong>理解</strong>：     </p><blockquote><p>select id , name from t_xxx where age=18;   </p><p>有一个组合索引 idx_id_name_age_xxx 包含了(覆盖了) id,name,age三个字段。查询时直接将建立了索引的列读取出来了，而不需要去查找所在行的其他数据, 所以很高效。</p></blockquote><p>(个人认为：在数据量较大，固定字段查询情况多时可以使用这种方法。)</p></li></ul></li></ul><h3 id="2-5-查询优化"><a href="#2-5-查询优化" class="headerlink" title="2.5 查询优化"></a>2.5 查询优化</h3><h4 id="2-5-1-索引优化"><a href="#2-5-1-索引优化" class="headerlink" title="2.5.1 索引优化"></a>2.5.1 索引优化</h4><h5 id="2-5-1-1-索引分析"><a href="#2-5-1-1-索引分析" class="headerlink" title="2.5.1.1 索引分析"></a>2.5.1.1 索引分析</h5><ul><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=209">单表分析案例</a></p></li><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=210">多表分析案例</a></p></li><li><p><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=211">三表分析案例</a></p><ul><li>尽可能减少Join语句的NextedLoop的循环总次数：永远用小结果集驱动大结果集</li><li>优先优化NestedLoop的内层循环</li><li><font color=#FF0000><strong>保证Join语句中被驱动表上Join条件的字段已经被索引</strong></font></li><li>当无法保证被驱动表的Join条件字段被索引且内存充足的前提下，不要太吝啬JoinBuffer的设置</li></ul></li></ul><h5 id="2-5-1-2-索引失效"><a href="#2-5-1-2-索引失效" class="headerlink" title="2.5.1.2 索引失效"></a>2.5.1.2 <font color=#FF0000><strong>索引失效</strong></font></h5><ul><li><font color=#FF0000><strong>联合索引在B+Tree上的存储结构及数据查找方式.</strong></font> ⭐，具体参考<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/feichitianxia/article/details/107997795">[3]</span></a></sup>（基于底层去理解索引失效）<ul><li>这里贴一个简单的联合索引的结构图，具体看上面的帖子</li><li><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png"></li></ul></li><li>索引失效案例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"></p><ul><li><p>小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png"></p></li></ul><h5 id="2-5-1-3-一般性建议"><a href="#2-5-1-3-一般性建议" class="headerlink" title="2.5.1.3 一般性建议"></a>2.5.1.3 一般性建议</h5><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png"></p><h5 id="2-5-1-4-优化口诀"><a href="#2-5-1-4-优化口诀" class="headerlink" title="2.5.1.4 优化口诀"></a>2.5.1.4 优化口诀</h5><p>建议理解，不用背</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png"></p><h4 id="2-5-2-查询优化"><a href="#2-5-2-查询优化" class="headerlink" title="2.5.2 查询优化"></a>2.5.2 查询优化</h4><blockquote><p>对于数据库分析</p><ol><li>观察，至少跑一天，看看生产的慢SQL情况。</li><li>开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li><li>explain+慢SQL分析</li><li>show profile</li><li>运维经理 or DBA来进行SQL数据库服务器的参数调优</li></ol></blockquote><p><strong>总结</strong>：</p><ul><li>慢查询开启并捕获</li><li>explain+慢SQL分析</li><li>show profile查询SQL再MySQL服务器里面的执行细节和生命周期情况</li><li>SQL数据库服务器参数调优</li></ul><h5 id="2-5-2-1-优化原则1：小表驱动大表"><a href="#2-5-2-1-优化原则1：小表驱动大表" class="headerlink" title="2.5.2.1 优化原则1：小表驱动大表"></a>2.5.2.1 优化原则1：小表驱动大表</h5><ul><li><p>类似嵌套循环Nested Loop</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png"></p></li><li><p>in/exists</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png"></p></li></ul><h5 id="2-5-2-2-order-by关键字优化"><a href="#2-5-2-2-order-by关键字优化" class="headerlink" title="2.5.2.2 order by关键字优化"></a>2.5.2.2 order by关键字优化</h5><blockquote><p>尽量使用Index方式排序,避免使用FileSort方式排序</p></blockquote><ul><li><p>MySQL支持二种方式的排序，FileSort和Index</p><ul><li>Index效率高.它指MySQL扫描索引本身完成排序。</li></ul></li><li><p>FileSort方式效率较低。</p></li></ul><blockquote><p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p></blockquote><ul><li>ORDER BY满足两情况，会使用Index方式排序<ul><li>ORDER BY 语句使用索引最左前列</li><li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li><li>where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</li></ul></li></ul><ul><li><p>小总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png"></p></li></ul><blockquote><p>如果不在索引列上，filesort有两种算法：</p><p>mysql就要启动<strong>双路排序</strong>和<strong>单路排序</strong></p></blockquote><ul><li>双路排序<ul><li>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。（两次）</li><li><strong>缺点</strong>：取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li></ul></li></ul><ul><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</li><li>它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li><li>结论及引申出的问题：<ul><li>结论：由于单路是后出的，总体而言好过双路</li><li>问题：在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li></ul></li></ul></li></ul><ul><li><p>优化策略</p><ul><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>去掉select 后面不需要的字段</p></li><li><p>以上策略对应的原因：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png"></p></li></ul></li></ul><h5 id="2-5-2-3-group-by关键字优化"><a href="#2-5-2-3-group-by关键字优化" class="headerlink" title="2.5.2.3 group by关键字优化"></a>2.5.2.3 group by关键字优化</h5><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ul><h5 id="2-5-2-4-关联查询优化"><a href="#2-5-2-4-关联查询优化" class="headerlink" title="2.5.2.4 关联查询优化"></a>2.5.2.4 关联查询优化</h5><ul><li>保证被驱动表的join字段已经被索引</li><li>left join 时，选择小表作为驱动表，大表作为被驱动表</li><li>inner join 时，mysql会自己帮你把小结果集的表选为驱动表</li><li>子查询尽量不要放在被驱动表，有可能使用不到索引</li></ul><h5 id="2-5-2-5-子查询优化"><a href="#2-5-2-5-子查询优化" class="headerlink" title="2.5.2.5 子查询优化"></a>2.5.2.5 子查询优化</h5><ul><li>有索引的情况下 用 inner join 是最好的 其次是 in ，exists最糟糕 </li><li>无索引的情况下用 小表驱动大表 因为join 方式需要distinct ，没有索引distinct消耗性能较大 所以 exists性能最佳 in其次 join性能最差</li><li>无索引的情况下大表驱动小表in 和 exists 的性能应该是接近的 都比较糟糕 exists稍微好一点 超不过5%   但是inner join 由于使用了 join buffer 所以快很多如果left join 则最慢 </li></ul><h5 id="2-5-2-6-分页查询优化"><a href="#2-5-2-6-分页查询优化" class="headerlink" title="2.5.2.6 分页查询优化"></a>2.5.2.6 分页查询优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 优化前<br>EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY deptno  LIMIT 10000,40<br># 优化后<br>EXPLAIN SELECT SQL_NO_CACHE * FROM emp INNER JOIN (SELECT id FROM emp e ORDER BY deptno LIMIT 10000,40) a ON a.id&#x3D;emp.id<br></code></pre></td></tr></table></figure><ul><li><p>先利用覆盖索引把要取的数据行的主键取到，然后再用这个主键列与数据表做关联（查询的数据量小了）</p></li><li><p>实践证明： </p><p>①、order by 后的字段（XXX）有索引 </p><p>②、sql 中有 limit 时，  当 select id 或 XXX字段索引包含字段时 ，显示 using index  当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort </p></li></ul><h5 id="2-5-2-7-去重优化"><a href="#2-5-2-7-去重优化" class="headerlink" title="2.5.2.7 去重优化"></a>2.5.2.7 去重优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 将产生重复数据<br>select kcdz from t_mall_sku where id in( 3,4,5,6,8 )<br><br># 使用 distinct 关键字去重消耗性能优化<br>select distinct kcdz from t_mall_sku where id in( 3,4,5,6,8 )<br><br># 能够利用到索引<br>select  kcdz from t_mall_sku where id in( 3,4,5,6,8 )  group by kcdz <br></code></pre></td></tr></table></figure><ul><li><p>尽量不要使用 distinct 关键字去重</p></li><li><p>group by能去重且利用索引</p></li></ul><h2 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3. 查询截取分析"></a>3. 查询截取分析</h2><h3 id="3-1-慢查询日志"><a href="#3-1-慢查询日志" class="headerlink" title="3.1 慢查询日志"></a>3.1 慢查询日志</h3><h4 id="3-1-1-慢查询日志介绍"><a href="#3-1-1-慢查询日志介绍" class="headerlink" title="3.1.1 慢查询日志介绍"></a>3.1.1 慢查询日志介绍</h4><ul><li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 </p></li><li><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。 </p></li><li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。 </p></li></ul><h4 id="3-1-2-慢查询日志使用"><a href="#3-1-2-慢查询日志使用" class="headerlink" title="3.1.2 慢查询日志使用"></a>3.1.2 慢查询日志使用</h4><blockquote><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p></blockquote><ul><li><p>查看是否开启及如何开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看<br>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;<br># 设置开启，只对当前数据库生效<br>set global slow_query_log&#x3D;1;<br></code></pre></td></tr></table></figure></li><li><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png"></p></li></ul><ul><li><p>查看当前多少秒算慢, 以及修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看<br>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;<br># 设置<br>set global long_query_time&#x3D;1;<br># 需要重新连接或新开一个会话才能看到修改值<br>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;<br><br># 改变当前session变量<br>set session long_query_time&#x3D;1;<br></code></pre></td></tr></table></figure></li><li><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show global status like &#39;%Slow_queries%&#39;;  <br></code></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-日志分析工具mysqldumpslow"><a href="#3-1-3-日志分析工具mysqldumpslow" class="headerlink" title="3.1.3 日志分析工具mysqldumpslow"></a>3.1.3 日志分析工具mysqldumpslow</h4><ul><li><p>工作常用参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log<br># 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more<br></code></pre></td></tr></table></figure></li><li><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png"></p></li></ul><h3 id="3-2-批量数据脚本"><a href="#3-2-批量数据脚本" class="headerlink" title="3.2 批量数据脚本"></a>3.2 批量数据脚本</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png"></p><ul><li><p>创建函数，假如报错：This function has none of DETERMINISTIC……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 由于开启过慢查询日志，因为我们开启了 bin-log, 我们就必须为我们的function指定一个参数。<br>show variables like &#39;log_bin_trust_function_creators&#39;;<br>set global log_bin_trust_function_creators&#x3D;1;<br><br># 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法：<br># windows下: my.ini[mysqld]加上log_bin_trust_function_creators&#x3D;1<br># linux下: &#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators&#x3D;1<br></code></pre></td></tr></table></figure></li><li><p>创建函数,保证每条数据都不同</p><ul><li><p>随机产生字符串</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)<br>BEGIN    ##方法开始 <br>DECLARE chars_str VARCHAR(100) DEFAULT   &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;;  ##声明一个 字符窜长度为 100 的变量 chars_str ,默认值  <br>DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;; DECLARE i INT DEFAULT 0;  ##循环开始<br>WHILE i &lt; n DO   <br>SET return_str &#x3D;CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));##concat 连接函数  ，substring(a,index,length) 从index处开始截取<br>SET i &#x3D; i + 1;<br>END WHILE;<br>RETURN return_str;<br>END $$ <br># 假如要删除<br># drop function rand_string;<br></code></pre></td></tr></table></figure></li><li><p>随机产生部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">    DELIMITER $$<br>    CREATE FUNCTION rand_num( ) RETURNS INT(5)<br>BEGIN    <br>    DECLARE i INT DEFAULT 0;<br>    SET i &#x3D; FLOOR(100+RAND()*10);<br>    RETURN i;<br>    END $$  <br>    # 假如要删除<br>    # drop function rand_num;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建存储过程</p><ul><li><p>插入数据的存储过程(往emp表添加随机数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE insert_emp10000(IN START INT(10),IN max_num INT(10))<br>BEGIN  <br>DECLARE i INT DEFAULT 0;   #set autocommit &#x3D;0 把autocommit设置成0  ；提高执行效率 <br>SET autocommit &#x3D; 0;     <br>REPEAT  ##重复 <br>SET i &#x3D; i + 1;   <br>INSERT INTO emp10000 (empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i) ,rand_string(6),&#39;SALESMAN&#39;,0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());   <br>UNTIL i &#x3D; max_num   ##直到  上面也是一个循环<br>END REPEAT;  ##满足条件后结束循环 <br>COMMIT;   ##执行完成后一起提交 <br>END $$ <br># 删除<br># DELIMITER ;<br># drop PROCEDURE insert_emp; <br></code></pre></td></tr></table></figure></li><li><p>插入数据的存储过程(往dept表添加随机数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程，往dept表添加随机数据<br>DELIMITER $$<br>CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))<br>BEGIN  <br>DECLARE i INT DEFAULT 0;<br>SET autocommit &#x3D; 0;     <br>REPEAT   <br>SET i &#x3D; i + 1;   <br>INSERT INTO dept (deptno ,dname,loc ) VALUES (START +i ,rand_string(10),rand_string(8));   <br>UNTIL i &#x3D; max_num   <br>END REPEAT;   <br>COMMIT;   <br>END $$  <br>#删除<br># DELIMITER ; #将 结束标志换回 ;<br># drop PROCEDURE insert_dept;<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>调用存储过程</p><ul><li><p>dept</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER ; #将 结束标志换回 ;<br>CALL insert_dept(100,10); <br></code></pre></td></tr></table></figure></li><li><p>emp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#执行存储过程，往emp表添加50万条数据<br>DELIMITER ;    #将 结束标志换回 ;<br>CALL insert_emp(100001,500000);  <br>CALL insert_emp10000(100001,10000);    <br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3-Show-Profile"><a href="#3-3-Show-Profile" class="headerlink" title="3.3 Show Profile"></a>3.3 Show Profile</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><blockquote><p>是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></blockquote><h4 id="3-3-2-官网介绍"><a href="#3-3-2-官网介绍" class="headerlink" title="3.3.2 官网介绍"></a>3.3.2 官网介绍</h4><p>官网：<a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p><h4 id="3-3-3-默认设置"><a href="#3-3-3-默认设置" class="headerlink" title="3.3.3 默认设置"></a>3.3.3 默认设置</h4><blockquote><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></blockquote><h4 id="3-3-4-分析步骤"><a href="#3-3-4-分析步骤" class="headerlink" title="3.3.4 分析步骤"></a>3.3.4 分析步骤</h4><ul><li><p>看看当前的mysql版本是否支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Show variables like &#39;profiling&#39;; #  默认是关闭，使用前需要开启    <br>set profiling&#x3D;1;  #  开启<br></code></pre></td></tr></table></figure></li><li><p>运行SQL</p></li><li><p>查看结果，show profiles；</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png"></p></li><li><p>诊断SQL，show profile cpu,block io for query  n  (n为上一步前面的问题SQL数字号码);</p><ul><li><p>查询命令的参数</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png"></p></li><li><p>查询结果</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png"></p></li></ul></li></ul><ul><li><p>日常开发需要注意的结论</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png"></p><ul><li><p>创建临时表的性能耗费示例：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png"></p></li></ul></li></ul><h3 id="3-4-全局查询日志"><a href="#3-4-全局查询日志" class="headerlink" title="3.4 全局查询日志"></a>3.4 全局查询日志</h3><h4 id="3-4-1-配置启用"><a href="#3-4-1-配置启用" class="headerlink" title="3.4.1 配置启用"></a>3.4.1 配置启用</h4><p>在mysql的my.cnf中，设置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启</span><br><span class="hljs-attr">general_log</span>=<span class="hljs-number">1</span>  <br><span class="hljs-comment"># 记录日志文件的路径</span><br><span class="hljs-attr">general_log_file</span>=/path/logfile<br><span class="hljs-comment"># 输出格式</span><br><span class="hljs-attr">log_output</span>=FILE<br></code></pre></td></tr></table></figure><h4 id="3-4-2-编码启用"><a href="#3-4-2-编码启用" class="headerlink" title="3.4.2 编码启用"></a>3.4.2 编码启用</h4><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png"></p><blockquote><p><font color=#FF0000><strong>特别的：尽量不要在生产环境开启这个功能</strong></font></p></blockquote><h2 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4. MySQL锁机制"></a>4. MySQL锁机制</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote><h3 id="4-2-锁的分类"><a href="#4-2-锁的分类" class="headerlink" title="4.2 锁的分类"></a>4.2 锁的分类</h3><h4 id="4-2-1-从对数据操作的类型（读-写）分"><a href="#4-2-1-从对数据操作的类型（读-写）分" class="headerlink" title="4.2.1 从对数据操作的类型（读\写）分"></a>4.2.1 从对数据操作的类型（读\写）分</h4><ul><li>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁(排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul><h4 id="4-2-2-从对数据操作的粒度分"><a href="#4-2-2-从对数据操作的粒度分" class="headerlink" title="4.2.2 从对数据操作的粒度分"></a>4.2.2 从对数据操作的粒度分</h4><ul><li>表锁</li><li>行锁</li></ul><h3 id="4-3-三锁"><a href="#4-3-三锁" class="headerlink" title="4.3 三锁"></a>4.3 三锁</h3><h4 id="4-3-1-表锁（偏读）"><a href="#4-3-1-表锁（偏读）" class="headerlink" title="4.3.1 表锁（偏读）"></a>4.3.1 表锁（偏读）</h4><blockquote><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></blockquote><ul><li><p>手动加读写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">lock tabel 表名 read(write), 表名2 read(write), ...;<br></code></pre></td></tr></table></figure></li><li><p>查看表上加过的锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show open tables;<br></code></pre></td></tr></table></figure></li><li><p>释放表锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure></li><li><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png"></p><p>补充：加读锁的session也不能修改加读锁的表。</p><p><font color=#FF0000><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong></font></p></li><li><p>如何分析表锁定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png"></p></li></ul><h4 id="4-3-2-行锁（偏写）"><a href="#4-3-2-行锁（偏写）" class="headerlink" title="4.3.2 行锁（偏写）"></a>4.3.2 行锁（偏写）</h4><blockquote><p>特点：</p><ol><li>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li></ol></blockquote><ul><li><p>行锁支持事务，<a href="http://lihengxu.cn/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/#5-TCL%E8%AF%AD%E8%A8%80">复习初级部分知识⭐</a></p><ul><li><p>重点:事务特性、并发事务导致的问题、事务隔离级别等</p></li><li><p>补充：并发事务导致的问题（更新丢失）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png"></p></li></ul></li></ul><ul><li><p><font color=#FF0000><strong>无索引(或者索引失效)行锁升级为表锁</strong></font></p></li><li><p>间隙锁的危害</p><ul><li><p><strong>间隙锁</strong>: </p><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。 </p></li><li><p><strong>危害</strong>:</p><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p></li></ul></li><li><p><font color=#FF0000><strong>[面试题] 常考如何锁定一行</strong></font></p><p>事务显示加锁<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_33033819/article/details/106445880">[9]</span></a></sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">##在 MySQL 5.7 中<br>共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE<br>排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE<br><br>##在 MySQL 8.0 中<br>共享锁（S）：SELECT * FROM table_name WHERE ... FOR SHARE<br>排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE[NOWAIT|SKIP LOCKED]<br>--NOWAIT:发现有锁等待后会立即返回错误，不用等待锁超时后报错。<br>--SKIP LOCKED:跳过被锁定的行，直接更新其他行，但是这样要注意是否会造成更新结果不符合预期。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p></li></ul><ul><li><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。 </p></li><li><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p></li><li><p>如何分析行锁定</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png"></p></li></ul><ul><li>优化建议：<ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁</li><li>涉及相同表的事务，对于调用表的顺序尽量保持一致</li><li>在业务环境允许的情况下,尽可能低级别事务隔离</li></ul></li></ul><h4 id="4-3-2-页锁（了解）"><a href="#4-3-2-页锁（了解）" class="headerlink" title="4.3.2 页锁（了解）"></a>4.3.2 页锁（了解）</h4><blockquote><p>开销和加锁时间界于表锁和行锁之间；</p><p>会出现死锁；</p><p>锁定粒度界于表锁和行锁之间，并发度一般。</p></blockquote><h2 id="5-主从复制⭐"><a href="#5-主从复制⭐" class="headerlink" title="5. 主从复制⭐"></a>5. 主从复制⭐</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png"></p><h3 id="5-1-复制的基本原理"><a href="#5-1-复制的基本原理" class="headerlink" title="5.1 复制的基本原理"></a>5.1 复制的基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></p><h3 id="5-2-复制的基本原则"><a href="#5-2-复制的基本原则" class="headerlink" title="5.2 复制的基本原则"></a>5.2 复制的基本原则</h3><ul><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个salve</li></ul><h3 id="5-3-复制的最大问题"><a href="#5-3-复制的最大问题" class="headerlink" title="5.3 复制的最大问题"></a>5.3 复制的最大问题</h3><blockquote><p>延时</p></blockquote><h3 id="5-4-一主一从常见配置"><a href="#5-4-一主一从常见配置" class="headerlink" title="5.4 一主一从常见配置"></a>5.4 一主一从常见配置</h3><ul><li><p>mysql版本一致且后台以服务运行</p></li><li><p>主从都配置在[mysqld]结点下，都是小写</p></li><li><p>主机修改my.ini配置文件</p><ul><li>[必须]主服务器唯一ID<ul><li>server-id=1</li></ul></li></ul></li><li><p>[必须]启用二进制日志</p><ul><li><p>log-bin=自己本地的路径/data/mysqlbin</p><ul><li>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin</li></ul></li><li><p>[可选]启用错误日志</p><ul><li>log-err=自己本地的路径/data/mysqlerr</li></ul></li><li><p>log-err=D:/devSoft/MySQLServer5.5/data/mys</p></li><li><p>[可选]根目录</p></li><li><p>basedir=”自己本地路径”</p><ul><li>basedir=”D:/devSoft/MySQLServer5.5/“</li></ul></li></ul></li><li><p>[可选]临时目录</p><ul><li><p>tmpdir=”自己本地路径”</p></li><li><p>tmpdir=”D:/devSoft/MySQLServer5.5/“</p></li><li><p>[可选]数据目录</p><ul><li>datadir=”自己本地路径/Data/“</li><li>datadir=”D:/devSoft/MySQLServer5.5/Data/“</li></ul></li></ul></li><li><p>read-only=0 </p><ul><li><p>主机，读写都可以</p></li><li><p>[可选]设置不要复制的数据库</p></li><li><p>binlog-ignore-db=mysql</p></li><li><p>[可选]设置需要复制的数据库</p><ul><li>binlog-do-db=需要复制的主数据库名字</li></ul></li></ul></li><li><p>从机修改my.cnf配置文件</p><ul><li>[必须]从服务器唯一ID</li><li>[可选]启用二进制日志</li></ul></li><li><p>因修改过配置文件，请主机+从机都重启后台mysql服务</p></li><li><p>主机从机都关闭防火墙</p><ul><li>windows手动关闭</li><li>关闭虚拟机linux防火墙    service iptables stop</li></ul></li><li><p>在Windows主机上建立帐户并授权slave</p><ul><li><p>在主机mysql中执行授权命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.授权<br>GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;123456&#39;;<br># 2.执行结束后刷新<br>flush privileges;<br># 3.查询主机状态<br>show master status;<br># 4.记录下File和Position的值<br># 5.执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在Linux从机上配置需要复制的主机</p><ul><li><p>在从机mysql中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机IP&#39;,<br>MASTER_USER&#x3D;&#39;zhangsan&#39;,<br>MASTER_PASSWORD&#x3D;&#39;123456&#39;,<br>MASTER_LOG_FILE&#x3D;&#39;File名字&#39;,MASTER_LOG_POS&#x3D;Position数字;<br></code></pre></td></tr></table></figure></li><li><p>启动从服务器复制功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start slave;<br></code></pre></td></tr></table></figure></li><li><p>查看从机状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show slave status\G<br></code></pre></td></tr></table></figure><p>下面两个参数都是Yes，则说明主从配置成功!</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: Yes</p></li></ul></li></ul><ul><li><p>主机新建库、新建表、insert记录，从机复制</p></li><li><p>如何停止从服务复制功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">stop slave;<br></code></pre></td></tr></table></figure><p>注意停止后，重新授权需要重新查看主机状态，记录下File和Position的值</p></li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">https://www.bilibili.com/video/BV12b411K7Zu?p=179</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/feichitianxia/article/details/107997795">https://blog.csdn.net/feichitianxia/article/details/107997795</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>MySQL5.1参考手册 - <a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://blog.csdn.net/qq_33033819/article/details/106445880">https://blog.csdn.net/qq_33033819/article/details/106445880</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2021/03/12/MySQL_JDBC/"/>
    <url>/2021/03/12/MySQL_JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p><strong>JDO</strong>技术（Java Data Object）</p></li><li><p>第三方O/R工具，如Hibernate, Mybatis 等</p></li></ul><p><strong>JDBC</strong>是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p><h3 id="1-1-JDBC介绍"><a href="#1-1-JDBC介绍" class="headerlink" title="1.1 JDBC介绍"></a>1.1 JDBC介绍</h3><blockquote><p> JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p></blockquote><p><strong>作用</strong>：</p><ul><li><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p></li><li><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p></li></ul><p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png"></p><p>而通过JDBC可以如下访问：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png"></p><blockquote><p>总结：</p><p>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p></blockquote><h3 id="1-2-JDBC-API"><a href="#1-2-JDBC-API" class="headerlink" title="1.2 JDBC API"></a>1.2 JDBC API</h3><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png"></p><h3 id="1-3-JDBC程序编写步骤"><a href="#1-3-JDBC程序编写步骤" class="headerlink" title="1.3  JDBC程序编写步骤"></a>1.3  JDBC程序编写步骤</h3><ul><li>注册驱动</li><li>获取连接</li><li>执行增删改查</li><li>释放资源</li></ul><h2 id="2-快速使用JDBC"><a href="#2-快速使用JDBC" class="headerlink" title="2. 快速使用JDBC"></a>2. 快速使用JDBC</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar <a href="http://dev.mysql.com/downloads/">MySQL的驱动下载地址</a></li><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li>右键–&gt;Add As Library</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC快速入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//1. 导入驱动jar包</span><br>        <span class="hljs-comment">//2.注册驱动</span><br>        <span class="hljs-comment">// Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>        <span class="hljs-comment">//3.获取数据库连接对象</span><br>        <span class="hljs-comment">// Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br>        Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-comment">//4.定义sql语句</span><br>        <span class="hljs-comment">//String sql = &quot;update account set balance = 2000 where id = 1&quot;;</span><br>        String sql = <span class="hljs-string">&quot;update account set balance = 2000&quot;</span>;<br>        <span class="hljs-comment">//5.获取执行sql的对象 Statement</span><br>        Statement stmt = conn.createStatement();<br>        <span class="hljs-comment">//6.执行sql</span><br>        <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<br>        <span class="hljs-comment">//7.处理结果</span><br>        System.out.println(count);<br>        <span class="hljs-comment">//8.释放资源</span><br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-详解各个对象："><a href="#2-3-详解各个对象：" class="headerlink" title="2.3 详解各个对象："></a>2.3 详解各个对象：</h3><h4 id="2-3-1-DriverManager：驱动管理对象"><a href="#2-3-1-DriverManager：驱动管理对象" class="headerlink" title="2.3.1 DriverManager：驱动管理对象"></a>2.3.1 DriverManager：驱动管理对象</h4><ul><li><p>功能</p><ul><li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar</p><p>static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager</p><p>写代码使用：  Class.forName(“com.mysql.jdbc.Driver”); </p><p>通过反射，加载与注册驱动类，<strong>解耦合（不直接依赖）</strong></p><p>通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>  java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>  &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</p></li><li><p>获取数据库连接：</p><ul><li><p>方法：static Connection getConnection(String url, String user, String password)</p></li><li><p>参数：</p><p><strong>JDBC URL</strong> 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由协议，子协议，子名称三部分组成，各部分间用冒号分隔。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png"></p><p>参数url：指定连接的路径</p><ol><li>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li><li>例子：jdbc:mysql://localhost:3306/db3</li><li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li></ol><p>user：用户名<br>password：密码</p></li></ul></li></ul></li></ul><h4 id="2-3-2-Connection：数据库连接对象"><a href="#2-3-2-Connection：数据库连接对象" class="headerlink" title="2.3.2 Connection：数据库连接对象"></a>2.3.2 Connection：数据库连接对象</h4><ul><li><p>功能</p><ul><li>获取执行sql 的对象</li><li>Statement createStatement()</li><li>PreparedStatement prepareStatement(String sql) </li></ul></li><li><p>管理事务：</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul><h4 id="2-3-3-Statement：执行sql的对象"><a href="#2-3-3-Statement：执行sql的对象" class="headerlink" title="2.3.3 Statement：执行sql的对象"></a>2.3.3 Statement：执行sql的对象</h4><ul><li><p>执行sql</p><ul><li>boolean execute(String sql) ：可以执行任意的sql 了解</li><li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li><li>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</li><li>PreparedStatement prepareStatement(String sql) </li></ul></li><li><p>代码: 对account表完成增删改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Statement stmt = <span class="hljs-keyword">null</span>;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 注册驱动</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>            <span class="hljs-comment">//2. 定义sql(增删改)</span><br>            String sql = <span class="hljs-string">&quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;</span>;<br>            <span class="hljs-comment">//String sql  = &quot;update account set balance = 1500 where id = 3&quot;;</span><br>            <span class="hljs-comment">//String sql  = &quot;delete from account where id = 3&quot;;</span><br>            <span class="hljs-comment">//3.获取Connection对象</span><br>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>            <span class="hljs-comment">//4.获取执行sql的对象 Statement</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">//5.执行sql</span><br>            <span class="hljs-keyword">int</span> count = stmt.executeUpdate(sql);<span class="hljs-comment">//影响的行数</span><br>            <span class="hljs-comment">//6.处理结果</span><br>            System.out.println(count);<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;添加成功！&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;添加失败！&quot;</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//stmt.close();</span><br>            <span class="hljs-comment">//7. 释放资源</span><br>            <span class="hljs-comment">//避免空指针异常</span><br>            <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    stmt.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    conn.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul><h4 id="2-3-4-ResultSet：结果集对象-封装查询结果"><a href="#2-3-4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="2.3.4 ResultSet：结果集对象,封装查询结果"></a>2.3.4 ResultSet：结果集对象,封装查询结果</h4><ul><li><p>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p></li><li><p>getXxx(参数):获取数据</p><ul><li> Xxx：代表数据类型   如： int getInt() ,    String getString()</li><li>参数：<ol><li>int：代表列的编号, 从1开始   如: getString(1)</li><li>String：代表列名称, 如: getDouble(“balance”)</li></ol></li></ul></li><li><p>注意：</p><ul><li><p>使用步骤：</p><ul><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li></ul></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(rs.next())&#123;<br><span class="hljs-comment">//获取数据</span><br><span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-number">1</span>);<br>String name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">double</span> balance = rs.getDouble(<span class="hljs-number">3</span>);<br>System.out.println(id + <span class="hljs-string">&quot;---&quot;</span> + name + <span class="hljs-string">&quot;---&quot;</span> + balance);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-5-PreparedStatement：执行sql的对象"><a href="#2-3-5-PreparedStatement：执行sql的对象" class="headerlink" title="2.3.5 PreparedStatement：执行sql的对象"></a>2.3.5 PreparedStatement：执行sql的对象</h4><ul><li><p>SQL注入问题: 在拼接sql时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题 </p><ul><li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li><li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ </li></ul></li><li><p>解决sql注入问题：使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL：参数使用 ? 作为占位符</p></li><li><p>步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用PreparedStatement实现登录方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username ,String password)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(username == <span class="hljs-keyword">null</span> || password == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//连接数据库判断是否登录成功</span><br>    Connection conn = <span class="hljs-keyword">null</span>;<br>    PreparedStatement pstmt =  <span class="hljs-keyword">null</span>;<br>    ResultSet rs = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//1.获取连接</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        conn =  JDBCUtils.getConnection();<br>        <span class="hljs-comment">//2.定义sql</span><br>        String sql = <span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>;<br>        <span class="hljs-comment">//3.获取执行sql的对象</span><br>        pstmt = conn.prepareStatement(sql);<br>        <span class="hljs-comment">//给?赋值</span><br>        pstmt.setString(<span class="hljs-number">1</span>,username);<br>        pstmt.setString(<span class="hljs-number">2</span>,password);<br>        <span class="hljs-comment">//4.执行查询,不需要传递sql</span><br>        rs = pstmt.executeQuery();<br>        <span class="hljs-comment">//5.判断</span><br>        <span class="hljs-comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;else&#123;</span><br><span class="hljs-comment">                return false;</span><br><span class="hljs-comment">            &#125;*/</span><br>        <span class="hljs-keyword">return</span> rs.next();<span class="hljs-comment">//如果有下一行，则返回true</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        JDBCUtils.close(rs,pstmt,conn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p><ul><li>可以防止SQL注入</li><li>效率更高</li></ul></li></ul><h3 id="2-4-PreparedStatement-Statement-对比"><a href="#2-4-PreparedStatement-Statement-对比" class="headerlink" title="2.4 PreparedStatement/Statement 对比"></a>2.4 PreparedStatement/Statement 对比</h3><blockquote><p><strong>Blob类型的数据</strong> (了解)</p><ol><li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li><li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li></ol><p>注意：如果存储的文件过大，数据库的性能会下降</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png"></p><p><strong>两者区别</strong></p><ul><li><p>代码的可读性和可维护性. Statement的sql拼接是个难题。</p></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li><li><p>PreparedStatement 可以处理Blob类型的数据</p></li><li><p>PreparedStatement 能最大可能提高性能</p><ul><li><p>Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高</p></li><li><p>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行</p></li></ul></li></ul><h2 id="3-JDBCUtils-抽取JDBC工具类"><a href="#3-JDBCUtils-抽取JDBC工具类" class="headerlink" title="3. JDBCUtils: 抽取JDBC工具类"></a>3. JDBCUtils: 抽取JDBC工具类</h2><ul><li><p>目的：简化书写</p></li><li><p>分析：</p><ol><li><p>注册驱动也抽取</p></li><li><p>抽取一个方法获取连接对象</p><ul><li><p>需求：不想传递参数（麻烦），还得保证工具类的通用性。</p></li><li><p>解决：配置文件</p><p> jdbc.properties<br> url=<br> user=<br> password=</p></li></ul></li></ol><ul><li>抽取一个方法释放资源</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取资源文件，获取值。</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 创建Properties集合类。</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br><br>            <span class="hljs-comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br>            ClassLoader classLoader = JDBCUtils.class.getClassLoader();<br>            URL res  = classLoader.getResource(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>            String path = res.getPath();<br>           <span class="hljs-comment">// System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br>            <span class="hljs-comment">//2. 加载文件</span><br>           <span class="hljs-comment">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br>            pro.load(<span class="hljs-keyword">new</span> FileReader(path));<br><br>            <span class="hljs-comment">//3. 获取数据，赋值</span><br>            url = pro.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            user = pro.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            password = pro.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>            driver = pro.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            <span class="hljs-comment">//4. 注册驱动</span><br>            Class.forName(driver);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>( rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-JDBC控制事务"><a href="#4-JDBC控制事务" class="headerlink" title="4. JDBC控制事务"></a>4. JDBC控制事务</h2><ol><li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p></li><li><p>操作：</p><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li><p>使用Connection对象来管理事务</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务</li></ul></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事务操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement pstmt1 = <span class="hljs-keyword">null</span>;<br>        PreparedStatement pstmt2 = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.获取连接</span><br>            conn = JDBCUtils.getConnection();<br>            <span class="hljs-comment">//开启事务</span><br>            conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">//2.定义sql</span><br>            <span class="hljs-comment">//2.1 张三 - 500</span><br>            String sql1 = <span class="hljs-string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//2.2 李四 + 500</span><br>            String sql2 = <span class="hljs-string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//3.获取执行sql对象</span><br>            pstmt1 = conn.prepareStatement(sql1);<br>            pstmt2 = conn.prepareStatement(sql2);<br>            <span class="hljs-comment">//4. 设置参数</span><br>            pstmt1.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt1.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><br>            pstmt2.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt2.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//5.执行sql</span><br>            pstmt1.executeUpdate();<br>            <span class="hljs-comment">// 手动制造异常</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br><br>            pstmt2.executeUpdate();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//事务回滚</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>) &#123;<br>                    conn.rollback();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.close(pstmt1,conn);<br>            JDBCUtils.close(pstmt2,<span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-批处理"><a href="#5-批处理" class="headerlink" title="5. 批处理"></a>5. 批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><blockquote><p> 注意:</p><ol><li>不是所用版本的mysql都支持</li><li><strong>JDBC</strong>连接MySQL时，如果要使用批处理功能，请再ur中加参数?rewriteBatchedStatements=true</li><li><strong>PreparedStatement</strong>作批处理插入时使用values（使用value没有效果）</li></ol></blockquote><h3 id="5-1-JDBC的批量处理语句包括下面方法："><a href="#5-1-JDBC的批量处理语句包括下面方法：" class="headerlink" title="5.1 JDBC的批量处理语句包括下面方法："></a>5.1 JDBC的批量处理语句包括下面方法：</h3><ul><li><p><strong>addBatch</strong>()：添加需要批量处理的SQL语句或参数</p></li><li><p><strong>executeBatch</strong>()：执行批量处理语句；</p></li><li><p><strong>clearBatch</strong>():清空批处理包的语句</p></li></ul><h3 id="5-2-批量执行SQL语句的两种情况"><a href="#5-2-批量执行SQL语句的两种情况" class="headerlink" title="5.2 批量执行SQL语句的两种情况"></a>5.2 批量执行SQL语句的两种情况</h3><ul><li><p>多条SQL语句的批量处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>Statement st = conn.createStatement();<br>st.addBatch(sql1);<br>st.addBatch(sql2);<br>...<br>st.addBatch(sqln);<br>st.executeBatch();<br>st.clearBatch();<br>...<br></code></pre></td></tr></table></figure></li><li><p><strong>一个SQL语句的批量传参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>PreparedStatement pst = conn.prepareStatement(sql);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">1001</span>; i++)&#123;<br>pst.setInt(<span class="hljs-number">1</span>, i);<br>...<br>pst.addBatch();<br>&#125;<br>pst.executeBatch();<br>st.clearBatch();<br>...<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-Blob类型数据的读写（了解）"><a href="#6-Blob类型数据的读写（了解）" class="headerlink" title="6. Blob类型数据的读写（了解）"></a>6. Blob类型数据的读写（了解）</h2><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li><li><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p></li><li><p> 需要注意的是：如果存储的文件过大，数据库的性能会下降</p></li></ul><p>写入：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png"></p><p>读取：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png"></p><h2 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7. 数据库连接池"></a>7. 数据库连接池</h2><ol><li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p><p> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p></li><li><p>好处：</p><ul><li><p>节约资源</p></li><li><p>用户访问高效</p></li></ul></li><li><p>实现：</p></li></ol><ul><li><p>标准接口：DataSource   javax.sql包下的</p><p>方法：</p><ul><li>获取连接：getConnection()</li><li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li></ul></li><li><p>一般我们不去实现它，有数据库厂商来实现</p><ul><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li></ul></li></ul><ol start="4"><li>C3P0：数据库连接池技术</li></ol><ul><li>步骤：</li></ul><ol><li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p><ul><li>不要忘记导入数据库驱动jar包</li></ul></li><li><p>定义配置文件：</p><ul><li>名称： c3p0.properties 或者 c3p0-config.xml</li><li>路径：直接将文件放在src目录下即可。</li></ul></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接： getConnection</p></li></ol><ul><li>代码：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * c3p0的演示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3P0Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-comment">//1.创建数据库连接池对象</span><br>        DataSource ds  = <span class="hljs-keyword">new</span> ComboPooledDataSource();<br>        <span class="hljs-comment">//2. 获取连接对象</span><br>        Connection conn = ds.getConnection();<br>        <span class="hljs-comment">//3. 打印</span><br>        System.out.println(conn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>Druid：数据库连接池实现技术，由阿里巴巴提供的<ol><li>步骤：<ol><li>导入jar包 druid-1.0.9.jar</li><li>定义配置文件：<ul><li>是properties形式的</li><li>可以叫任意名称，可以放在任意目录下</li></ul></li><li>加载配置文件。Properties</li><li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol></li></ol><ul><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Druid演示</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidDemo</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>          <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.定义配置文件</span><br>        <span class="hljs-comment">//3.加载配置文件</span><br>        Properties pro = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>);<br>        pro.load(is);<br>        <span class="hljs-comment">//4.获取连接池对象</span><br>        DataSource ds = DruidDataSourceFactory.createDataSource(pro);<br>        <span class="hljs-comment">//5.获取连接</span><br>        Connection conn = ds.getConnection();<br>        System.out.println(conn);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>定义工具类<ol><li>定义一个类 JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法</li></ol></li><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Druid连接池的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;<br><br>    <span class="hljs-comment">//1.定义成员变量 DataSource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载配置文件</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br>            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>));<br>            <span class="hljs-comment">//2.获取DataSource</span><br>            ds = DruidDataSourceFactory.createDataSource(pro);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>       close(<span class="hljs-keyword">null</span>,stmt,conn);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<span class="hljs-comment">//归还连接</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接池方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）"><a href="#8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）" class="headerlink" title="8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）"></a>8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）</h2><ul><li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>步骤：</p><ol><li><p>导入jar包</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li>JdbcTemplate template = new JdbcTemplate(ds);</li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li><p>update():执行DML语句。增、删、改语句</p></li><li><p>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p><p>注意：这个方法查询的结果集长度只能是1</p></li><li><p>queryForList():查询结果将结果集封装为list集合</p><p>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p></li><li><p>query():查询结果，将结果封装为JavaBean对象</p></li><li><p>query的参数：RowMapper</p></li></ul></li><li><p>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p></li><li><p>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p><ul><li><p>queryForObject：查询结果，将结果封装为对象</p><p>一般用于聚合函数的查询</p></li></ul></li></ol></li></ul><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jdbctemplate;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JdbcTemplate入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.创建JDBCTemplate对象</span><br>        JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());<br>        <span class="hljs-comment">//3.调用方法</span><br>        String sql = <span class="hljs-string">&quot;update account set balance = 5000 where id = ?&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">3</span>);<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jdbctemplate;<br><br><span class="hljs-keyword">import</span> cn.itcast.domain.Emp;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><br><span class="hljs-keyword">import</span> java.sql.Date;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo2</span> </span>&#123;<br><br>    <span class="hljs-comment">//Junit单元测试，可以让方法独立执行</span><br>    <span class="hljs-comment">//1. 获取JDBCTemplate对象</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//2. 定义sql</span><br>        String sql = <span class="hljs-string">&quot;update emp set salary = 10000 where id = 1001&quot;</span>;<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-keyword">int</span> count = template.update(sql);<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 添加一条记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>, <span class="hljs-string">&quot;郭靖&quot;</span>, <span class="hljs-number">10</span>);<br>        System.out.println(count);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3.删除刚才添加的记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;delete from emp where id = ?&quot;</span>;<br>        <span class="hljs-keyword">int</span> count = template.update(sql, <span class="hljs-number">1015</span>);<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="hljs-comment">     * 注意：这个方法查询的结果集长度只能是1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp where id = ? or id = ?&quot;</span>;<br>        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 5. 查询所有记录，将其封装为List</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);<br><br>        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;<br>            System.out.println(stringObjectMap);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Emp&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Emp <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                Emp emp = <span class="hljs-keyword">new</span> Emp();<br>                <span class="hljs-keyword">int</span> id = rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                String ename = rs.getString(<span class="hljs-string">&quot;ename&quot;</span>);<br>                <span class="hljs-keyword">int</span> job_id = rs.getInt(<span class="hljs-string">&quot;job_id&quot;</span>);<br>                <span class="hljs-keyword">int</span> mgr = rs.getInt(<span class="hljs-string">&quot;mgr&quot;</span>);<br>                Date joindate = rs.getDate(<span class="hljs-string">&quot;joindate&quot;</span>);<br>                <span class="hljs-keyword">double</span> salary = rs.getDouble(<span class="hljs-string">&quot;salary&quot;</span>);<br>                <span class="hljs-keyword">double</span> bonus = rs.getDouble(<span class="hljs-string">&quot;bonus&quot;</span>);<br>                <span class="hljs-keyword">int</span> dept_id = rs.getInt(<span class="hljs-string">&quot;dept_id&quot;</span>);<br><br>                emp.setId(id);<br>                emp.setEname(ename);<br>                emp.setJob_id(job_id);<br>                emp.setMgr(mgr);<br>                emp.setJoindate(joindate);<br>                emp.setSalary(salary);<br>                emp.setBonus(bonus);<br>                emp.setDept_id(dept_id);<br><br>                <span class="hljs-keyword">return</span> emp;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6_2</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));<br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 7. 查询总记录数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;<br>        String sql = <span class="hljs-string">&quot;select count(id) from emp&quot;</span>;<br>        Long total = template.queryForObject(sql, Long.class);<br>        System.out.println(total);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>表与JavaBean的关系</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png"></p></li></ul><h2 id="9-DAO层"><a href="#9-DAO层" class="headerlink" title="9.  DAO层"></a>9.  DAO层</h2><ul><li><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</p></li><li><p>作用：为了实现功能的模块化，更有利于代码的维护和升级</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
      <category>Java</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>MySQL</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO框架 个人博客域名更换</title>
    <link href="/2021/03/11/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/"/>
    <url>/2021/03/11/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO框架-个人博客域名更换"><a href="#HEXO框架-个人博客域名更换" class="headerlink" title="HEXO框架 个人博客域名更换"></a>HEXO框架 个人博客域名更换</h1><p>基于<a href="http://lihengxu.cn/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">HEXO框架 个人博客搭建</a>，完成博客项目部署后，我们可以绑定自己的域名</p><h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h2><p>在<a href="https://wanwang.aliyun.com/">阿里云的万网</a>购买了自己域名：lihengxu.cn</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_1_%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7.png"></p><p>购买后可以在<a href="https://dc.console.aliyun.com/">域名控制台</a>看到自己的域名信息</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_2_%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E6%8E%A7%E5%88%B6%E5%8F%B0.png"></p><h2 id="2-解析域名"><a href="#2-解析域名" class="headerlink" title="2. 解析域名"></a>2. 解析域名</h2><ul><li><p>解析之前先ping 一下博客仓库对应的GitHub二级域名：</p><p>lihengxu.github.io的IP地址：185.199.110.153</p></li><li><p>然后点击解析</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_3_%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D.png"></p><ul><li>添加两个解析记录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_4_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%951.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_5_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%952.png"></p><ul><li>完成添加后的效果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_6_%E8%A7%A3%E6%9E%90%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%953.png"></p><h2 id="3-设置CNAME"><a href="#3-设置CNAME" class="headerlink" title="3. 设置CNAME"></a>3. 设置CNAME</h2><p>在项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的）</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_7_CNAME%E6%96%87%E4%BB%B6.png"></p><p>然后填写上域名。比如：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo2_8_CNAME%E6%96%87%E4%BB%B6.png"></p><h2 id="4-更新并重新部署"><a href="#4-更新并重新部署" class="headerlink" title="4. 更新并重新部署"></a>4. 更新并重新部署</h2><p>一下指令的具体解释见这篇博客：<a href="http://lihengxu.cn/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">HEXO框架 个人博客搭建</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览<br>hexo d # 部署到github<br></code></pre></td></tr></table></figure><blockquote><p>参考资料：<br>[1]  <a href="https://my.oschina.net/leonadmin/blog/4315110">https://my.oschina.net/leonadmin/blog/4315110</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p><strong>基于<a href="https://www.bilibili.com/video/BV12b411K7Zu">尚硅谷MySQL视频</a>的学习笔记</strong></p><h2 id="1-初识MySQL"><a href="#1-初识MySQL" class="headerlink" title="1. 初识MySQL"></a>1. 初识MySQL</h2><h3 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h3><ul><li>数据库的常见概念 ★<br>1、DB：数据库，存储数据的容器<br>2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br>3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</li><li>数据库存储数据的特点<br>1、数据存放到表中，然后表再放到库中<br>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br>3、表中有一个或多个列，<strong>列</strong>又称为“<strong>字段</strong>”，相当于java中“<strong>属性</strong>”<br>4、表中的<strong>每一行数据</strong>，相当于java中“<strong>对象</strong>”</li></ul><ul><li>常见的数据库管理系统<br>mysql、oracle、db2、sqlserver</li></ul><h3 id="1-2-MySQL介绍"><a href="#1-2-MySQL介绍" class="headerlink" title="1.2 MySQL介绍"></a>1.2 MySQL介绍</h3><ul><li><p>MySQL的背景<br>前身属于瑞典的一家公司，MySQL AB<br>08年被sun公司收购<br>09年sun被oracle收购</p></li><li><p>MySQL的优点</p><ul><li>开源、免费、成本低</li><li>性能高、移植性也好</li><li>体积小，便于安装</li></ul></li><li><p>MySQL服务的启动和停止</p><ul><li>方式一：通过命令行<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> 服务名<br><span class="hljs-built_in">net</span> stop 服务名<br></code></pre></td></tr></table></figure></li><li>方式二：计算机——右击——管理——服务</li></ul></li></ul><ul><li><p>MySQL服务的登录和退出</p><ul><li><p>登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码<br></code></pre></td></tr></table></figure></li><li><p>退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit 或 ctrl+C<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>MySQL的常见命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.查看当前所有的数据库<br>show databases;<br># 2.打开指定的库<br>use 库名<br># 3.查看当前库的所有表<br>show tables;<br># 4.查看其它库的所有表<br>show tables from 库名;<br># 5.创建表<br>create table 表名(<br>列名 列类型,<br>列名 列类型，<br>...<br>);<br># 6.查看表结构<br>desc 表名;<br># 7.查看服务器的版本<br># 方式一：登录到mysql服务端<br>select version();<br># 方式二：没有登录到mysql服务端<br>mysql --version<br># 或<br>mysql --V<br></code></pre></td></tr></table></figure></li><li><p>MySQL的语法规范</p><ol><li><p>不区分大小写,但建议关键字大写，表名、列名小写</p></li><li><p>每条命令最好用分号结尾</p></li><li><p>每条命令根据需要，可以进行缩进 或换行</p></li><li><p>注释</p><ul><li><p>单行注释：#注释文字</p></li><li><p>单行注释：– 注释文字</p></li><li><p>多行注释：/* 注释文字  */</p></li></ul></li></ol></li><li><p>SQL的语言分类</p><ul><li>DQL（Data Query Language）：数据查询语言<pre><code>    select </code></pre></li><li>DML(Data Manipulate Language):数据操作语言<pre><code>    insert 、update、delete</code></pre></li><li>DDL（Data Define Languge）：数据定义语言<pre><code>    create、drop、alter</code></pre></li><li>TCL（Transaction Control Language）：事务控制语言<pre><code>    commit、rollback</code></pre></li></ul></li></ul><h2 id="2-DQL语言"><a href="#2-DQL语言" class="headerlink" title="2. DQL语言"></a>2. DQL语言</h2><h3 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、查询单个字段<br>select 字段名 from 表名;<br><br># 2、查询多个字段<br>select 字段名，字段名 from 表名;<br><br># 3、查询所有字段<br>select * from 表名;<br><br># 4、查询常量<br># 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要<br>select 常量值;<br><br># 5、查询函数<br>select 函数名(实参列表);<br><br># 6、查询表达式<br>select 100&#x2F;1234;<br><br># 7、起别名<br># ① as<br># ② 空格<br><br># 8、去重<br>select distinct 字段名 from 表名;<br><br># 9、+<br># 作用：做加法运算<br>select 数值+数值;  # 直接运算<br>select 字符+数值;  # 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算<br>select null+值;  # 结果都为null<br><br># 10、【补充】concat函数<br># 功能：拼接字符<br>select concat(字符1，字符2，字符3,...);<br><br># 11、【补充】ifnull函数<br># 功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值<br>select ifnull(commission_pct,0) from employees;<br><br># 12、【补充】isnull函数<br># 功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0<br></code></pre></td></tr></table></figure><h3 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.条件查询的基本结构<br>select 查询列表 from 表名 where 筛选条件<br><br># 2.简单条件运算符<br>&gt; &lt; &#x3D; &lt;&gt; !&#x3D; &gt;&#x3D; &lt;&#x3D;  <br>&lt;&#x3D;&gt;安全等于 # 可以判断null值<br><br># 3. 逻辑运算符<br>&amp;&amp; and<br>|| or<br>!  not<br><br># 4、模糊查询<br>between and # 左右边界不能颠倒顺序<br>between 120 and 100 # 等价于 &gt;&#x3D; 120 &amp;&amp; &lt;&#x3D; 100 <br><br>in (&#39;&#39;, &#39;&#39;) # in列表值类型必须统一,且不支持通配符<br>is null &#x2F;is not null  # 用于判断null值, &#x3D; 不能判断null<br>like  # 一般搭配通配符使用，可以判断字符型或数值型 <br><br># 5.通配符：<br>%：任意多个字符<br>_：任意单个字符<br>通配符转义 \ 或者 &#39;_$_&#39; ESCAPE &#39;$&#39;<br><br><br>普通类型的数值  null值   可读性<br>is null×   √      √<br>&lt;&#x3D;&gt;    √   √      ×<br></code></pre></td></tr></table></figure><p><font color=#FF0000><strong>经典面试题</strong></font> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from employees;<br>select * from employees where name like &#39;%%&#39; and id like &#39;%%&#39;;<br>两个查询语句的执行结果是否相同？<br>解：不一样，若name或者id有null值则查不出来<br></code></pre></td></tr></table></figure><h3 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 排序查询的基本结构<br>select 查询列表<br>from 表<br>where 筛选条件<br>order by 排序列表 [asc&#125;desc]<br><br># 2. 特点<br>&#x2F;*<br>1、asc ：升序，如果不写默认升序<br>   desc：降序<br>2、排序列表 支持 单个字段、多个字段、函数、表达式、别名<br>3、order by的位置一般放在查询语句的最后（除limit语句之外）<br>*&#x2F;<br></code></pre></td></tr></table></figure><h3 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h3><ul><li>功能：类似于java中的方法</li><li>好处：提高重用性和隐藏实现细节</li><li>调用：select 函数名(实参列表);</li></ul><p>单行函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、字符函数<br># concat:连接<br># substr:截取子串，索引从1开始<br># upper:变大写<br># lower：变小写<br># replace：替换<br># length：获取字节长度<br># trim:去前后空格<br># lpad：左填充<br># rpad：右填充<br># instr:获取子串第一次出现的索引<br><br>SELECT LENGTH(&#39;john&#39;);<br>SELECT CONCAT(last_name,&#39;_&#39;,first_name) 姓名 FROM employees;<br>SELECT UPPER(&#39;john&#39;);<br>SELECT LOWER(&#39;joHn&#39;);<br>SELECT <br>CONCAT(UPPER(last_name),LOWER(first_name))  姓名 <br>FROM employees;<br>SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,7)  out_put;<br>SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;<br>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2)))  out_put<br>FROM employees;<br>SELECT INSTR(&#39;杨不殷六侠悔爱上了殷六侠&#39;,&#39;殷八侠&#39;) AS out_put;<br>SELECT LENGTH(TRIM(&#39;    张翠山    &#39;)) AS out_put;<br>SELECT TRIM(&#39;aa&#39; FROM &#39;aaaaaa张aaaa翠山aaaaa&#39;) AS out_put;<br>SELECT LPAD(&#39;殷素素&#39;,2,&#39;*&#39;) AS out_put;<br>SELECT RPAD(&#39;殷素素&#39;,12,&#39;ab&#39;) AS out_put;<br>SELECT REPLACE(&#39;周芷若周芷若张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;<br><br># 2、数学函数<br># ceil:向上取整<br># round：四舍五入<br># mod:取模<br># floor：向下取整<br># truncate:截断<br># rand:获取随机数，返回0-1之间的小数<br>SELECT ROUND(-1.55);<br>SELECT ROUND(1.567,2);<br>SELECT CEIL(-1.02);<br>SELECT FLOOR(-9.99);<br>SELECT TRUNCATE(1.69999,1);<br>#mod取余<br>&#x2F;*<br>mod(a,b) ：  a-a&#x2F;b*b<br>mod(-10,-3):-10- (-10)&#x2F;(-3)*（-3）&#x3D;-1<br>*&#x2F;<br>SELECT MOD(10,-3);<br>SELECT 10%3;<br><br># 3、日期函数<br># now：返回当前日期+时间<br># year:返回年<br># month：返回月<br># day:返回日<br># date_format:将日期转换成字符<br># curdate:返回当前日期<br># str_to_date:将字符转换成日期<br># curtime：返回当前时间<br># hour:小时<br># minute:分钟<br># second：秒<br># datediff:返回两个日期相差的天数<br># monthname:以英文形式返回月<br>SELECT NOW();<br>SELECT CURDATE();<br>SELECT CURTIME();<br>SELECT YEAR(NOW()) 年;<br>SELECT YEAR(&#39;1998-1-1&#39;) 年;<br>SELECT  YEAR(hiredate) 年 FROM employees;<br>SELECT MONTH(NOW()) 月;<br>SELECT MONTHNAME(NOW()) 月;<br>SELECT STR_TO_DATE(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) AS out_put;<br>#查询入职日期为1992--4-3的员工信息<br>SELECT * FROM employees WHERE hiredate &#x3D; &#39;1992-4-3&#39;;<br>SELECT * FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);<br>SELECT DATE_FORMAT(NOW(),&#39;%y年%m月%d日&#39;) AS out_put;<br>#查询有奖金的员工名和入职日期(xx月&#x2F;xx日 xx年)<br>SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月&#x2F;%d日 %y年&#39;) 入职日期<br>FROM employees<br>WHERE commission_pct IS NOT NULL;<br><br># 4、其他函数<br># version 当前数据库服务器的版本<br># database 当前打开的数据库<br># user当前用户<br># password(&#39;字符&#39;)：返回该字符的密码形式<br># md5(&#39;字符&#39;):返回该字符的md5加密形式<br>SELECT VERSION();<br>SELECT DATABASE();<br>SELECT USER();<br><br>#5、流程控制函数<br>&#x2F;*<br>①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2<br>②case情况1<br>case 变量或表达式或字段<br>when 常量1 then 值1<br>when 常量2 then 值2<br>...<br>else 值n<br>end<br><br>③case情况2<br>case <br>when 条件1 then 值1<br>when 条件2 then 值2<br>...<br>else 值n<br>end<br>*&#x2F;<br>SELECT IF(10&lt;5,&#39;大&#39;,&#39;小&#39;);<br><br>SELECT salary 原始工资,department_id,<br>CASE department_id<br>WHEN 30 THEN salary*1.1<br>WHEN 40 THEN salary*1.2<br>WHEN 50 THEN salary*1.3<br>ELSE salary<br>END AS 新工资<br>FROM employees;<br><br>SELECT salary,<br>CASE <br>WHEN salary&gt;20000 THEN &#39;A&#39;<br>WHEN salary&gt;15000 THEN &#39;B&#39;<br>WHEN salary&gt;10000 THEN &#39;C&#39;<br>ELSE &#39;D&#39;<br>END AS 工资级别<br>FROM employees;<br></code></pre></td></tr></table></figure><p>分组函数(统计函数\聚合函数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.分类<br>max 最大值<br>min 最小值<br>sum 和<br>avg 平均值<br>count 计算个数<br><br># 2.简单 的使用<br>SELECT SUM(salary) FROM employees;<br>SELECT AVG(salary) FROM employees;<br>SELECT MIN(salary) FROM employees;<br>SELECT MAX(salary) FROM employees;<br>SELECT COUNT(salary) FROM employees;<br><br><br>SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;<br><br>SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数<br>FROM employees;<br><br># 3、参数支持哪些类型<br># sum和avg一般用于处理数值型<br># max、min、count可以处理任何数据类型<br>SELECT SUM(last_name) ,AVG(last_name) FROM employees;<br>SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;<br>SELECT MAX(last_name),MIN(last_name) FROM employees;<br>SELECT MAX(hiredate),MIN(hiredate) FROM employees;<br>SELECT COUNT(commission_pct) FROM employees;<br>SELECT COUNT(last_name) FROM employees;<br><br># 4、是否忽略null(以上分组函数都忽略)<br>SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)&#x2F;35,SUM(commission_pct)&#x2F;107 FROM employees;<br><br>SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;<br><br>SELECT COUNT(commission_pct) FROM employees;<br>SELECT commission_pct FROM employees;<br><br># 5、和distinct搭配<br>SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;<br>SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;<br><br># 6、count函数的详细介绍<br>count(字段)：统计该字段非空值的个数<br>count(*):统计结果集的行数<br>SELECT COUNT(salary) FROM employees;<br>SELECT COUNT(*) FROM employees;<br>SELECT COUNT(1) FROM employees;<br><br>效率：<br>MYISAM存储引擎下，COUNT(*)的效率高<br>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些<br><br>#6、和分组函数一同查询的字段有限制,要求是group by后出现的字段<br>SELECT AVG(salary),employee_id  FROM employees; # 这个查询没有意义<br></code></pre></td></tr></table></figure><h3 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.分组查询的基本结构<br>select 分组函数，分组后的字段<br>from 表<br>[where 筛选条件]<br>group by 分组的字段<br>[having 分组后的筛选]<br>[order by 排序列表]<br><br># 2.筛选对比<br>使用关键字筛选的表位置<br>分组前筛选where原始表 group by的前面<br>分组后筛选having分组后的结果   group by 的后面<br><br># 3. 常见问题<br>1：分组函数做筛选能不能放在where后面<br>答：不能<br><br>2：where——group by——having<br>答：一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率<br><br>3、分组可以按单个字段也可以按多个字段<br>4、可以搭配着排序使用<br><br># 4. 一些示例<br>#案例1：查询每个工种的员工平均工资<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;<br>#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资<br>SELECT job_id,MAX(salary)<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING MAX(salary)&gt;12000;<br>#案例3：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序<br>SELECT job_id,MAX(salary) m<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING m&gt;6000<br>ORDER BY m ;<br>#案例4：查询每个工种每个部门的最低工资,并按最低工资降序<br>SELECT MIN(salary),job_id,department_id<br>FROM employees<br>GROUP BY department_id,job_id<br>ORDER BY MIN(salary) DESC;<br></code></pre></td></tr></table></figure><h3 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.连接查询的含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询<br>    笛卡尔乘积现象：表1 有m行，表2有n行，结果&#x3D;m*n行<br>    发生原因：没有有效的连接条件<br>    如何避免：添加有效的连接条件<br><br># 2.分类：<br># 按年代分类：<br>sql92标准:仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br><br># 按功能分类：<br>内连接：<br>等值连接<br>非等值连接<br>自连接<br>外连接：<br>左外连接<br>右外连接<br>全外连接<br><br>交叉连接<br><br># 3. SQL92语法<br># 等值连接<br>select 查询列表<br>from 表1 别名,表2 别名<br>where 表1.key&#x3D;表2.key<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br>① 一般为表起别名<br>② 多表的顺序可以调换<br>③ n表连接至少需要n-1个连接条件<br>④ 等值连接的结果是多表的交集部分<br><br><br># 非等值连接<br>select 查询列表<br>from 表1 别名,表2 别名<br>where 非等值的连接条件<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br># 自连接<br>select 查询列表<br>from 表 别名1,表 别名2<br>where 等值的连接条件<br>【and 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选】<br>【order by 排序字段】<br><br><br># 4.SQL99语法<br>    # 内连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    【inner】 join 表2 别名 on 连接条件<br>    where 筛选条件<br>    group by 分组列表<br>    having 分组后的筛选<br>    order by 排序列表<br>    limit 子句;<br>    - 特点：<br>    ① 表的顺序可以调换<br>    ② 内连接的结果&#x3D;多表的交集<br>    ③ n表连接至少需要n-1个连接条件<br>    - 分类：<br>    等值连接<br>    非等值连接<br>    自连接<br><br>    # 外连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    left|right|full【outer】 join 表2 别名 on 连接条件<br>    where 筛选条件<br>    group by 分组列表<br>    having 分组后的筛选<br>    order by 排序列表<br>    limit 子句;<br>    - 特点：<br>    ① 查询的结果&#x3D;主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null<br>    ② left join 左边的就是主表<br>      right join 右边的就是主表<br>      full join 两边都是主表<br>    ③ 一般用于查询除了交集部分的剩余的不匹配的行<br><br>    # 交叉连接<br>    - 语法：<br>    select 查询列表<br>    from 表1 别名<br>    cross join 表2 别名;<br>    - 特点：<br>    类似于笛卡尔乘积<br></code></pre></td></tr></table></figure><h3 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 子查询的含义<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询<br><br># 2. 分类：<br>    # 按子查询出现的位置：<br>        select后面：<br>            仅仅支持标量子查询<br><br>        from后面：<br>            支持表子查询<br>        where或having后面：★<br>            标量子查询（单行） √<br>            列子查询  （多行） √<br>            行子查询<br><br>        exists后面（相关子查询）<br>            表子查询<br><br>    # 按结果集的行列数不同：<br>        标量子查询（结果集只有一行一列）<br>        列子查询（结果集只有一列多行）<br>        行子查询（结果集有一行多列）<br>        表子查询（结果集一般为多行多列）<br><br># 3. 示例<br># 3.1 where或having后面<br>特点：<br>① 子查询放在小括号内<br>② 子查询一般放在条件的右侧<br>③ 标量子查询，一般搭配着单行操作符使用<br>&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;<br>列子查询，一般搭配着多行操作符使用<br>in、any&#x2F;some、all<br><br>④ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果<br><br>    # 标量子查询<br>    案例：查询最低工资的员工姓名和工资<br>    ① 最低工资<br>    select min(salary) from employees<br>    ② 查询员工的姓名和工资，要求工资&#x3D;①<br>    select last_name,salary<br>    from employees<br>    where salary&#x3D;(<br>        select min(salary) from employees<br>    );<br><br>    # 列子查询 ★<br>    案例：查询所有是领导的员工姓名<br>    ① 查询所有员工的 manager_id<br>    select manager_id<br>    from employees<br>    ② 查询姓名，employee_id属于①列表的一个<br>    select last_name<br>    from employees<br>    where employee_id in(<br>        select manager_id<br>        from employees<br>    );<br>    <br>    # 行子查询（了解）<br>案例：查询员工编号最小并且工资最高的员工信息<br>    SELECT * <br>    FROM employees<br>    WHERE (employee_id,salary)&#x3D;(<br>        SELECT MIN(employee_id),MAX(salary)<br>        FROM employees<br>    );<br>    ① 查询最小的员工编号<br>    SELECT MIN(employee_id)<br>    FROM employees<br>② 查询最高工资<br>    SELECT MAX(salary)<br>    FROM employees<br>    ③ 查询员工信息<br>    SELECT *<br>    FROM employees<br>    WHERE employee_id&#x3D;(<br>        SELECT MIN(employee_id)<br>        FROM employees<br>    )AND salary&#x3D;(<br>        SELECT MAX(salary)<br>        FROM employees<br>    );<br>    <br># 3.2 select后面<br>仅仅支持标量子查询<br>    #案例：查询每个部门的员工个数<br>    SELECT d.*,(<br>        SELECT COUNT(*)<br>        FROM employees e<br>        WHERE e.department_id &#x3D; d.&#96;department_id&#96;<br>     ) 个数<br>     FROM departments d;<br><br><br># 3.3 from后面<br>将子查询结果充当一张表，要求必须起别名<br>    #案例：查询每个部门的平均工资的工资等级<br>    ① 查询每个部门的平均工资<br>    SELECT AVG(salary),department_id<br>    FROM employees<br>    GROUP BY department_id<br>    SELECT * FROM job_grades;<br><br>    ② 连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal<br>    SELECT  ag_dep.*,g.&#96;grade_level&#96;<br>    FROM (<br>        SELECT AVG(salary) ag,department_id<br>        FROM employees<br>        GROUP BY department_id<br>    ) ag_dep<br>    INNER JOIN job_grades g<br>    ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;<br><br><br># 3.4 exists后面（相关子查询）<br>语法：<br>exists(完整的查询语句)<br>结果：<br>1或0<br><br>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary&#x3D;300000);<br><br>    #案例：查询有员工的部门名<br>    #in<br>    SELECT department_name<br>    FROM departments d<br>    WHERE d.&#96;department_id&#96; IN(<br>        SELECT department_id<br>        FROM employees<br>    )<br>    #exists<br>    SELECT department_name<br>    FROM departments d<br>    WHERE EXISTS(<br>        SELECT *<br>        FROM employees e<br>        WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;<br>    );<br></code></pre></td></tr></table></figure><h3 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 分页查询<br>select 查询列表<br>from 表<br>[join type join 表2<br>on 连接条件<br>where 筛选条件<br>group by 分组字段<br>having 分组后的筛选<br>order by 排序的字段]<br>limit [offset，] size;<br><br># 2. 注意<br>offset代表的是起始的条目索引，默认从0开始<br>size代表的是显示的条目数<br><br># 3. 公式<br>假如要显示的页数为page，每一页条目数为size<br>select 查询列表<br>from 表<br>limit (page-1)*size,size;<br></code></pre></td></tr></table></figure><h3 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 联合查询: 将多条查询语句的结果合并成一个结果<br>查询语句1<br>union<br>查询语句2<br>union<br>...<br><br># 2. 应用场景：<br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时<br><br># 3. 特点：★<br>3.1 要求多条查询语句的查询列数是一致的！<br>3.2 要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.3 union关键字默认去重，如果使用union all 可以包含重复项<br><br># 4.案例：查询部门编号&gt;90或邮箱包含a的员工信息<br>SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;;<br>SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;<br>UNION<br>SELECT * FROM employees  WHERE department_id&gt;90;<br></code></pre></td></tr></table></figure><h3 id="2-10-查询语句总结"><a href="#2-10-查询语句总结" class="headerlink" title="2.10 查询语句总结"></a>2.10 查询语句总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法以及执行顺序<br>select 查询列表    ⑦<br>from 表1 别名       ①<br>连接类型 join 表2   ②<br>on 连接条件         ③<br>where 筛选          ④<br>group by 分组列表   ⑤<br>having 筛选         ⑥<br>order by排序列表    ⑧<br>limit 起始条目索引，条目数;  ⑨<br></code></pre></td></tr></table></figure><h2 id="3-DML语言"><a href="#3-DML语言" class="headerlink" title="3. DML语言"></a>3. DML语言</h2><blockquote><p>数据操作语言：</p><p>插入：insert</p><p>修改：update</p><p>删除：delete</p></blockquote><h3 id="3-1-插入语句"><a href="#3-1-插入语句" class="headerlink" title="3.1 插入语句"></a>3.1 插入语句</h3><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法<br>insert into 表名(列名) values(值1,...);<br><br># 1.插入的值的类型要与列的类型一致或兼容<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br><br># 2.不可以为null的列必须插入值。可以为null的列如何插入值？<br># 2.1：<br>INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<br>VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br># 2.2：<br>INSERT INTO beauty(id,NAME,sex,phone)<br>VALUES(15,&#39;娜扎&#39;,&#39;女&#39;,&#39;1388888888&#39;);<br><br># 3.列的顺序是否可以调换<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);<br><br># 4.列数和值的个数必须一致<br>INSERT INTO beauty(NAME,sex,id,phone)<br>VALUES(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);<br><br># 5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致<br>INSERT INTO beauty<br>VALUES(18,&#39;张飞&#39;,&#39;男&#39;,NULL,&#39;119&#39;,NULL,NULL);<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br>insert into 表名<br>set 列名&#x3D;值,列名&#x3D;值,...<br><br># 示例<br>INSERT INTO beauty<br>SET id&#x3D;19, NAME&#x3D;&#39;刘涛&#39;, phone&#x3D;&#39;999&#39;;<br></code></pre></td></tr></table></figure><p>对比两种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、方式一支持插入多行,方式二不支持<br>INSERT INTO beauty<br>VALUES(23,&#39;唐艺昕1&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)<br>,(24,&#39;唐艺昕2&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)<br>,(25,&#39;唐艺昕3&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);<br><br># 2、方式一支持子查询，方式二不支持<br>INSERT INTO beauty(id,NAME,phone)<br>SELECT 26,&#39;宋茜&#39;,&#39;11809866&#39;;<br><br>INSERT INTO beauty(id,NAME,phone)<br>SELECT id,boyname,&#39;1234567&#39;<br>FROM boys WHERE id&lt;3;<br></code></pre></td></tr></table></figure><h3 id="3-2-修改语句"><a href="#3-2-修改语句" class="headerlink" title="3.2 修改语句"></a>3.2 修改语句</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.修改单表的记录★<br>update 表名<br>set 列&#x3D;新值,列&#x3D;新值,...<br>where 筛选条件;<br><br># 2.修改多表的记录【补充】<br># sql92语法：<br>update 表1 别名,表2 别名<br>set 列&#x3D;值,...<br>where 连接条件<br>and 筛选条件;<br># sql99语法：<br>update 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br>set 列&#x3D;值,...<br>where 筛选条件;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.修改单表的记录<br>#案例1：修改beauty表中姓唐的女神的电话为13899888899<br>UPDATE beauty SET phone &#x3D; &#39;13899888899&#39;<br>WHERE NAME LIKE &#39;唐%&#39;;<br>#案例2：修改boys表中id好为2的名称为张飞，魅力值 10<br>UPDATE boys SET boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10<br>WHERE id&#x3D;2;<br><br>#2.修改多表的记录<br>#案例 1：修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;<br>SET b.&#96;phone&#96;&#x3D;&#39;119&#39;,bo.&#96;userCP&#96;&#x3D;1000<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;<br>#案例2：修改没有男朋友的女神的男朋友编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;<br>SET b.&#96;boyfriend_id&#96;&#x3D;2<br>WHERE bo.&#96;id&#96; IS NULL;<br>SELECT * FROM boys;<br></code></pre></td></tr></table></figure><h3 id="3-3-删除语句"><a href="#3-3-删除语句" class="headerlink" title="3.3 删除语句"></a>3.3 删除语句</h3><p> 方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、单表的删除【★】<br>delete from 表名 where 筛选条件<br><br># 2、多表的删除【补充】<br># sql92语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名,表2 别名<br>where 连接条件<br>and 筛选条件;<br># sql99语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.单表的删除<br># 案例：删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;<br><br># 2.多表的删除<br># 案例：删除张无忌的女朋友的信息<br>DELETE b<br>FROM beauty b<br>INNER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;<br># 案例：删除黄晓明的信息以及他女朋友的信息<br>DELETE b,bo<br>FROM beauty b<br>INNER JOIN boys bo ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;<br>WHERE bo.&#96;boyName&#96;&#x3D;&#39;黄晓明&#39;;<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br>truncate table 表名;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#案例：将魅力值&gt;100的男神信息删除<br>TRUNCATE TABLE boys ;<br></code></pre></td></tr></table></figure><p><font color=#FF0000><strong>delete 对比 truncate</strong>  [面试题]</font> </p><blockquote><ol><li><p>delete 可以加where 条件，truncate不能加</p></li><li><p>truncate删除，效率高一丢丢</p></li><li><p>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</p></li><li><p>truncate删除没有返回值，delete删除有返回值</p></li><li><p>truncate删除不能回滚，delete删除可以回滚.</p></li></ol></blockquote><h2 id="4-DDL语言"><a href="#4-DDL语言" class="headerlink" title="4. DDL语言"></a>4. DDL语言</h2><p>数据定义语言    –&gt;   库和表的管理</p><blockquote><p>一、库的管理<br>创建、修改、删除</p><p>二、表的管理<br>创建、修改、删除</p></blockquote><p>创建： create<br>修改： alter<br>删除： drop</p><h3 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1、库的创建<br>create database  [if not exists]库名;<br>#案例：创建库Books<br>CREATE DATABASE IF NOT EXISTS books ;<br><br>#2、库的修改<br>RENAME DATABASE books TO 新库名;<br>#更改库的字符集<br>ALTER DATABASE books CHARACTER SET gbk;<br><br>#3、库的删除<br>DROP DATABASE IF EXISTS books;<br></code></pre></td></tr></table></figure><h3 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.表的创建 ★<br># 语法：<br>create table 表名(<br>列名 列的类型【(长度) 约束】,<br>列名 列的类型【(长度) 约束】,<br>列名 列的类型【(长度) 约束】,<br>...<br>列名 列的类型【(长度) 约束】<br>)<br># 案例：创建表Book<br>CREATE TABLE book(<br>id INT,#编号<br>bName VARCHAR(20),#图书名<br>price DOUBLE,#价格<br>authorId  INT,#作者编号<br>publishDate DATETIME#出版日期<br>);<br>DESC book;<br>#案例：创建表author<br>CREATE TABLE IF NOT EXISTS author(<br>id INT,<br>au_name VARCHAR(20),<br>nation VARCHAR(10)<br>)<br>DESC author;<br><br><br># 2.表的修改<br># 语法<br>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;<br># ① 修改列名<br>ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;<br># ② 修改列的类型或约束<br>ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;<br># ③ 添加新列<br>ALTER TABLE author ADD COLUMN annual DOUBLE; <br># ④ 删除列<br>ALTER TABLE book_author DROP COLUMN  annual;<br># ⑤ 修改表名<br>ALTER TABLE author RENAME TO book_author;<br><br><br># 3.表的删除<br>DROP TABLE IF EXISTS book_author;<br>SHOW TABLES;<br># 通用的写法：<br>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;<br>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE  表名();<br><br><br># 4.表的复制<br>INSERT INTO author VALUES<br>(1,&#39;村上春树&#39;,&#39;日本&#39;),<br>(2,&#39;莫言&#39;,&#39;中国&#39;),<br>(3,&#39;冯唐&#39;,&#39;中国&#39;),<br>(4,&#39;金庸&#39;,&#39;中国&#39;);<br><br>SELECT * FROM Author;<br>SELECT * FROM copy2;<br># 1.仅仅复制表的结构<br>CREATE TABLE copy LIKE author;<br># 2.复制表的结构+数据<br>CREATE TABLE copy2 <br>SELECT * FROM author;<br><br># 只复制部分数据<br>CREATE TABLE copy3<br>SELECT id,au_name<br>FROM author <br>WHERE nation&#x3D;&#39;中国&#39;;<br><br># 仅仅复制某些字段<br>CREATE TABLE copy4 <br>SELECT id,au_name<br>FROM author<br>WHERE 0;<br></code></pre></td></tr></table></figure><h3 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h3><blockquote><p>  常见的数据类型</p><ul><li><p>数值型：</p></li><li><p>整型</p></li><li><p>小数：</p><ul><li><p>定点数</p></li><li><p>浮点数</p></li></ul></li><li><p>字符型：</p></li><li><p>较短的文本：char、varchar</p></li><li><p>较长的文本：text、blob（较长的二进制数据）</p></li><li><p>日期型</p></li></ul></blockquote><p><strong>整型</strong></p><ul><li><p>分类：<br>tinyint、smallint、mediumint、int/integer、bigint<br>1              2               3                     4                     8</p></li><li><p>特点：<br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 如何设置无符号和有符号<br>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>t1 INT(7) ZEROFILL,<br>t2 INT(7) ZEROFILL,<br>    t3 INT UNSIGNED<br><br>);<br>DESC tab_int;<br><br><br>INSERT INTO tab_int VALUES(-123456);<br>INSERT INTO tab_int VALUES(-123456,-123456);<br>INSERT INTO tab_int VALUES(2147483648,4294967296);<br>INSERT INTO tab_int VALUES(123,123);<br>SELECT * FROM tab_int;<br></code></pre></td></tr></table></figure><p><strong>小数</strong></p><ul><li><p>分类：</p><ol><li>浮点型<br>float(M,D)<br>double(M,D)</li><li>定点型<br>dec(M，D)<br>decimal(M,D)</li></ol></li><li><p>特点：</p><p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p><p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③</p><p>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p></li><li><p>原则：</p><p>所选择的类型越简单越好，能保存数值的类型越小越好</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#测试M和D<br>CREATE TABLE tab_float(<br>f1 FLOAT,<br>f2 DOUBLE,<br>f3 DECIMAL<br>);<br>SELECT * FROM tab_float;<br>DESC tab_float;<br><br>INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);<br>INSERT INTO tab_float VALUES(123.456,123.456,123.456);<br>INSERT INTO tab_float VALUES(123.4,123.4,123.4);<br>INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);<br></code></pre></td></tr></table></figure><p><strong>字符型</strong></p><ul><li><p>较短的文本：</p><p>char  varchar</p></li><li><p>其他：</p><p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p></li><li><p>较长的文本：<br>text<br>blob(较大的二进制)</p></li><li><p>char/varchar 对比</p></li></ul><table><thead><tr><th></th><th>写法</th><th>M的意思</th><th>特点</th><th>空间的耗费</th><th>效率</th></tr></thead><tbody><tr><td>char</td><td>char(M)</td><td>最大的字符数，可以省略，默认为1</td><td>固定长度的字符</td><td>比较耗费</td><td>高</td></tr><tr><td>varchar</td><td>varchar(M)</td><td>最大的字符数，不可以省略</td><td>可变长度的字符</td><td>比较节省</td><td>低</td></tr></tbody></table><ul><li>enum和set不区分大小写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tab_char(<br>c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)<br>);<br>INSERT INTO tab_char VALUES(&#39;a&#39;);<br>INSERT INTO tab_char VALUES(&#39;b&#39;);<br>INSERT INTO tab_char VALUES(&#39;c&#39;);<br>INSERT INTO tab_char VALUES(&#39;m&#39;);<br>INSERT INTO tab_char VALUES(&#39;A&#39;);<br>SELECT * FROM tab_char;<br><br>CREATE TABLE tab_set(<br>s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)<br>);<br>INSERT INTO tab_set VALUES(&#39;a&#39;);<br>INSERT INTO tab_set VALUES(&#39;A,B&#39;);<br>INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);<br></code></pre></td></tr></table></figure></li></ul><p><strong>日期型</strong></p><ul><li>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</li></ul><p>datetime保存日期+时间<br>timestamp保存日期+时间</p><table><thead><tr><th></th><th>写法</th><th>范围</th><th>时区等的影响</th></tr></thead><tbody><tr><td>datetime</td><td>8</td><td>1000-9999</td><td>不受</td></tr><tr><td>timestamp</td><td>4</td><td>1970-2038</td><td>受</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tab_date(<br>t1 DATETIME,<br>t2 TIMESTAMP<br>);<br>INSERT INTO tab_date VALUES(NOW(),NOW());<br>SELECT * FROM tab_date;<br><br># 查看当前时区<br>SHOW VARIABLES LIKE &#39;time_zone&#39;;<br># 更改时区<br>SET time_zone&#x3D;&#39;+9:00&#39;;<br></code></pre></td></tr></table></figure><h3 id="4-4-常见约束"><a href="#4-4-常见约束" class="headerlink" title="4.4 常见约束"></a>4.4 常见约束</h3><ul><li><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p></li><li><p>分类：六大约束</p><ul><li><p>NOT NULL：<strong>非空</strong>，用于保证该字段的值不能为空</p><pre><code>比如姓名、学号等</code></pre></li><li><p>DEFAULT：<strong>默认</strong>，用于保证该字段有默认值</p><pre><code>比如性别</code></pre></li><li><p>PRIMARY KEY：<strong>主键</strong>，用于保证该字段的值具有<strong>唯一性</strong>，并且<strong>非空</strong></p><pre><code>比如学号、员工编号等</code></pre></li><li><p>UNIQUE：<strong>唯一</strong>，用于保证该字段的值具有<strong>唯一性</strong>，可以为空</p><pre><code>比如座位号</code></pre></li><li><p>CHECK：检查约束【mysql中不支持】</p><pre><code>比如年龄、性别</code></pre></li><li><p>FOREIGN KEY：<strong>外键</strong>，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p><p>​    在<strong>从表添加外键约束</strong>，用于<strong>引用主表</strong>中某列的值<br>​    比如学生表的专业编号，员工表的部门编号，员工表的工种编号<br>​    </p></li></ul></li><li><p>添加约束的时机：</p><pre><code>1.创建表时2.修改表时</code></pre></li><li><p>约束的添加分类：</p><ul><li>列级约束：<br>六大约束语法上都支持，但外键约束没有效果        </li><li>表级约束：<br>除了非空、默认，其他的都支持<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型 列级约束,<br>字段名 字段类型,<br>表级约束<br>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>​    </p><ul><li><font color=#FF0000>主键和唯一的对比【面试题】</font> </li></ul><table><thead><tr><th></th><th>保证唯一性</th><th>是否允许为空</th><th>一个表中可以有多少个</th><th>是否允许组合</th></tr></thead><tbody><tr><td>主键</td><td>√</td><td>×</td><td>至多有1个</td><td>√，但不推荐</td></tr><tr><td>唯一</td><td>√</td><td>√</td><td>可以有多个</td><td>√，但不推荐</td></tr></tbody></table><ul><li><p>外键</p><ul><li><p>要求在从表设置外键关系</p></li><li><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p></li><li><p>主表的关联列必须是一个key（一般是主键或唯一）</p></li><li><p>插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 可以通过以下两种方式来删除主表的记录<br># 方式一：级联删除<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;<br># 方式二：级联置空<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>约束的增删改</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建表时添加约束<br># 1.添加列级约束<br>&#x2F;*<br>语法：<br>直接在字段名和类型后面追加 约束类型即可。<br>只支持：默认、非空、主键、唯一<br>*&#x2F;<br>USE students;<br>DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>id INT PRIMARY KEY,#主键<br>stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>gender CHAR(1) CHECK(gender&#x3D;&#39;男&#39; OR gender &#x3D;&#39;女&#39;),#检查<br>seat INT UNIQUE,#唯一<br>age INT DEFAULT  18,#默认约束<br>majorId INT REFERENCES major(id)#外键(这里外键无效)<br><br>);<br><br>CREATE TABLE major(<br>id INT PRIMARY KEY,<br>majorName VARCHAR(20)<br>);<br><br>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;<br><br><br># 2.添加表级约束<br>&#x2F;*<br>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名) <br>*&#x2F;<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT,<br><br>CONSTRAINT pk PRIMARY KEY(id),#主键<br>CONSTRAINT uq UNIQUE(seat),#唯一键<br>CONSTRAINT ck CHECK(gender &#x3D;&#39;男&#39; OR gender  &#x3D; &#39;女&#39;),#检查<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键<br><br>);<br><br>SHOW INDEX FROM stuinfo;<br><br><br># 通用的写法：★<br>CREATE TABLE IF NOT EXISTS stuinfo(<br>id INT PRIMARY KEY,<br>stuname VARCHAR(20),<br>sex CHAR(1),<br>age INT DEFAULT 18,<br>seat INT UNIQUE,<br>majorid INT,<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br><br>);<br><br><br># 二、修改表时添加约束<br>&#x2F;*<br>1. 添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;<br>2. 添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;<br>*&#x2F;<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT<br>)<br>DESC stuinfo;<br><br># 1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;<br># 2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br># 3.添加主键<br># ①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;<br># ②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);<br># 4.添加唯一<br># ①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;<br># ②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);<br># 5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); <br><br><br># 三、修改表时删除约束<br># 1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;<br># 2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;<br># 3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;<br># 4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;<br># 5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br><br>SHOW INDEX FROM stuinfo;<br></code></pre></td></tr></table></figure><ul><li><p>自增长列(标识列）</p><ul><li><p>含义：可以不用手动的插入值，系统提供默认的序列值</p></li><li><p>特点：</p><blockquote><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？<strong>至多一个</strong>！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p></blockquote></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.创建表时设置标识列<br>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>id INT,<br>NAME FLOAT UNIQUE AUTO_INCREMENT,<br>seat INT <br>);<br>TRUNCATE TABLE tab_identity;<br><br>INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#39;john&#39;);<br>INSERT INTO tab_identity(NAME) VALUES(&#39;lucy&#39;);<br>SELECT * FROM tab_identity;<br><br># 查看自增长相关变量<br>SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;<br># 设置自增长步长(一般要进行修改)<br>SET auto_increment_increment&#x3D;3;<br><br># 2.修改表时设置标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;<br><br># 3.修改表时删除标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT;<br></code></pre></td></tr></table></figure><h3 id="4-5-表与表之间的关系"><a href="#4-5-表与表之间的关系" class="headerlink" title="4.5 表与表之间的关系"></a>4.5 表与表之间的关系</h3><ul><li>一对一</li><li>一对多</li><li>多对多</li></ul><h2 id="5-TCL语言"><a href="#5-TCL语言" class="headerlink" title="5. TCL语言"></a>5. TCL语言</h2><p>Transaction Control Language 事务控制语言</p><h3 id="5-1-事务的含义"><a href="#5-1-事务的含义" class="headerlink" title="5.1 事务的含义"></a>5.1 事务的含义</h3><blockquote><p><strong>事务</strong>：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p></blockquote><h3 id="5-2-事务的特点"><a href="#5-2-事务的特点" class="headerlink" title="5.2 事务的特点"></a>5.2 事务的特点</h3><p><font color=#FF0000>事务的特性：ACID  [面试题]</font>  </p><ul><li>原子性：一个事务不可再分割，要么都执行要么都不执行.</li><li>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态.</li><li>隔离性：一个事务的执行不受其他事务的干扰.</li><li>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</li></ul><blockquote><p>存储引擎:</p><ol><li>概念: 在mysql中的数据用各种不同的技术存储在文件(或者内存)中.</li><li>通过<code>show engines;</code>来查看mysql支持的存储引擎.</li><li>在mysql中用的最多的存储引擎有: innodb, myisam, memory等. 其中innodb支持事务,而myisam和memory不支持事务.</li></ol></blockquote><h3 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h3><ul><li><p>事务的创建</p><ul><li><p>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p><p>​    delete from 表 where id =1;</p></li><li><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用<code>set autocommit=0;</code></p></li></ul></li></ul><ul><li><p>显式事务的使用</p><p>① 开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p><p>② 编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p><p>设置回滚点：<br>savepoint 回滚点名;</p><p>③ 结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p></li><li><p>delete和truncate在事务使用时的区别：</p><ul><li>delete支持回滚</li><li>truncate不支持</li></ul></li></ul><h3 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h3><ul><li><p>事务的并发问题是如何发生的？</p><p>​    多个事务 同时 操作 同一个数据库的相同数据时</p></li><li><p><font color=#FF0000>并发问题都有哪些？</font> </p><ul><li><strong>脏读</strong>：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li><li><strong>不可重复读</strong>：一个事务多次读取，结果不一样</li><li><strong>幻读</strong>：一个事务读取了其他事务还没有提交的数据，只是读到的是其他事务“插入”的数据</li><li><strong>更新丢失</strong>：当两个或者多个事务选择同一行，然后基于最初的选定的值更新该行时，由于每一个事务都不知道其他事务的存在，就会发生更新问题。最后的更新覆盖了其他事务所做的更新。</li></ul></li><li><p>如何解决并发问题</p><p>​    通过设置隔离级别来解决并发问题</p></li><li><p><font color=#FF0000>事务的隔离级别</font>  </p></li></ul><table><thead><tr><th></th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted: 读未提交</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>×</td><td>×</td><td>×</td></tr><tr><td>read committed: 读已提交</td><td>语句级</td><td>√</td><td>×</td><td>×</td></tr><tr><td>repeatable read: 可重复读</td><td>事务级</td><td>√</td><td>√</td><td>×</td></tr><tr><td>serializable: 串行化 (每次读都需获得表级共享锁，读写相互都会阻塞,性能低下)</td><td>最高级别，事务级</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql中默认 第三个隔离级别 <br>repeatable read<br># oracle中默认第二个隔离级别 <br>read committed<br># 查看隔离级别<br>select @@tx_isolation;<br>show variables like &#39;tx_isolation&#39;;<br># 设置隔离级别<br>set session|global transaction isolation level 隔离级别;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.演示事务的使用步骤<br># 开启事务<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br># 编写一组事务的语句<br>UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;<br>UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;<br># 结束事务<br>ROLLBACK; # commit;<br>SELECT * FROM account;<br><br>#2.演示事务对于delete和truncate的处理的区别<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;<br><br>#3.演示savepoint 的使用<br>SET autocommit&#x3D;0;<br>START TRANSACTION;<br>DELETE FROM account WHERE id&#x3D;25;<br>SAVEPOINT a;#设置保存点<br>DELETE FROM account WHERE id&#x3D;28;<br>ROLLBACK TO a;#回滚到保存点<br>SELECT * FROM account;<br></code></pre></td></tr></table></figure><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><blockquote><p><strong>含义</strong>：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据, <strong>只保存了sql逻辑</strong>, 不保存查询结果</p></blockquote><ul><li><p>应用场景:</p><ul><li>多个地方用到相同的查询结果</li><li>该查询结果使用的sql语句比较复杂</li></ul></li><li><p>好处：</p><ul><li>重用sql语句</li><li>简化复杂的sql操作，不必知道它的查询细节</li><li>保护数据，提高安全性（只提供对方需要的信息）</li></ul></li><li><p>创建视图</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 示例：查询姓张的学生名和专业名<br># 1.原始sql语句<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;<br>WHERE s.&#96;stuname&#96; LIKE &#39;张%&#39;;<br># 2.①创建视图<br>CREATE VIEW v1<br>AS<br>SELECT stuname,majorname<br>FROM stuinfo s<br>INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;;<br># 2.②使用视图简化原始sql语句<br>SELECT * FROM v1 WHERE stuname LIKE &#39;张%&#39;;<br></code></pre></td></tr></table></figure><ul><li>修改视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式一：<br>&#x2F;*<br>create or replace view  视图名<br>as<br>查询语句;<br>*&#x2F;<br>SELECT * FROM myv3 <br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;<br><br>#方式二：<br>&#x2F;*<br>语法：<br>alter view 视图名<br>as <br>查询语句;<br>*&#x2F;<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;<br></code></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：drop view 视图名,视图名,...;<br>DROP VIEW emp_v1,emp_v2,myv3;<br></code></pre></td></tr></table></figure><ul><li>查看视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC myv3;<br>SHOW CREATE VIEW myv3;<br></code></pre></td></tr></table></figure><ul><li>更新视图</li></ul><p>视图可以增删改，示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;<br>SELECT * FROM myv1;<br>SELECT * FROM employees;<br>#1.插入<br>INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;);<br>#2.修改<br>UPDATE myv1 SET last_name &#x3D; &#39;张无忌&#39; WHERE last_name&#x3D;&#39;张飞&#39;;<br>#3.删除<br>DELETE FROM myv1 WHERE last_name &#x3D; &#39;张无忌&#39;;<br></code></pre></td></tr></table></figure><p>具备以下特点的视图不允许更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># ① 包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT MAX(salary) m,department_id<br>FROM employees<br>GROUP BY department_id;<br>SELECT * FROM myv1;<br>#更新<br>UPDATE myv1 SET m&#x3D;9000 WHERE department_id&#x3D;10;<br><br># ② 常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS<br>SELECT &#39;john&#39; NAME;<br>SELECT * FROM myv2;<br>#更新<br>UPDATE myv2 SET NAME&#x3D;&#39;lucy&#39;;<br><br><br># ③ Select中包含子查询<br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;<br>#更新<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资&#x3D;100000;<br><br><br># ④ join<br>CREATE OR REPLACE VIEW myv4<br>AS<br>SELECT last_name,department_name<br>FROM employees e<br>JOIN departments d<br>ON e.department_id  &#x3D; d.department_id;<br>#更新<br>SELECT * FROM myv4;<br>UPDATE myv4 SET last_name  &#x3D; &#39;张飞&#39; WHERE last_name&#x3D;&#39;Whalen&#39;;<br>INSERT INTO myv4 VALUES(&#39;陈真&#39;,&#39;xxxx&#39;);<br><br># ⑤ from一个不能更新的视图<br>CREATE OR REPLACE VIEW myv5<br>AS<br>SELECT * FROM myv3;<br>#更新<br>SELECT * FROM myv5;<br>UPDATE myv5 SET 最高工资&#x3D;10000 WHERE department_id&#x3D;60;<br><br># ⑥ where子句的子查询引用了from子句中的表<br>CREATE OR REPLACE VIEW myv6<br>AS<br>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>SELECT  manager_id<br>FROM employees<br>WHERE manager_id IS NOT NULL<br>);<br>#更新<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary&#x3D;10000 WHERE last_name &#x3D; &#39;k_ing&#39;;<br></code></pre></td></tr></table></figure><ul><li>表和视图的对比<table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>create view</td><td>只是保存了sql逻辑</td><td>增删改查，只是一般不能增删改</td></tr><tr><td>表</td><td>create table</td><td>保存了数据</td><td>增删改查</td></tr></tbody></table></li></ul><h3 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h3><ul><li>系统变量：<ul><li>全局变量：</li></ul>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效<ul><li><p>会话变量：</p><p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p></li></ul></li><li>自定义变量：<ul><li>用户变量</li><li>局部变量</li></ul></li></ul><blockquote><ol><li>系统变量</li></ol></blockquote><p><strong>说明</strong>：变量由系统定义，不是用户定义，属于服务器层面<br><strong>注意</strong>：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br><strong>使用步骤</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1、查看所有系统变量<br>show global|【session】variables;<br># 2、查看满足条件的部分系统变量<br>show global|【session】 variables like &#39;%char%&#39;;<br># 3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br># 4、为某个系统变量赋值<br># 方式一：<br>set global|【session】系统变量名&#x3D;值;<br># 方式二：<br>set @@global|【session】系统变量名&#x3D;值;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1》全局变量<br>&#x2F;*<br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>*&#x2F;<br># ① 查看所有全局变量<br>SHOW GLOBAL VARIABLES;<br># ② 查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;<br># ③ 查看指定的系统变量的值<br>SELECT @@global.autocommit;<br># ④ 为某个系统变量赋值<br>SET @@global.autocommit&#x3D;0;<br>SET GLOBAL autocommit&#x3D;0;<br><br>#2》会话变量<br>&#x2F;*<br>作用域：针对于当前会话（连接）有效<br>*&#x2F;<br># ① 查看所有会话变量<br>SHOW SESSION VARIABLES;<br># ② 查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;<br># ③ 查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;<br># ④ 为某个会话变量赋值<br>SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;<br>SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>自定义变量</li></ol></blockquote><p><strong>说明</strong>：变量由用户自定义，而不是系统提供的<br><strong>使用步骤</strong>：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1》用户变量<br>&#x2F;*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*&#x2F;<br># 赋值操作符：&#x3D;或:&#x3D;<br># ① 声明并初始化<br>SET @变量名&#x3D;值;<br>SET @变量名:&#x3D;值;<br>SELECT @变量名:&#x3D;值;<br># ② 赋值（更新变量的值）<br>#方式一：<br>SET @变量名&#x3D;值;<br>SET @变量名:&#x3D;值;<br>SELECT @变量名:&#x3D;值;<br>#方式二：<br>SELECT 字段 INTO @变量名<br>FROM 表;<br># ③ 使用（查看变量的值）<br>SELECT @变量名;<br><br><br># 2》局部变量<br>&#x2F;*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*&#x2F;<br># ① 声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】<br># ② 赋值（更新变量的值）<br>#方式一：<br>SET 局部变量名&#x3D;值;<br>SET 局部变量名:&#x3D;值;<br>SELECT 局部变量名:&#x3D;值;<br>#方式二：<br>SELECT 字段 INTO 具备变量名<br>FROM 表;<br># ③ 使用（查看变量的值）<br>SELECT 局部变量名;<br><br><br># 案例：声明两个变量，求和并打印<br># 用户变量<br>SET @m&#x3D;1;<br>SET @n&#x3D;1;<br>SET @sum&#x3D;@m+@n;<br>SELECT @sum;<br># 局部变量<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM&#x3D;m+n;<br>SELECT SUM;<br></code></pre></td></tr></table></figure><p><strong>用户变量和局部变量的对比</strong>：</p><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><h3 id="6-3-存储过程和函数"><a href="#6-3-存储过程和函数" class="headerlink" title="6.3 存储过程和函数"></a>6.3 存储过程和函数</h3><ul><li>存储过程和函数：类似于java中的方法</li><li>好处：<br>1、提高代码的重用性<br>2、简化操作</li></ul><blockquote><ol><li><strong>存储过程</strong></li></ol></blockquote><p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建语法★<br>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN<br>存储过程体（一组合法的SQL语句）<br>END<br>&#x2F;*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型<br>举例：<br>in stuname varchar(20)<br><br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值,in可以省略<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值<br><br>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*&#x2F;<br><br><br># 二、调用语法<br>CALL 存储过程名(实参列表);<br><br>#----------------------案例演示-------------------------<br># 1.空参列表<br>#案例：插入到admin表中五条记录<br>SELECT * FROM admin;<br>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>INSERT INTO admin(username,&#96;password&#96;) <br>VALUES(&#39;john1&#39;,&#39;0000&#39;),(&#39;lily&#39;,&#39;0000&#39;),(&#39;rose&#39;,&#39;0000&#39;),(&#39;jack&#39;,&#39;0000&#39;),(&#39;tom&#39;,&#39;0000&#39;);<br>END $<br>#调用<br>CALL myp1()$<br><br># 2.创建带in模式参数的存储过程<br>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息<br>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>SELECT bo.*<br>FROM boys bo<br>RIGHT JOIN beauty b ON bo.id &#x3D; b.boyfriend_id<br>WHERE b.name&#x3D;beautyName;<br>END $<br>#调用<br>CALL myp2(&#39;柳岩&#39;)$<br>#案例2 ：创建存储过程实现，用户是否登录成功<br>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>DECLARE result INT DEFAULT 0;#声明并初始化<br>SELECT COUNT(*) INTO result#赋值<br>FROM admin<br>WHERE admin.username &#x3D; username<br>AND admin.password &#x3D; PASSWORD;<br><br>SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用<br>END $<br>#调用<br>CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$<br><br># 3.创建out 模式参数的存储过程<br>#案例1：根据输入的女神名，返回对应的男神名<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>SELECT bo.boyname INTO boyname<br>FROM boys bo<br>RIGHT JOIN<br>beauty b ON b.boyfriend_id &#x3D; bo.id<br>WHERE b.name&#x3D;beautyName ;<br>END $<br>#调用<br>CALL myp7(&#39;小昭&#39;, @name)$<br>SELECT @name$<br>#案例2：根据输入的女神名，返回对应的男神名和魅力值<br>CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) <br>BEGIN<br>SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>FROM boys <br>RIGHT JOIN<br>beauty b ON b.boyfriend_id &#x3D; boys.id<br>WHERE b.name&#x3D;beautyName ;<br>END $<br>#调用<br>CALL myp7(&#39;小昭&#39;, @name, @cp)$<br>SELECT @name,@cp$<br><br># 4.创建带inout模式参数的存储过程<br>#案例1：传入a和b两个值，最终a和b都翻倍并返回<br>CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)<br>BEGIN<br>SET a&#x3D;a*2;<br>SET b&#x3D;b*2;<br>END $<br>#调用<br>SET @m&#x3D;10$<br>SET @n&#x3D;20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$<br><br><br># 三、删除存储过程<br>#语法：drop procedure 存储过程名<br>DROP PROCEDURE p1;<br>DROP PROCEDURE p2,p3;#×<br><br><br># 四、查看存储过程的信息<br>DESC myp2; # 不可以<br>SHOW CREATE PROCEDURE  myp2;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li><strong>函数</strong></li></ol></blockquote><p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><p><strong>区别</strong>：</p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>函数体<br>END<br>&#x2F;*<br>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型<br>2.函数体：<br>肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记<br>*&#x2F;<br><br><br>#二、调用语法<br>SELECT 函数名(参数列表)<br><br>#-----------------案例演示-------------------<br># 1.无参有返回<br>#案例：返回公司的员工个数<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>DECLARE c INT DEFAULT 0;#定义局部变量<br>SELECT COUNT(*) INTO c#赋值<br>FROM employees;<br>RETURN c;<br>END $<br>SELECT myf1()$<br><br># 2.有参有返回<br># 案例1：根据员工名，返回它的工资<br>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>SET @sal&#x3D;0;#定义用户变量 <br>SELECT salary INTO @sal   #赋值<br>FROM employees<br>WHERE last_name &#x3D; empName;<br>RETURN @sal;<br>END $<br>SELECT myf2(&#39;k_ing&#39;) $<br># 案例2：根据部门名，返回该部门的平均工资<br>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>DECLARE sal DOUBLE ;<br>SELECT AVG(salary) INTO sal<br>FROM employees e<br>JOIN departments d ON e.department_id &#x3D; d.department_id<br>WHERE d.department_name&#x3D;deptName;<br>RETURN sal;<br>END $<br>SELECT myf3(&#39;IT&#39;)$<br><br><br>#三、查看函数<br>SHOW CREATE FUNCTION myf3;<br><br><br>#四、删除函数<br>DROP FUNCTION myf3;<br><br># 案例: 创建函数，实现传入两个float，返回二者之和<br>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>DECLARE SUM FLOAT DEFAULT 0;<br>SET SUM&#x3D;num1+num2;<br>RETURN SUM;<br>END $<br>SELECT test_fun1(1,2)$<br></code></pre></td></tr></table></figure><h3 id="6-4-流程控制结构"><a href="#6-4-流程控制结构" class="headerlink" title="6.4  流程控制结构"></a>6.4  流程控制结构</h3><p>顺序、分支、循环</p><blockquote><ol><li>分支结构</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1.if函数<br>&#x2F;*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面<br>*&#x2F;<br><br># 2.case结构<br>&#x2F;*<br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>...<br>else 语句n;<br>end <br>情况2：<br>case <br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>...<br>else 语句n;<br>end <br>- 应用在begin end 中或外面<br>如果放在begin end 外面，作为表达式结合着其他语句使用<br>如果放在begin end 里面，一般作为独立的语句使用<br>- else语句可以省略，如果else省略了，全部when都不满足，则返回null<br><br># 3.if结构<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>....<br>else 语句n;<br>end if;<br>功能：类似于多重if<br>只能应用在begin end 中<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>循环结构</li></ol></blockquote><p><strong>分类</strong>：<br>while、loop、repeat</p><p><strong>循环控制</strong>：</p><p>iterate 【标签】 类似于 continue，继续，结束本次循环，继续下一次<br>leave 【标签】 类似于  break，跳出，结束当前所在的循环</p><p><strong>语法</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E5%9F%BA%E7%A1%80_1_%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png"></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.没有添加循环控制语句<br>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>WHILE i&lt;&#x3D;insertCount DO<br>INSERT INTO admin(username,&#96;password&#96;) VALUES(CONCAT(&#39;Rose&#39;,i),&#39;666&#39;);<br>SET i&#x3D;i+1;<br>END WHILE;<br>END $<br>CALL pro_while1(100)$<br><br>#2.添加leave语句<br>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>a:WHILE i&lt;&#x3D;insertCount DO<br>INSERT INTO admin(username,&#96;password&#96;)<br>VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);<br>IF i&gt;&#x3D;20 THEN LEAVE a;<br>END IF;<br>SET i&#x3D;i+1;<br>END WHILE a;<br>END $<br>CALL test_while1(100)$<br><br>#3.添加iterate语句<br>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>a:WHILE i&lt;&#x3D;insertCount DO<br>SET i&#x3D;i+1;<br>IF MOD(i,2)!&#x3D;0 THEN ITERATE a;<br>END IF;<br><br>INSERT INTO admin(username,&#96;password&#96;)<br>VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);<br>END WHILE a;<br>END $<br>CALL test_while1(100)$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo图床</title>
    <link href="/2021/03/07/PicGo/"/>
    <url>/2021/03/07/PicGo/</url>
    
    <content type="html"><![CDATA[<h1 id="PicGo图床"><a href="#PicGo图床" class="headerlink" title="PicGo图床"></a>PicGo图床</h1><h2 id="1-下载PicGo"><a href="#1-下载PicGo" class="headerlink" title="1. 下载PicGo"></a>1. 下载PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h2 id="2-安装PicGo"><a href="#2-安装PicGo" class="headerlink" title="2. 安装PicGo"></a>2. 安装PicGo</h2><p>直接运行.exe</p><h2 id="3-新建一个github仓库"><a href="#3-新建一个github仓库" class="headerlink" title="3. 新建一个github仓库"></a>3. 新建一个github仓库</h2><p>mycdn</p><h2 id="4-生成token"><a href="#4-生成token" class="headerlink" title="4.生成token"></a>4.生成token</h2><p>[进入github] -&gt; [点击头像] -&gt; [settings] -&gt; [Developers settings] -&gt; [Personal access token]</p><blockquote><p> 必须勾选repo</p></blockquote><p>生成后必须复制token，只显示一次</p><blockquote><p>0cb447c7cb66f97f8dd645d1b30f88b3bda94198</p></blockquote><h2 id="5-配置PicGo"><a href="#5-配置PicGo" class="headerlink" title="5. 配置PicGo"></a>5. 配置PicGo</h2><p>打开PicGo左栏依次选择[图床设置] -&gt; [github图床]</p><p>格式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">仓库名： 你的用户名/仓库名<br>分支： main<br>Token： <span class="hljs-number">0</span>cb447c7cb66f97f8dd645d1b30f88b3bda94198<br>存储路径： img/  <span class="hljs-comment"># 表示上传到你的仓库的img目录下</span><br>自定义域名格式： https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>LihengXu/mycdn<br></code></pre></td></tr></table></figure><p>因为github的服务器在国外，所以用来当图床的时候，国内的速度非常感人，但是我们可以使用<code>jsdelivr</code>提供的CDN服务，速度非常的快，基本不大的图片可以秒开。</p><p>所以上述<strong>自定义域名</strong>实际上是使用的<code>jsdelivr</code>的CDN服务。</p><h2 id="6-上传图片"><a href="#6-上传图片" class="headerlink" title="6. 上传图片"></a>6. 上传图片</h2><p>点击上传区，选择github图床</p><p>示例</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/myfig.png"></p>]]></content>
    
    
    <categories>
      
      <category>PicGo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO框架 个人博客搭建</title>
    <link href="/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/21/HEXO%E6%A1%86%E6%9E%B6%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="HEXO框架-个人博客搭建"><a href="#HEXO框架-个人博客搭建" class="headerlink" title="HEXO框架 个人博客搭建"></a>HEXO框架 个人博客搭建</h1><h2 id="一、-环境搭建"><a href="#一、-环境搭建" class="headerlink" title="一、 环境搭建"></a>一、 环境搭建</h2><h3 id="1-nodejs安装"><a href="#1-nodejs安装" class="headerlink" title="1. nodejs安装"></a>1. nodejs安装</h3><h4 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h4><p>下载地址（选择<strong>LTS</strong>稳定版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><blockquote><p>下载之后直接默认安装，一路next（建议不要放在C盘）</p></blockquote><h4 id="1-2-测试nodejs"><a href="#1-2-测试nodejs" class="headerlink" title="1.2 测试nodejs"></a>1.2 测试nodejs</h4><p>打开windows的命令行工具输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure><p>显示版本号则安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_1_%E6%B5%8B%E8%AF%95nodejs%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h4 id="1-3-测试npm"><a href="#1-3-测试npm" class="headerlink" title="1.3 测试npm"></a>1.3 测试npm</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> npm是nodejs安装时默认安装的</span><br><span class="hljs-meta">#</span><span class="bash"> 直接在windows的命令行工具输入</span><br>npm -v<br></code></pre></td></tr></table></figure><p>显示如下则安装成功, npm管理工具用于安装Hexo框架</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_2_%E6%B5%8B%E8%AF%95npm%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h4 id="1-4-安装nrm（需要一点耐心）"><a href="#1-4-安装nrm（需要一点耐心）" class="headerlink" title="1.4 安装nrm（需要一点耐心）"></a>1.4 安装nrm（需要一点耐心）</h4><blockquote><p> nrm的安装原因：需要切换下载源到国内镜像源，提升下载速度</p></blockquote><ul><li>默认npm的全局安装路径在C盘，我们需要修改到nodejs的安装目录，新建两个文件夹: <code>node_global_modules</code> 和 <code>node_cache</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_3_%E4%BF%AE%E6%94%B9npm%E9%BB%98%E8%AE%A4%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84.png"></p><ul><li><p>在命令行执行以下两条命令修改npm配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set prefix &quot;D:\Java\nodejs\node_modules\npm\node_global_modules&quot;<br>npm config set cache &quot;D:\Java\nodejs\node_modules\npm\node_cache&quot;<br></code></pre></td></tr></table></figure></li><li><p>执行后输入以下命令，查看npm配置结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config ls<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_4_npm%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png"></p><ul><li>验证配置成功后，需要配置环境变量。在环境变量中，新建一个系统变量，变量名：<code>NODE_HOME</code>，变量值：<code>D:\dev\nodejs</code>，效果如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_5_%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE_HOME.png"></p><ul><li><p>在系统环境变量<code>Path</code>变量名中，新建变量值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">NODE_HOME%</span><br><span class="hljs-meta">%</span><span class="bash">NODE_HOME%\node_modules</span><br><span class="hljs-meta">%</span><span class="bash">NODE_HOME%\node_modules\npm\node_global_modules\</span><br></code></pre></td></tr></table></figure></li></ul><p>效果如图（下图第二个路径写错了）：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_6_%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%88%B0path.png"></p><ul><li><p>保存后重新打开命令行工具，执行性全局安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install nrm -g<br></code></pre></td></tr></table></figure><p>安装结束后如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_7_nrm%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C.png"></p></li><li><p>在命令行输入指令查看下载源，可能会报错如下图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nrm ls<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_8_nrm%E6%8A%A5%E9%94%99.png"></p></li><li><p>找到nrm目录(错误第四行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">at Object.&lt;anonymous&gt; (D:\Java\nodejs\node_modules\npm\node_global_modules\node_modules\nrm\cli.js:17:20)<br></code></pre></td></tr></table></figure></li><li><p>打开cli.js 第17行修改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//const NRMRC = path.join(process.env.HOME, &#x27;.nrmrc&#x27;); (删除)</span><br><span class="hljs-keyword">const</span> NRMRC = path.join(process.env[(process.platform == <span class="hljs-string">&#x27;win32&#x27;</span>) ? <span class="hljs-string">&#x27;USERPROFILE&#x27;</span> : <span class="hljs-string">&#x27;HOME&#x27;</span>], <span class="hljs-string">&#x27;.nrmrc&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>重新输入<code>nrm ls</code>查看下载源</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_9_%E6%9F%A5%E7%9C%8Bnrm%E4%B8%8B%E8%BD%BD%E6%BA%90.png"></p></li><li><p>修改下载源指令，推荐选择taobao</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nrm use taobao # 选择淘宝<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-安装Hexo框架"><a href="#2-安装Hexo框架" class="headerlink" title="2. 安装Hexo框架"></a>2. 安装Hexo框架</h3><h4 id="2-1-安装hexo-cli脚手架"><a href="#2-1-安装hexo-cli脚手架" class="headerlink" title="2.1 安装hexo-cli脚手架"></a>2.1 安装hexo-cli脚手架</h4><p>打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装成功如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_10_hexo-cli%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png"></p><h4 id="2-2-验证hexo-cli安装成功"><a href="#2-2-验证hexo-cli安装成功" class="headerlink" title="2.2 验证hexo-cli安装成功"></a>2.2 验证hexo-cli安装成功</h4><p>命令行输入测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_11_hexo-cli%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85.png"></p><h3 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3. 安装Git"></a>3. 安装Git</h3><p>具体可以参考我的<a href="https://lihengxu.github.io/2020/08/21/gitstudy/">Git总结</a></p><h2 id="二、使用Hexo搭建博客"><a href="#二、使用Hexo搭建博客" class="headerlink" title="二、使用Hexo搭建博客"></a>二、使用Hexo搭建博客</h2><h3 id="1-创建项目文件夹"><a href="#1-创建项目文件夹" class="headerlink" title="1. 创建项目文件夹"></a>1. 创建项目文件夹</h3><p>在本地硬盘创建并进入项目文件夹（blog），并在该文件夹下打开命令行工具</p><h3 id="2-初始化blog项目"><a href="#2-初始化blog项目" class="headerlink" title="2. 初始化blog项目"></a>2. 初始化blog项目</h3><p>使用hexo命令初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>初始化项目文件如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_12_blog%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6.png"></p><h3 id="3-运行hexo服务预览博客"><a href="#3-运行hexo服务预览博客" class="headerlink" title="3. 运行hexo服务预览博客"></a>3. 运行hexo服务预览博客</h3><p>在当前路径下输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>命令行出现访问路径，直接点击访问即可</p><p>默认样式如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/hexo%E6%90%AD%E5%BB%BA_13_hexo%E5%8D%9A%E5%AE%A2%E9%A2%84%E8%A7%88.png"></p><h3 id="4-创建文章"><a href="#4-创建文章" class="headerlink" title="4. 创建文章"></a>4. 创建文章</h3><p>在当前路径下输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo n &#x27;hexo test&#x27;<br></code></pre></td></tr></table></figure><p>回车后出现以标题命名的.md文件路径，打开该文件编辑文章内容</p><h3 id="5-更新文章"><a href="#5-更新文章" class="headerlink" title="5. 更新文章"></a>5. 更新文章</h3><p>命令行输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览博客<br></code></pre></td></tr></table></figure><h2 id="三、-博客部署到GitHub"><a href="#三、-博客部署到GitHub" class="headerlink" title="三、 博客部署到GitHub"></a>三、 博客部署到GitHub</h2><h3 id="1-登陆GitHub创建仓库"><a href="#1-登陆GitHub创建仓库" class="headerlink" title="1. 登陆GitHub创建仓库"></a>1. 登陆GitHub创建仓库</h3><p>创建仓库命：LihengXu.github.io (注意第一个.前面一定是账户名)</p><h3 id="2-在本地目录安装git部署插件"><a href="#2-在本地目录安装git部署插件" class="headerlink" title="2. 在本地目录安装git部署插件"></a>2. 在本地目录安装git部署插件</h3><p>在项目根目录下打开命令行工具输入如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-deployer-git # --save 表示只在本目录下安装<br></code></pre></td></tr></table></figure><h3 id="3-修改项目根目录下的配置文件"><a href="#3-修改项目根目录下的配置文件" class="headerlink" title="3. 修改项目根目录下的配置文件"></a>3. 修改项目根目录下的配置文件</h3><p>找到<code>_config.yaml</code>文件</p><p>找到最下面的<code>deploy：type</code> 进行编辑:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/LihengXu/LihengXu.github.io.git</span> <br>  <span class="hljs-comment"># repo : github上创建的仓库地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><blockquote><p>上面的repo：建议使用ssh并绑定公钥， 详细见如何<a href="https://lihengxu.github.io/2020/08/21/Git/#%E4%BD%BF%E7%94%A8%E7%A0%81%E4%BA%91gitee">GIt：使用码云gitee</a>（gitee和github操作没有区别）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:LihengXu/LihengXu.github.io.git</span><br></code></pre></td></tr></table></figure><h3 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4. 部署到GitHub"></a>4. 部署到GitHub</h3><p>项目根目录下打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>提示你输入GitHub账户和密码后将代码提交到GitHub仓库</p><p>通过<a href="https://lihengxu.github.io/">GitHub链接</a>可访问博客</p><h2 id="四、-更换主题"><a href="#四、-更换主题" class="headerlink" title="四、 更换主题"></a>四、 更换主题</h2><h3 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h3><p>将主题文件下载到本地项目的<code>theme</code>文件夹</p><p>在本地项目根目录下打开命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><h3 id="2-修改配置-config-yml"><a href="#2-修改配置-config-yml" class="headerlink" title="2. 修改配置 _config.yml"></a>2. 修改配置 _config.yml</h3><p>找到<code>#Extensions</code>项的theme</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><p><a href="https://hexo.fluid-dev.com/docs/start/">fluid主题使用指南</a>，可以进一步自定义更多设置</p><h3 id="3-更新并重新部署"><a href="#3-更新并重新部署" class="headerlink" title="3. 更新并重新部署"></a>3. 更新并重新部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean # 清理缓存<br>hexo g # 解析生成<br>hexo s # 运行hexo服务预览<br>hexo d # 部署到github<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用</title>
    <link href="/2020/08/21/Git/"/>
    <url>/2020/08/21/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git初步使用"><a href="#Git初步使用" class="headerlink" title="Git初步使用"></a>Git初步使用</h1><p><strong>前言</strong>：用了比较长时间的github了，一直都不能把git理清楚，于是决定整理一下git的学习笔记，供自己梳理和回顾。</p><p><strong>说明</strong>：这里思路是B站up狂神的git教学<a href="https://www.bilibili.com/video/BV1FE411P7B3?p=1">狂神聊Git</a>，给大家安利一下这个up，他许多视频都很不错。</p><hr><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote><p><strong>版本控制</strong>  版本迭代的版本管理器(Revision control)</p></blockquote><p>尤其在多人开发中，使用版本控制尤为重要</p><blockquote><p><strong>常见的版本控制工具</strong></p></blockquote><p>主流的版本控制器有：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong> (subversion)</li><li><strong>CVS</strong> (Concurrent Version System)</li><li><strong>VSS</strong> (Micorosoft Visual SourceSafe)</li><li><strong>TFS</strong> (Team Foudation Server)</li><li>Visual Studio Online</li></ul><p>现在影响力最大也是使用最广泛的是<strong>Git</strong>和<strong>SVN</strong></p><blockquote><p><strong>版本控制分类</strong></p></blockquote><ol><li><p><strong>本地版本控制</strong></p><p>记录文件每次更新，可以对每个版本做一个快照，或者是记录补丁文件，适用于个人，如RCS。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_1_%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p></li><li><p><strong>集中版本控制</strong></p><p>所有版本数据都保存在服务器上，协同开发者从服务器上同步更新或者上传自己的修改。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_2_%E9%9B%86%E4%B8%AD%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p><p>所有的版本数据保存在服务器上，用户本地只有自己的以前所同步的版本，如果不联网，用户看不到历史版本，也午饭切换版本验证问题，或者不同分支工作。而且，所有有数据都保存在单一服务器上，一旦服务器损坏就会丢失所有数据，需要定期备份。代表有：<strong>SVN CVS VSS</strong></p></li><li><p><strong>分布式版本控制</strong></p><p>所有版本星信息全部同步到本地的每一个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需要在连网时push到相应的服务器或者其他用户那里。由于每一个用户保存的都是所有的版本数据，只要有一个用户设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_3_%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.png"></p></li></ol><blockquote><p><strong>Git和SVN的区别</strong></p></blockquote><p><strong>SVN</strong>是集中式版本控制系统，版本库集中放在中央服务器的，而工作的时候，用自己电脑首先要从重要服务器得到最新版本，然后工作，完成工作后需要推送到中央服务器。集中实版本控制系统必须联网才能工作，对网络带宽要求较高</p><p><strong>Git</strong>是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。协同方式：你在电脑上修改了文件A，其他人也修改了文件A，你们俩只需要把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到。</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p><strong>GIt</strong>是Linux社区 (特别是Linux的缔造者<strong>Linus Torvalds</strong>) 基于使用<strong>BitKeeper</strong>时的经验教训，开发出的自己的版本系统。大约花了<strong>两周左右</strong>，也就是后来的<strong>Git</strong>。</p><p><strong>Git</strong>是免费的、开源的、最初Git是为辅助Linux内核开发的，来代替BitKeeper。</p><h2 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h2><blockquote><p><strong>Git下载</strong></p></blockquote><p>打开官网<a href="https://git-scm.com/">git官网</a>，下载git对应操作系统的版本</p><p>下载过慢就是用镜像下载<a href="http://npm.taobao.org/mirrors/git-for-windows/">淘宝镜像</a></p><blockquote><p><strong>Git卸载</strong></p></blockquote><p>直接反安装即可、清理环境变量</p><blockquote><p><strong>Git安装</strong></p></blockquote><p>无脑下一步安装即可。</p><blockquote><p><strong>启动Git</strong></p></blockquote><p>安装成功后开始菜单会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_4_git%E9%80%89%E9%A1%B9.png"></p><p><strong>Git Bash</strong>:  Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD</strong>:  Windows风格的命令行</p><p><strong>GIt GUI</strong>:  图形界面的GIt，不建议初学者使用，尽量先熟悉常用的命令</p><blockquote><p><strong>基本的Linux命令</strong></p></blockquote><ol><li><p><strong>cd</strong> 改变目录</p></li><li><p><strong>cd ..</strong> 回退到上一个目录，直接cd进入默认目录</p></li><li><p><strong>pwd</strong> 显示当前目录路径</p></li><li><p><strong>ls(ll)</strong> 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更加详细</p></li><li><p><strong>touch</strong> 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p></li><li><p><strong>rm</strong> 删除一个文件，rm index.js 就会把index.js删除掉</p></li><li><p><strong>mkdir</strong> 新建一个目录，就是新建一个文件夹</p></li><li><p><strong>rm -r</strong> 删除一个文件夹，rm -r src 删除src目录</p><p>切勿随意在Linux系统中使用<strong>rm -rf /</strong> ，会从根目录全部递归删除，那么会删除电脑中全部文件。</p></li><li><p><strong>mv</strong> 移动文件，mv index.html src index.html 是我们要移动的文件，src是目标文件夹，这么写必须在同一目录下。</p></li><li><p><strong>reset</strong> 重新初始化终端/清屏</p></li><li><p><strong>clear</strong> 清屏</p></li><li><p><strong>history</strong> 查看命令历史</p></li><li><p><strong>help</strong> 帮助</p></li><li><p><strong>exit</strong> 退出</p></li><li><p>**#**表示注释</p></li></ol><blockquote><p><strong>Git配置</strong></p></blockquote><p>查看配置 <strong>git config -l</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_5_git%E9%85%8D%E7%BD%AE.png"></p><p>查看不同级别的配置文件 (都保存在本地) ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统config</span><br>git config --system --list<br><br><span class="hljs-comment"># 查看当前用户(global)配置</span><br>git config --global --list<br></code></pre></td></tr></table></figure><p><strong>Git相关的配置文件：</strong></p><ol><li>Git\etc\gitconfig : Git 安装目录下的gitconfig –system 系统级</li><li>C:\UsersAdminstrator\ .gitconfig 只适用于当前登录用户配置 –global 全局</li></ol><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里</p><blockquote><p><strong>配置用户名与邮箱 (用户标识，必要)</strong></p></blockquote><p>当你安装git后首先要设置你的用户名和e-mail地址。这非常重要，每次git提交都会使用该信息。它会被永远嵌入到你的提交中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;lihengxu&quot;</span> <span class="hljs-comment"># 名称</span><br>git config --global user.email 15882320389@163.com <span class="hljs-comment"># 邮箱</span><br></code></pre></td></tr></table></figure><p>只需要设置一次，只要传递了–global选项，Git将总会使用该信息来处理你在系统中的一切处理。如果你希望在一个特定的项目中使用不同的名称或email地址，你可以在该项目运行该命令而不要–global选项。总之–global为全局配置，不加为某一个项目的特定配置。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_6_git%E9%85%8D%E7%BD%AE--global.png"></p><h2 id="Git基本理论-核心"><a href="#Git基本理论-核心" class="headerlink" title="Git基本理论 (核心)"></a>Git基本理论 (核心)</h2><blockquote><p><strong>工作区域</strong></p></blockquote><p>Git本地有三个工作区域：</p><ol><li>工作目录(Working Direcitory)</li><li>暂存区(Stage/Index)</li><li>资源区(Repository 或 GIt Directory)</li></ol><p>如果加上远程的</p><ol start="4"><li>Git仓库(Remote Directory)</li></ol><p>就可以分为4个工作区域，转换关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_7_git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F.png"></p><ul><li><strong>Workspace</strong>: 工作区，就是平时你存放项目代码的地方</li><li><strong>Index/Stage</strong>： 暂存区，用于平时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li><strong>Repository</strong>：仓库区(或者本地仓库)， 就是安全存放数据的位置，这里面有你提交的所有版本数据。其中HEAD指向最新放入仓库的版本。</li><li><strong>Remote</strong>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</li></ul><p>本地三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_8_HEAD%E6%8C%87%E5%90%91%E7%9A%84%E7%89%88%E6%9C%AC.png"></p><ul><li><strong>Directory</strong>：使用GIt管理的目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li><strong>WorkSpace</strong>：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间</li><li><strong>.git</strong>：存放管理信息的目录，初始化仓库的时候自动创建。</li><li><strong>Index/Stage</strong>：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li><strong>Local Repo</strong>：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支(branch)。</li><li><strong>Stash</strong>：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><blockquote><p><strong>工作流程</strong></p></blockquote><p>git的工作流程一般是这样的：</p><ol><li>在工作目录中添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；</li><li>将暂存区域的文件提交到git仓库。</li></ol><p>因此，git管理文件有三种状态：已修改(modified)、已暂存(staged)、已提交(committed)</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_9_git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><blockquote><p>创建工程目录与常用指令</p></blockquote><p>工作目录(WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你的项目的目录，也可以是一个空目录，建议不要有中文，日常使用一下图中6个命令：</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_10_git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库有两种方法：一种是创建一个全新仓库，另一种是克隆远程仓库。</p><ol><li><p>创建全新仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前目录中新建一个Git代码库</span><br>$ git init<br></code></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目中多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p></li></ol><blockquote><p>克隆远程仓库</p></blockquote><ol><li><p>另一种方式是克隆远程目录，也就是将远程服务器上的仓库完全镜像一份到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆一个项目和它整个历史代码(版本信息)</span><br>$ git <span class="hljs-built_in">clone</span> https://github.com/LihengXu/WPS_Apolloscape.git<br></code></pre></td></tr></table></figure></li><li><p>去gitee或者github上克隆一个测试</p></li></ol><h2 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h2><blockquote><p><strong>文件4种状态</strong></p></blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改，提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在不想提交的文件，或者要提交的文件没有提交上。</p><ul><li><strong>Untracked</strong>：未跟踪，此文件在文件夹种，并没有加入到git库，不参与版本控制，通过<code>git add</code> 状态变为 <code>staged</code></li><li><strong>Unmodify</strong>：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中的完全一致。这种类型的文件有两种去处，如果它被修改，而变为<code>Modified</code>，如果使用<code>git rm</code>移出版本库，则成为<code>untracked</code>文件</li><li><strong>Modified</strong>：文件已修改，仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过<code>git add</code>可以进入暂存<code>staged</code>状态，使用<code>git checkout</code>则丢弃修改，返回到<code>Unmodify</code>状态，这个<code>git checkout</code> 即从库中取出文件，覆盖当前修改。</li><li><strong>Staged</strong>：暂存状态。执行<code>git commit</code>则将修改同步到库中，这是库中文件和本地文件右边为一致，文件为<code>Unmodify</code>状态。执行<code>git reset HEAD filename</code>取消暂存，文件状态为<code>Modified</code>。</li></ul><blockquote><p><strong>查看文件状态</strong></p></blockquote><p>上面说文件有4种状态，通过如下命令可以查看文件的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看指定文件状态</span><br>git status [filename]<br><br><span class="hljs-comment"># 查看所有文件状态</span><br>git status<br><br><span class="hljs-comment"># 添加所有文件到暂存区</span><br>git add .<br><br><span class="hljs-comment"># 删除仓库中的&quot;README.en.md&quot;文件</span><br>git rm README.en.md<br><br><span class="hljs-comment"># 提交暂存区中内容到本地仓库，-m 提交信息</span><br>git commit -m <span class="hljs-string">&quot;for test&quot;</span><br><br><span class="hljs-comment"># 提交至远程仓库</span><br>git push<br></code></pre></td></tr></table></figure><blockquote><p><strong>忽略文件</strong></p></blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下面建立一个”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或者以井号(#)开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号(*)代表任意多字符，问号(?)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2,…})代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号(!)，表示例外规则，将不会忽略。</li><li>如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 为注释</span><br>*.txt      <span class="hljs-comment"># 忽略所有.txt结尾的文件，这样的话上传就不会被选中。</span><br>!lib.txt   <span class="hljs-comment"># 但lib.txt除外</span><br>/temp      <span class="hljs-comment"># 仅忽略根目录下的TODO文件，不包括其他目录temp</span><br>build/     <span class="hljs-comment"># 忽略build/目录下的所有文件</span><br>doc/*.txt  <span class="hljs-comment"># 会忽略doc/notes.txt但不包括doc/server/arch.txt</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通常前后端项目都需要的.gitignore的配置</span><br>*.class<br>*.<span class="hljs-built_in">log</span><br>*.lock<br><br><span class="hljs-comment"># Package Files #</span><br>*.jar<br>*.war<br>*.ear<br>target/<br><br><span class="hljs-comment"># idea</span><br>.idea/<br>*.iml<br><br>*velocity.log*<br><br><span class="hljs-comment">### STS ###</span><br>.apt_generated<br>.factorypath<br>.springBeans<br><br><span class="hljs-comment">### IntelliJ IDEA###</span><br>*.iml<br>*.ipr<br>*.iws<br>.idea<br>.classpath<br>.project<br>.settings/<br>bin/<br><br>*.<span class="hljs-built_in">log</span><br>tmp/<br><br><span class="hljs-comment">#rebel</span><br>*rebel.xml*<br></code></pre></td></tr></table></figure><h2 id="使用码云gitee"><a href="#使用码云gitee" class="headerlink" title="使用码云gitee"></a>使用码云gitee</h2><blockquote><p>国内一般使用gitee，而通常全球范围内大多都是用github，两者使用几乎一致，有些公司会自己搭建gitlab服务器</p></blockquote><ol><li><p>注册登录码云，完善个人信息，点击自己头像选设置</p></li><li><p>设置本机绑定SSH公钥，实现免密码登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入C:\Users\Administrator\.ssh目录</span><br><span class="hljs-comment"># 生成公钥，-t rsa是选择加密方式</span><br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_11_%E5%85%AC%E9%92%A5%E7%94%9F%E6%88%90%E7%BB%93%E6%9E%9C.png"></p></li><li><p>将公钥信息public key (打开上面的<code>.pub</code>文件，这就是公钥)添加到码云账户中即可</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_12_%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%A4%84.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_13_%E6%B7%BB%E5%8A%A0%E6%88%90%E5%8A%9F%E5%90%8E.png"></p></li><li><p>使用码云创建自己的仓库</p><p>新建仓库的位置</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_14_%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%931.png"></p><p>若公开的话有一个许可证选项：</p><p>开源是否可以随意转载，开源但是不能商用，等等各种限制协议。</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_15_%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png"></p></li><li><p>最后克隆至本地即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://gitee.com/lihengxu/gitstudy.git<br></code></pre></td></tr></table></figure></li></ol><h2 id="IDEA中集成Git"><a href="#IDEA中集成Git" class="headerlink" title="IDEA中集成Git"></a>IDEA中集成Git</h2><p> <strong>(和Pycharm基本相同)</strong></p><ol><li>新建项目，绑定git<ul><li>将远程的git文件目录直接拷贝到项目中即可，或者直接创建项目到git文件目录下</li></ul></li><li>修改文件，使用IDEA操作git<ul><li>添加到暂存区：命令行 <code>git add .</code> ；或者手动鼠标右键点文件，选GIt然后点Add</li><li>commit提交：界面右上角有一个commit选项，点击后选择，并输入一下message即可</li><li>push到远程仓库：直接在命令行中输入<code>git push</code>即可</li></ul></li><li>提交测试</li></ol><hr><p><strong>以上全部都不涉及分支，全是单人操作</strong></p><hr><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支类似平行宇宙的概念，适用于多人协同开发</p><p>当存在多个分支，我们进行分支合并时，可能会有冲突产生</p><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/gitstudy_16_git%E5%88%86%E6%94%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>git分支中常见命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>git branch<br><br><span class="hljs-comment"># 列出所偶远程分支</span><br>git branch -r<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>git branch [branch -name]<br><br><span class="hljs-comment"># 切换到该分支</span><br>git checkout [branch]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><br><span class="hljs-comment"># 重命名分支</span><br>git branch -m [branch -oldname] [branch -newname]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 中止这一次提交的合并(当遇到冲突时)</span><br>$ git merge --abort<br><br><span class="hljs-comment"># 将分支变基(Rebase)到master</span><br><span class="hljs-comment"># 先切换到分支，再完成变基</span><br>$ git checkout [branch]<br>$ git rebase master<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch -name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch -name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><blockquote><p>想要形象的快速理解分支的概念，推荐一款图形化客户端<a href="https://www.gitkraken.com/">GitKraken</a></p></blockquote><blockquote><p>建议使用github账号关联登录，这里推荐<a href="https://www.bilibili.com/video/BV1KD4y1S7FL">教程</a>以及关于分支的进阶<a href="https://www.bilibili.com/video/bv1hA411v7qX/">教程</a></p></blockquote><p>注意主分支master应该非常稳定，只有分支代码稳定之后才能合并到主分支上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Git其实还是比较简单的，很多命令其实只要多用就能熟悉，尤其时分支的操作，这部分用图形界面多使用就能理解得更深刻</li><li>gitee下面有一个git大全，更多得一些插件，命令都能在里面查询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

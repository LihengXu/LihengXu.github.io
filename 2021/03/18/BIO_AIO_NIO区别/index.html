

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/xiao.png">
  <link rel="icon" href="/img/bg/xiao.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>BIO_AIO_NIO区别 - LihengXu&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"zTPGNcnnYmT218Av5iBL8nGh-gzGzoHsz","app_key":"Nk68rUDzBxauuv3b7ro1QdtD","server_url":"https://ztpgncnn.lc-cn-n1-shared.com"}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>LihengXu</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                about
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/example.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="BIO_AIO_NIO区别">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-18 21:40" pubdate>
        March 18, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      102
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">BIO_AIO_NIO区别</h1>
            
            <div class="markdown-body">
              <h1 id="BIO-AIO-NIO区别"><a href="#BIO-AIO-NIO区别" class="headerlink" title="BIO_AIO_NIO区别"></a>BIO_AIO_NIO区别</h1><blockquote>
<p>简单对比：</p>
<ul>
<li>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题的关键其实就是理解同步/异步、阻塞/非阻塞的含义。</p>
<p>最初我看了很多blog以及一些所谓的面试考题讲解视频，以为理解了同步/异步、阻塞/非阻塞的含义，但其实越想越经不起推敲</p>
<p>比如下面的一些理解（我认为是不对的）：</p>
<blockquote>
<p><del>同步和异步（针对请求），阻塞和非阻塞（针对客户端）</del></p>
<p><del>在网络请求中，客户端会发出一个请求到服务端</del></p>
<ol>
<li><del>客户端发了请求后，就一直等着服务端的返回相应。 客户端：阻塞。 请求：同步</del></li>
<li><del>客户端发了请求后，就去干别的事情了，时不时来检查服务端是否给出了响应。 客户端：非阻塞。 请求： 同步。</del></li>
<li><del>换成异步请求后，客户端发出请求后，就坐在椅子上，等着服务端的返回相应。 客户端：阻塞。 请求：异步。</del></li>
<li><del>客户端发出请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。 客户端：阻塞。 请求：异步。</del></li>
</ol>
</blockquote>
<p>像这样举通俗的例子来说明这几个概念，通常都经不起推敲，原因在于，例子中缺少了一个“操作系统”级别的调度者。</p>
<ul>
<li><p>阻塞非阻塞是跟进程/线程严密相关的，而进程/线程又是依赖于操作系统存在的，所以自然不能脱离操作系统来讨论阻塞非阻塞。</p>
</li>
<li><p>同步/异步也是跟任务流相关的，所以举例子必须考虑到并发的任务流，不然，肯定很难举出恰当的例子的。</p>
</li>
</ul>
<p>本文的讨论：</p>
<ul>
<li><p>限定Linux环境下的network IO作为背景来讨论同步/异步、阻塞/非阻塞的理解。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=" UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models
">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/historyasamirror/article/details/5778378
">[2]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/112810033
">[4]</span></a></sup></p>
</li>
<li><p>讨论Java中对应的编程模型</p>
</li>
<li><p>对比BIO/NIO的区别<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/83597838
">[3]</span></a></sup></p>
</li>
</ul>
<h2 id="1-Linux下的五种I-O模型"><a href="#1-Linux下的五种I-O模型" class="headerlink" title="1.  Linux下的五种I/O模型"></a>1.  Linux下的五种I/O模型</h2><p>Stevens在文章中一共比较了五种IO Model：</p>
<ul>
<li>blocking IO</li>
<li>nonblocking IO</li>
<li>IO multiplexing</li>
<li>signal driven IO</li>
<li>asynchronous IO</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p>
<blockquote>
<p>IO发生时涉及的对象和步骤:</p>
<ul>
<li>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象:<ul>
<li>一个是调用这个IO的process (or thread)</li>
<li>另一个就是系统内核(kernel)</li>
</ul>
</li>
<li>当一个read操作发生时，它会经历两个阶段：<br>   1 等待数据准备 (Waiting for the data to be ready)<br>   2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
<li>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</li>
</ul>
</blockquote>
<h3 id="1-1-阻塞I-O（blocking-I-O）"><a href="#1-1-阻塞I-O（blocking-I-O）" class="headerlink" title="1.1 阻塞I/O（blocking I/O）"></a>1.1 阻塞I/O（blocking I/O）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样:</p>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
</li>
</ul>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。以下是java实现的服务器bio代码（需要掌握），注意阻塞方法阻塞的第一个阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BIO阻塞代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTcpSocket</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建一个ServerSocket连接</span><br>            <span class="hljs-keyword">final</span> ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>            <span class="hljs-comment">// 2.绑定端口号</span><br>            serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 3.当前线程放弃cpu资源等待获取数据</span><br>            System.out.println(<span class="hljs-string">&quot;等待获取数据...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept(); <span class="hljs-comment">// 阻塞方法</span><br>                executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            System.out.println(<span class="hljs-string">&quot;获取到数据...&quot;</span>);<br>                            <span class="hljs-comment">// 4.读取数据</span><br>                            <span class="hljs-keyword">int</span> read = socket.getInputStream().read(bytes); <span class="hljs-comment">// 会阻塞</span><br>                            String result = <span class="hljs-keyword">new</span> String(bytes);<br>                            System.out.println(result);<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                        &#125;<br>                    &#125;<br>                &#125;);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用程序</strong>想要读取数据就会调用<code>recvfrom</code>,而<code>recvfrom</code>会通知OS来执行，OS就会判断<strong>数据报是否准备好</strong>(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会<strong>将数据从内核空间拷贝到用户空间</strong>(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后<code>socket.read()</code>就会解除阻塞，并得到read的结果。</p>
<h3 id="1-2-非阻塞（Non-Blocking-IO）"><a href="#1-2-非阻塞（Non-Blocking-IO）" class="headerlink" title="1.2 非阻塞（Non-Blocking IO）"></a>1.2 非阻塞（Non-Blocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
</li>
</ul>
<p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。一定要注意这个地方，<strong>Non-Blocking还是会阻塞的</strong>。</p>
<p>以下是java实现的服务器bio代码（需要掌握），注意数据准备阶段是非阻塞方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NIO非阻塞式代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerNioTcpSocket</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建一个ServerSocketChannel连接</span><br>            <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">// 2.绑定端口号</span><br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 设置为非阻塞式</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 非阻塞式</span><br>            SocketChannel socketChannel = serverSocketChannel.accept(); <br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> j = socketChannel.read(byteBuffer);  <span class="hljs-comment">// 此处不会阻塞</span><br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">byte</span>[] bytes = Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());<br>                    System.out.println(<span class="hljs-string">&quot;获取到数据&quot;</span> + <span class="hljs-keyword">new</span> String(bytes));<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;程序执行完毕..&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>NIO中提供了集中Channel：<code>ServerSocketChannel；SocketChannel；FileChannel；</code> <code>DatagramChannel</code>只有<code>FileChannel</code>无法设置成非阻塞模式，其他Channel都可以设置为非阻塞模式。</p>
<p>当设置为非阻塞后，我们的<code>socket.read()</code>方法就会立即得到一个返回结果(成功 or 失败)，我们可以根据返回结果执行不同的逻辑，比如在失败时，我们可以做一些其他的事情。但事实上这种方式也是低效的，因为我们不得不使用轮询方法区一直问OS：“我的数据好了没啊”。第一个代码是该线程不断的轮询，第二个代码是使用selector实现轮询等待有效请求。</p>
<p>NIO 不会在<code>recvfrom</code>也就是<code>socket.read()</code>时候阻塞，但是还是会在<strong>将数据从内核空间拷贝到用户空间</strong>阻塞。</p>
<h3 id="1-3-I-O复用-IO-multiplexing"><a href="#1-3-I-O复用-IO-multiplexing" class="headerlink" title="1.3 I/O复用 IO multiplexing"></a>1.3 I/O复用 IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。</p>
<p>有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>
<p>它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png" srcset="/img/loading.gif"></p>
<p>这里用java的NIO示意select</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>); <br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待事件发生...&quot;</span>);<br>            <span class="hljs-comment">// 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br>            <span class="hljs-keyword">int</span> select = selector.select(); <br><br>            System.out.println(<span class="hljs-string">&quot;事件发生了...&quot;</span>);<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectionKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                <span class="hljs-comment">// 删除本次已处理的key， 防止下次select重复处理</span><br>                it.remove();<br>                handle(key);<br>            &#125;      <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了...&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">// 处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 通过Selector监听Channel时对读事件感兴趣</span><br>            sc.register(selector, SelectionKey.OP_READ); <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了...&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据:&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br>            ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes());<br>            sc.write(bufferToWrite);<br>            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable) &#123;<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            System.out.println(<span class="hljs-string">&quot;write事件...&quot;</span>);<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br>            <span class="hljs-comment">// 在有数据往外写的时候在注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">// sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<blockquote>
<p>多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
</blockquote>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="1-4-异步I-O-Asynchronous-IO"><a href="#1-4-异步I-O-Asynchronous-IO" class="headerlink" title="1.4 异步I/O(Asynchronous IO)"></a>1.4 异步I/O(Asynchronous IO)</h3><p>linux下的asynchronous IO其实用得很少(所以这里就不贴AIO的java代码了，一般不要求掌握）。先看一下它的流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png" srcset="/img/loading.gif"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。</p>
<p>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。</p>
<h3 id="1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解"><a href="#1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解" class="headerlink" title="1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解"></a>1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解</h3><p>其实是POSIX的定义是这样子的：</p>
<ul>
<li><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
</li>
<li><p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</li>
</ul>
<p>核心区别是：synchronous IO做”IO operation”的时候会将process阻塞</p>
<ol>
<li><p>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
</li>
<li><p>而asynchronous IO,当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
</li>
</ol>
<blockquote>
<p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png" srcset="/img/loading.gif"></p>
<p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h3 id="1-6-select，poll，epoll区别"><a href="#1-6-select，poll，epoll区别" class="headerlink" title="1.6 select，poll，epoll区别"></a>1.6 select，poll，epoll区别</h3><p>知乎这篇文章把底层讲得很清楚（一共三篇）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64746509">https://zhuanlan.zhihu.com/p/64746509</a></p>
<p>他们是NIO中多路复用的三种实用机制（底层是三个C++的API），是由Linux操作系统提供的。</p>
<p>Unix，Linux操作系统的一些基本知识：</p>
<ul>
<li><p>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间</p>
</li>
<li><p>文件描述符File Descriptor（FD）：是一个抽象概念，形式上是一个整数，实际上是一个索引值。指向内核中为每一个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD。</p>
</li>
</ul>
<blockquote>
<p>select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。（fd_set是一个数组结构，拷贝大小受限制 x64最大2048）</p>
<p>poll机制：和select机制差不多的。将fd_set结构进行了优化，FD集合大小突破了操作系统限制。（pollfd结构来代替fd_set，通过链表实现的）</p>
<p>Epoll机制：Event Poll不在扫描所有的FD，只将用户关心的FD的事件存放到内核的一个事件表当中。可以减少用户空间与内核空间之间需要拷贝的数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody><tr>
<td>select（1984）</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll（1997）</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll（2002）</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody></table>
<p>Java NIO当中是使用哪一种机制？</p>
<p>基于内核版本，可以查看DefaultSelectorProvider源码：</p>
<ul>
<li><p>windows下，WindowsSelectorProvider。</p>
</li>
<li><p>Linux下，内核2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。</p>
</li>
</ul>
<h2 id="2-Java的IO编程模型"><a href="#2-Java的IO编程模型" class="headerlink" title="2. Java的IO编程模型"></a>2. Java的IO编程模型</h2><blockquote>
<p>BIO 同步阻塞IO。 可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。</p>
<p>编程模型最简单。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png" srcset="/img/loading.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复习黑马文件上传的服务端BIO代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUpload_Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器 启动..... &quot;</span>);<br>        <span class="hljs-comment">// 1. 创建服务端ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2. 循环接收,建立连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket accept = serverSocket.accept(); <span class="hljs-comment">// 阻塞方法</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            3. socket对象交给子线程处理,进行读写操作</span><br><span class="hljs-comment">            Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">new</span> Thread(() ‐&gt; &#123;<br>                <span class="hljs-keyword">try</span> (<br>                    <span class="hljs-comment">//3.1 获取输入流对象</span><br>                    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(accept.getInputStream());<br>                    <span class="hljs-comment">//3.2 创建输出流对象, 保存到本地 .</span><br>                    FileOutputStream fis = <span class="hljs-keyword">new</span> FileOutputStream(System.currentTimeMillis() +<br>                    <span class="hljs-string">&quot;.jpg&quot;</span>);<br>                    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fis);) &#123;<br>                    <span class="hljs-comment">// 3.3 读写数据</span><br>                    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">8</span>];<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">while</span> ((len = bis.read(b)) != ‐<span class="hljs-number">1</span>) &#123;<br>                        bos.write(b, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    <span class="hljs-comment">//4. 关闭 资源</span><br>                    bos.close();<br>                    bis.close();<br>                    accept.close();<br>                    System.out.println(<span class="hljs-string">&quot;文件上传已保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是如果不活跃的连接逐渐增多，线程池里的线程慢慢的也都开始阻塞等待IO，线程池里真正在运行的线程数会越来越少，当线程池处理不过来时，会放置到线程池配置的BlockingQueue中，队列塞满后，慢慢的线程池中线程的数目会逐渐达到线程池配置的maximumPoolSize，如果再处理不过来，执行拒绝策略。也就是说，<code>最终会导致请求无法及时处理。</code></p>
<p>这样带来的问题是，假设有线程池corePoolSize设置为100，只要有100个不活跃的连接正在阻塞读写IO，就会把前corePoolSize线程都阻塞住，后续的请求就无法及时处理。</p>
<blockquote>
<p>NIO 同步非阻塞IO。 可靠性比较好，吞吐量也比较高，适用于连接比较多且连接比较短（轻操作）。例如聊天室。JDK1.4开始支持。（应用最广）</p>
<p>编程模型最复杂。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif"></p>
<p>NIO非阻塞体现:</p>
<ul>
<li>accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</li>
<li>首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</li>
</ul>
<p>(我的一些看法，java的NIO就是Linux中IO复用和NIO两个模型的结合)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>); <br>        ssc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待事件发生...&quot;</span>);<br>            <span class="hljs-comment">// 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br>            <span class="hljs-keyword">int</span> select = selector.select(); <br><br>            System.out.println(<span class="hljs-string">&quot;事件发生了...&quot;</span>);<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectionKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                <span class="hljs-comment">// 删除本次已处理的key， 防止下次select重复处理</span><br>                it.remove();<br>                handle(key);<br>            &#125;      <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了...&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">// 处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 通过Selector监听Channel时对读事件感兴趣</span><br>            sc.register(selector, SelectionKey.OP_READ); <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了...&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据:&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br>            ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes());<br>            sc.write(bufferToWrite);<br>            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable) &#123;<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            System.out.println(<span class="hljs-string">&quot;write事件...&quot;</span>);<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br>            <span class="hljs-comment">// 在有数据往外写的时候在注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">// sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>AIO 异步非阻塞IO。解决了服务端需要一直守着线程的问题，可靠性是最好的，吞吐量也是非常高的，适用于连接比较多且比较长（重操作）。 例如相册服务器。 JDK7开始支持。</p>
<p>编程模型比较简单，但需要操作系统来支持异步服务。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端代码(了解)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIOServer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open().bind(<span class="hljs-keyword">new</span> InewSocketAddress(<span class="hljs-number">9000</span>));<br>        <br>        serverChannel.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHander&lt;AsynchronousServerSocketChannel, Object&gt;())&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(AsynchronousServerSocketChannel socketChannel, Object attachment)</span></span>&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-comment">// 再次接受客户端连接，如果不写这一行代码后面的客户端连接不上服务器端</span><br>                    serverChannel.accept(attachment, <span class="hljs-keyword">this</span>);<br>                    System.out.println(socketChannel.getRemoteAddress());<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    socketChannel.read(buffer, buffer, <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer buffer)</span></span>&#123;<br>                            buffer.flip();<br>                            System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, result));<br>                            socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes()));<br>                        &#125;<br>                        <br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;exc.printStackTrace();&#125;<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;exc.printStackTrace();&#125;<br>        &#125;);<br>        <br>        Thread.sleep(Integer.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="3-BIO-NIO区别"><a href="#3-BIO-NIO区别" class="headerlink" title="3. BIO/NIO区别"></a>3. BIO/NIO区别</h2><p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif"></p>
<h2 id="4-BIO、NIO、AIO适用场景"><a href="#4-BIO、NIO、AIO适用场景" class="headerlink" title="4. BIO、NIO、AIO适用场景"></a>4. BIO、NIO、AIO适用场景</h2><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h2 id="5-Java-NIO的3个核心组件"><a href="#5-Java-NIO的3个核心组件" class="headerlink" title="5. Java NIO的3个核心组件"></a>5. Java NIO的3个核心组件</h2><blockquote>
<p>NIO重点:</p>
<p>Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>简单解释：</p>
</blockquote>
<ul>
<li><p>每一个channel对应一个buffer缓冲区。</p>
</li>
<li><p>channel会注册到selector。</p>
</li>
<li><p>selector会根据channel上发生的读写事件，将请求交由某一个空闲线程处理。</p>
</li>
<li><p>selector对应一个或者多个线程。</p>
</li>
<li><p>buffer和channel都是可读可写的。</p>
</li>
</ul>
<h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p>
<p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p>
<p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p>
<p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p>
<ul>
<li>ByteBuffer：字节缓冲区</li>
<li>CharBuffer:字符缓冲区</li>
<li>ShortBuffer：短整型缓冲区</li>
<li>IntBuffer：整型缓冲区</li>
<li>LongBuffer:长整型缓冲区</li>
<li>FloatBuffer：浮点型缓冲区</li>
<li>DoubleBuffer：双精度浮点型缓冲区</li>
</ul>
<h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p>
<p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p>
<p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p>
<p>Channel有四种实现：</p>
<ul>
<li>FileChannel:是从文件中读取数据。</li>
<li>DatagramChannel:从UDP网络中读取或者写入数据。</li>
<li>SocketChannel:从TCP网络中读取或者写入数据。</li>
<li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li>
</ul>
<h3 id="5-3-多路复用器Selector"><a href="#5-3-多路复用器Selector" class="headerlink" title="5.3 多路复用器Selector"></a>5.3 多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p>
<p><strong>关键对象</strong></p>
<ul>
<li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li>
<li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li>
</ul>
<p><strong>监听注册</strong></p>
<p>监听注册在Selector</p>
<blockquote>
<p>socketChannel.register(selector, SelectionKey.OP_READ);</p>
</blockquote>
<p><strong>监听的事件有</strong></p>
<ul>
<li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li>
<li>OP_READ: 读取就绪，socketChannel使用</li>
<li>OP_WRITE: 写入就绪，socketChannel使用</li>
<li>OP_CONNECT: 连接就绪，socketChannel使用</li>
</ul>
<h3 id="5-4-NIO的一些应用和框架"><a href="#5-4-NIO的一些应用和框架" class="headerlink" title="5.4 NIO的一些应用和框架"></a>5.4 NIO的一些应用和框架</h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83597838">https://zhuanlan.zhihu.com/p/83597838</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112810033">https://zhuanlan.zhihu.com/p/112810033</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/IO/">IO</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/Network/">Network</a>
                    
                      <a class="hover-with-bg" href="/tags/IO/">IO</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/23/%E8%AE%A1%E7%BD%91/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络总结</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/15/MySQL%E5%B9%B6%E5%8F%91%E6%97%B6%E7%BB%8F%E5%85%B8%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">
                        <span class="hidden-mobile">MySQL并发时经典的死锁及解决方法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "zTPGNcnnYmT218Av5iBL8nGh-gzGzoHsz",
          app_key: "Nk68rUDzBxauuv3b7ro1QdtD",
          placeholder: "吐槽",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "https://ztpgncnn.lc-cn-n1-shared.com",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
